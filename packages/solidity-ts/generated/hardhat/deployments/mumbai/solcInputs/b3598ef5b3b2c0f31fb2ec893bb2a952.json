{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAccessControl } from './IAccessControl.sol';\nimport { AccessControlInternal } from './AccessControlInternal.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControl is IAccessControl, AccessControlInternal {\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function grantRole(\n        bytes32 role,\n        address account\n    ) external onlyRole(_getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool) {\n        return _hasRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32) {\n        return _getRoleAdmin(role);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function revokeRole(\n        bytes32 role,\n        address account\n    ) external onlyRole(_getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function renounceRole(bytes32 role) external {\n        _renounceRole(role);\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { UintUtils } from '../../utils/UintUtils.sol';\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\nimport { AccessControlStorage } from './AccessControlStorage.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControlInternal is IAccessControlInternal {\n    using AddressUtils for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using UintUtils for uint256;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function _hasRole(\n        bytes32 role,\n        address account\n    ) internal view virtual returns (bool) {\n        return\n            AccessControlStorage.layout().roles[role].members.contains(account);\n    }\n\n    /**\n     * @notice revert if sender does not have given role\n     * @param role role to query\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, msg.sender);\n    }\n\n    /**\n     * @notice revert if given account does not have given role\n     * @param role role to query\n     * @param account to query\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!_hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        'AccessControl: account ',\n                        account.toString(),\n                        ' is missing role ',\n                        uint256(role).toHexString(32)\n                    )\n                )\n            );\n        }\n    }\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function _getRoleAdmin(\n        bytes32 role\n    ) internal view virtual returns (bytes32) {\n        return AccessControlStorage.layout().roles[role].adminRole;\n    }\n\n    /**\n     * @notice set role as admin role\n     * @param role role to set\n     * @param adminRole admin role to set\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = _getRoleAdmin(role);\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.remove(account);\n        emit RoleRevoked(role, account, msg.sender);\n    }\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function _renounceRole(bytes32 role) internal virtual {\n        _revokeRole(role, msg.sender);\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\n\nlibrary AccessControlStorage {\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) roles;\n    }\n\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.AccessControl');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\n\n/**\n * @title AccessControl interface\n */\ninterface IAccessControl is IAccessControlInternal {\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool);\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function renounceRole(bytes32 role) external;\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial AccessControl interface needed by internal functions\n */\ninterface IAccessControlInternal {\n    event RoleAdminChanged(\n        bytes32 indexed role,\n        bytes32 indexed previousAdminRole,\n        bytes32 indexed newAdminRole\n    );\n\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n}\n"
    },
    "@solidstate/contracts/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Merkle tree verification utility\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary MerkleProof {\n    /**\n     * @notice verify whether given leaf is contained within Merkle tree defined by given root\n     * @param proof proof that Merkle tree contains given leaf\n     * @param root Merkle tree root\n     * @param leaf element whose presence in Merkle tree to prove\n     * @return whether leaf is proven to be contained within Merkle tree defined by root\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        unchecked {\n            bytes32 computedHash = leaf;\n\n            for (uint256 i = 0; i < proof.length; i++) {\n                bytes32 proofElement = proof[i];\n\n                if (computedHash <= proofElement) {\n                    computedHash = keccak256(\n                        abi.encodePacked(computedHash, proofElement)\n                    );\n                } else {\n                    computedHash = keccak256(\n                        abi.encodePacked(proofElement, computedHash)\n                    );\n                }\n            }\n\n            return computedHash == root;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/data/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Map implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableMap {\n    error EnumerableMap__IndexOutOfBounds();\n    error EnumerableMap__NonExistentKey();\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        MapEntry[] _entries;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct AddressToAddressMap {\n        Map _inner;\n    }\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    function at(\n        AddressToAddressMap storage map,\n        uint256 index\n    ) internal view returns (address, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n\n        return (\n            address(uint160(uint256(key))),\n            address(uint160(uint256(value)))\n        );\n    }\n\n    function at(\n        UintToAddressMap storage map,\n        uint256 index\n    ) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    function contains(\n        AddressToAddressMap storage map,\n        address key\n    ) internal view returns (bool) {\n        return _contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    function contains(\n        UintToAddressMap storage map,\n        uint256 key\n    ) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    function length(\n        AddressToAddressMap storage map\n    ) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    function length(\n        UintToAddressMap storage map\n    ) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    function get(\n        AddressToAddressMap storage map,\n        address key\n    ) internal view returns (address) {\n        return\n            address(\n                uint160(\n                    uint256(_get(map._inner, bytes32(uint256(uint160(key)))))\n                )\n            );\n    }\n\n    function get(\n        UintToAddressMap storage map,\n        uint256 key\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    function set(\n        AddressToAddressMap storage map,\n        address key,\n        address value\n    ) internal returns (bool) {\n        return\n            _set(\n                map._inner,\n                bytes32(uint256(uint160(key))),\n                bytes32(uint256(uint160(value)))\n            );\n    }\n\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        AddressToAddressMap storage map,\n        address key\n    ) internal returns (bool) {\n        return _remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    function remove(\n        UintToAddressMap storage map,\n        uint256 key\n    ) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    function toArray(\n        AddressToAddressMap storage map\n    )\n        internal\n        view\n        returns (address[] memory keysOut, address[] memory valuesOut)\n    {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new address[](len);\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._key))\n                );\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function toArray(\n        UintToAddressMap storage map\n    )\n        internal\n        view\n        returns (uint256[] memory keysOut, address[] memory valuesOut)\n    {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new uint256[](len);\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = uint256(map._inner._entries[i]._key);\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function keys(\n        AddressToAddressMap storage map\n    ) internal view returns (address[] memory keysOut) {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._key))\n                );\n            }\n        }\n    }\n\n    function keys(\n        UintToAddressMap storage map\n    ) internal view returns (uint256[] memory keysOut) {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new uint256[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = uint256(map._inner._entries[i]._key);\n            }\n        }\n    }\n\n    function values(\n        AddressToAddressMap storage map\n    ) internal view returns (address[] memory valuesOut) {\n        uint256 len = map._inner._entries.length;\n\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function values(\n        UintToAddressMap storage map\n    ) internal view returns (address[] memory valuesOut) {\n        uint256 len = map._inner._entries.length;\n\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function _at(\n        Map storage map,\n        uint256 index\n    ) private view returns (bytes32, bytes32) {\n        if (index >= map._entries.length)\n            revert EnumerableMap__IndexOutOfBounds();\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    function _contains(\n        Map storage map,\n        bytes32 key\n    ) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) revert EnumerableMap__NonExistentKey();\n        unchecked {\n            return map._entries[keyIndex - 1]._value;\n        }\n    }\n\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) {\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            unchecked {\n                map._entries[keyIndex - 1]._value = value;\n            }\n            return false;\n        }\n    }\n\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) {\n            unchecked {\n                MapEntry storage last = map._entries[map._entries.length - 1];\n\n                // move last entry to now-vacant index\n                map._entries[keyIndex - 1] = last;\n                map._indexes[last._key] = keyIndex;\n            }\n\n            // clear last index\n            map._entries.pop();\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/data/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    error EnumerableSet__IndexOutOfBounds();\n\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(\n        Bytes32Set storage set,\n        uint256 index\n    ) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    function at(\n        AddressSet storage set,\n        uint256 index\n    ) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(\n        UintSet storage set,\n        uint256 index\n    ) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    function contains(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function contains(\n        AddressSet storage set,\n        address value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function indexOf(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, value);\n    }\n\n    function indexOf(\n        AddressSet storage set,\n        address value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function indexOf(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(value));\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function add(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function remove(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        UintSet storage set,\n        uint256 value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function toArray(\n        Bytes32Set storage set\n    ) internal view returns (bytes32[] memory) {\n        return set._inner._values;\n    }\n\n    function toArray(\n        AddressSet storage set\n    ) internal view returns (address[] memory) {\n        bytes32[] storage values = set._inner._values;\n        address[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function toArray(\n        UintSet storage set\n    ) internal view returns (uint256[] memory) {\n        bytes32[] storage values = set._inner._values;\n        uint256[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function _at(\n        Set storage set,\n        uint256 index\n    ) private view returns (bytes32) {\n        if (index >= set._values.length)\n            revert EnumerableSet__IndexOutOfBounds();\n        return set._values[index];\n    }\n\n    function _contains(\n        Set storage set,\n        bytes32 value\n    ) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _indexOf(\n        Set storage set,\n        bytes32 value\n    ) private view returns (uint256) {\n        unchecked {\n            return set._indexes[value] - 1;\n        }\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            status = true;\n        }\n    }\n\n    function _remove(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            unchecked {\n                bytes32 last = set._values[set._values.length - 1];\n\n                // move last value to now-vacant index\n\n                set._values[valueIndex - 1] = last;\n                set._indexes[last] = valueIndex;\n            }\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            status = true;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\nimport { IERC1155Internal } from './IERC1155Internal.sol';\n\n/**\n * @title ERC1155 interface\n * @dev see https://github.com/ethereum/EIPs/issues/1155\n */\ninterface IERC1155 is IERC1155Internal, IERC165 {\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external view returns (uint256);\n\n    /**\n     * @notice query the balances of given tokens held by given addresses\n     * @param accounts addresss to query\n     * @param ids tokens to query\n     * @return token balances\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool);\n\n    /**\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\n     * @param operator address whose approval status to update\n     * @param status whether operator should be considered approved\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to transfer\n     * @param data data payload\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC1155 interface needed by internal functions\n */\ninterface IERC1155Internal {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\n\n/**\n * @title ERC1155 transfer receiver interface\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @notice validate receipt of ERC1155 transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param id token ID received\n     * @param value quantity of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @notice validate receipt of ERC1155 batch transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param ids token IDs received\n     * @param values quantities of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 is IERC165Internal {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n */\ninterface IERC165Internal {\n\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\nimport { IERC721Internal } from './IERC721Internal.sol';\n\n/**\n * @title ERC721 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721 is IERC721Internal, IERC165 {\n    /**\n     * @notice query the balance of given address\n     * @return balance quantity of tokens held\n     */\n    function balanceOf(address account) external view returns (uint256 balance);\n\n    /**\n     * @notice query the owner of given token\n     * @param tokenId token to query\n     * @return owner token owner\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, without checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice grant approval to given account to spend token\n     * @param operator address to be approved\n     * @param tokenId token to approve\n     */\n    function approve(address operator, uint256 tokenId) external payable;\n\n    /**\n     * @notice get approval status for given token\n     * @param tokenId token to query\n     * @return operator address approved to spend token\n     */\n    function getApproved(\n        uint256 tokenId\n    ) external view returns (address operator);\n\n    /**\n     * @notice grant approval to or revoke approval from given account to spend all tokens held by sender\n     * @param operator address to be approved\n     * @param status approval status\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return status whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool status);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC721 interface needed by internal functions\n */\ninterface IERC721Internal {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed operator,\n        uint256 indexed tokenId\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\nimport { IERC165Base } from './IERC165Base.sol';\nimport { ERC165BaseInternal } from './ERC165BaseInternal.sol';\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165Base is IERC165Base, ERC165BaseInternal {\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n        return _supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165BaseInternal is IERC165BaseInternal {\n    /**\n     * @notice indicates whether an interface is already supported based on the interfaceId\n     * @param interfaceId id of interface to check\n     * @return bool indicating whether interface is supported\n     */\n    function _supportsInterface(\n        bytes4 interfaceId\n    ) internal view returns (bool) {\n        return ERC165BaseStorage.layout().supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @notice sets status of interface support\n     * @param interfaceId id of interface to set status for\n     * @param status boolean indicating whether interface will be set as supported\n     */\n    function _setSupportsInterface(bytes4 interfaceId, bool status) internal {\n        if (interfaceId == 0xffffffff) revert ERC165Base__InvalidInterfaceId();\n        ERC165BaseStorage.layout().supportedInterfaces[interfaceId] = status;\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC165BaseStorage {\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC165Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/IERC165Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\n\ninterface IERC165Base is IERC165, IERC165BaseInternal {}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/IERC165BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165Internal } from '../../../interfaces/IERC165Internal.sol';\n\ninterface IERC165BaseInternal is IERC165Internal {\n    error ERC165Base__InvalidInterfaceId();\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155 } from '../../../interfaces/IERC1155.sol';\nimport { IERC1155Receiver } from '../../../interfaces/IERC1155Receiver.sol';\nimport { IERC1155Base } from './IERC1155Base.sol';\nimport { ERC1155BaseInternal, ERC1155BaseStorage } from './ERC1155BaseInternal.sol';\n\n/**\n * @title Base ERC1155 contract\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155Base is IERC1155Base, ERC1155BaseInternal {\n    /**\n     * @inheritdoc IERC1155\n     */\n    function balanceOf(\n        address account,\n        uint256 id\n    ) public view virtual returns (uint256) {\n        return _balanceOf(account, id);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual returns (uint256[] memory) {\n        if (accounts.length != ids.length)\n            revert ERC1155Base__ArrayLengthMismatch();\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        unchecked {\n            for (uint256 i; i < accounts.length; i++) {\n                if (accounts[i] == address(0))\n                    revert ERC1155Base__BalanceQueryZeroAddress();\n                batchBalances[i] = balances[ids[i]][accounts[i]];\n            }\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) public view virtual returns (bool) {\n        return ERC1155BaseStorage.layout().operatorApprovals[account][operator];\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function setApprovalForAll(address operator, bool status) public virtual {\n        if (msg.sender == operator) revert ERC1155Base__SelfApproval();\n        ERC1155BaseStorage.layout().operatorApprovals[msg.sender][\n            operator\n        ] = status;\n        emit ApprovalForAll(msg.sender, operator, status);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        if (from != msg.sender && !isApprovedForAll(from, msg.sender))\n            revert ERC1155Base__NotOwnerOrApproved();\n        _safeTransfer(msg.sender, from, to, id, amount, data);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        if (from != msg.sender && !isApprovedForAll(from, msg.sender))\n            revert ERC1155Base__NotOwnerOrApproved();\n        _safeTransferBatch(msg.sender, from, to, ids, amounts, data);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155Receiver } from '../../../interfaces/IERC1155Receiver.sol';\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { IERC1155BaseInternal } from './IERC1155BaseInternal.sol';\nimport { ERC1155BaseStorage } from './ERC1155BaseStorage.sol';\n\n/**\n * @title Base ERC1155 internal functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155BaseInternal is IERC1155BaseInternal {\n    using AddressUtils for address;\n\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function _balanceOf(\n        address account,\n        uint256 id\n    ) internal view virtual returns (uint256) {\n        if (account == address(0))\n            revert ERC1155Base__BalanceQueryZeroAddress();\n        return ERC1155BaseStorage.layout().balances[id][account];\n    }\n\n    /**\n     * @notice mint given quantity of tokens for given address\n     * @dev ERC1155Receiver implementation is not checked\n     * @param account beneficiary of minting\n     * @param id token ID\n     * @param amount quantity of tokens to mint\n     * @param data data payload\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__MintToZeroAddress();\n\n        _beforeTokenTransfer(\n            msg.sender,\n            address(0),\n            account,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        ERC1155BaseStorage.layout().balances[id][account] += amount;\n\n        emit TransferSingle(msg.sender, address(0), account, id, amount);\n    }\n\n    /**\n     * @notice mint given quantity of tokens for given address\n     * @param account beneficiary of minting\n     * @param id token ID\n     * @param amount quantity of tokens to mint\n     * @param data data payload\n     */\n    function _safeMint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _mint(account, id, amount, data);\n\n        _doSafeTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            account,\n            id,\n            amount,\n            data\n        );\n    }\n\n    /**\n     * @notice mint batch of tokens for given address\n     * @dev ERC1155Receiver implementation is not checked\n     * @param account beneficiary of minting\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to mint\n     * @param data data payload\n     */\n    function _mintBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__MintToZeroAddress();\n        if (ids.length != amounts.length)\n            revert ERC1155Base__ArrayLengthMismatch();\n\n        _beforeTokenTransfer(\n            msg.sender,\n            address(0),\n            account,\n            ids,\n            amounts,\n            data\n        );\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        for (uint256 i; i < ids.length; ) {\n            balances[ids[i]][account] += amounts[i];\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), account, ids, amounts);\n    }\n\n    /**\n     * @notice mint batch of tokens for given address\n     * @param account beneficiary of minting\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to mint\n     * @param data data payload\n     */\n    function _safeMintBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _mintBatch(account, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            account,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @notice burn given quantity of tokens held by given address\n     * @param account holder of tokens to burn\n     * @param id token ID\n     * @param amount quantity of tokens to burn\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__BurnFromZeroAddress();\n\n        _beforeTokenTransfer(\n            msg.sender,\n            account,\n            address(0),\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            ''\n        );\n\n        mapping(address => uint256) storage balances = ERC1155BaseStorage\n            .layout()\n            .balances[id];\n\n        unchecked {\n            if (amount > balances[account])\n                revert ERC1155Base__BurnExceedsBalance();\n            balances[account] -= amount;\n        }\n\n        emit TransferSingle(msg.sender, account, address(0), id, amount);\n    }\n\n    /**\n     * @notice burn given batch of tokens held by given address\n     * @param account holder of tokens to burn\n     * @param ids token IDs\n     * @param amounts quantities of tokens to burn\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__BurnFromZeroAddress();\n        if (ids.length != amounts.length)\n            revert ERC1155Base__ArrayLengthMismatch();\n\n        _beforeTokenTransfer(msg.sender, account, address(0), ids, amounts, '');\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        unchecked {\n            for (uint256 i; i < ids.length; i++) {\n                uint256 id = ids[i];\n                if (amounts[i] > balances[id][account])\n                    revert ERC1155Base__BurnExceedsBalance();\n                balances[id][account] -= amounts[i];\n            }\n        }\n\n        emit TransferBatch(msg.sender, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @notice transfer tokens between given addresses\n     * @dev ERC1155Receiver implementation is not checked\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _transfer(\n        address operator,\n        address sender,\n        address recipient,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        if (recipient == address(0))\n            revert ERC1155Base__TransferToZeroAddress();\n\n        _beforeTokenTransfer(\n            operator,\n            sender,\n            recipient,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        unchecked {\n            uint256 senderBalance = balances[id][sender];\n            if (amount > senderBalance)\n                revert ERC1155Base__TransferExceedsBalance();\n            balances[id][sender] = senderBalance - amount;\n        }\n\n        balances[id][recipient] += amount;\n\n        emit TransferSingle(operator, sender, recipient, id, amount);\n    }\n\n    /**\n     * @notice transfer tokens between given addresses\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _safeTransfer(\n        address operator,\n        address sender,\n        address recipient,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _transfer(operator, sender, recipient, id, amount, data);\n\n        _doSafeTransferAcceptanceCheck(\n            operator,\n            sender,\n            recipient,\n            id,\n            amount,\n            data\n        );\n    }\n\n    /**\n     * @notice transfer batch of tokens between given addresses\n     * @dev ERC1155Receiver implementation is not checked\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _transferBatch(\n        address operator,\n        address sender,\n        address recipient,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (recipient == address(0))\n            revert ERC1155Base__TransferToZeroAddress();\n        if (ids.length != amounts.length)\n            revert ERC1155Base__ArrayLengthMismatch();\n\n        _beforeTokenTransfer(operator, sender, recipient, ids, amounts, data);\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        for (uint256 i; i < ids.length; ) {\n            uint256 token = ids[i];\n            uint256 amount = amounts[i];\n\n            unchecked {\n                uint256 senderBalance = balances[token][sender];\n\n                if (amount > senderBalance)\n                    revert ERC1155Base__TransferExceedsBalance();\n\n                balances[token][sender] = senderBalance - amount;\n\n                i++;\n            }\n\n            // balance increase cannot be unchecked because ERC1155Base neither tracks nor validates a totalSupply\n            balances[token][recipient] += amount;\n        }\n\n        emit TransferBatch(operator, sender, recipient, ids, amounts);\n    }\n\n    /**\n     * @notice transfer batch of tokens between given addresses\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _safeTransferBatch(\n        address operator,\n        address sender,\n        address recipient,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _transferBatch(operator, sender, recipient, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            operator,\n            sender,\n            recipient,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @notice wrap given element in array of length 1\n     * @param element element to wrap\n     * @return singleton array\n     */\n    function _asSingletonArray(\n        uint256 element\n    ) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n        return array;\n    }\n\n    /**\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155Received(\n                    operator,\n                    from,\n                    id,\n                    amount,\n                    data\n                )\n            returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector)\n                    revert ERC1155Base__ERC1155ReceiverRejected();\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert ERC1155Base__ERC1155ReceiverNotImplemented();\n            }\n        }\n    }\n\n    /**\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155BatchReceived(\n                    operator,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                )\n            returns (bytes4 response) {\n                if (\n                    response != IERC1155Receiver.onERC1155BatchReceived.selector\n                ) revert ERC1155Base__ERC1155ReceiverRejected();\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert ERC1155Base__ERC1155ReceiverNotImplemented();\n            }\n        }\n    }\n\n    /**\n     * @notice ERC1155 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @dev called for both single and batch transfers\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC1155BaseStorage {\n    struct Layout {\n        mapping(uint256 => mapping(address => uint256)) balances;\n        mapping(address => mapping(address => bool)) operatorApprovals;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/IERC1155Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155 } from '../../../interfaces/IERC1155.sol';\nimport { IERC1155BaseInternal } from './IERC1155BaseInternal.sol';\n\n/**\n * @title ERC1155 base interface\n */\ninterface IERC1155Base is IERC1155BaseInternal, IERC1155 {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/IERC1155BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155Internal } from '../../../interfaces/IERC1155Internal.sol';\n\n/**\n * @title ERC1155 base interface\n */\ninterface IERC1155BaseInternal is IERC1155Internal {\n    error ERC1155Base__ArrayLengthMismatch();\n    error ERC1155Base__BalanceQueryZeroAddress();\n    error ERC1155Base__NotOwnerOrApproved();\n    error ERC1155Base__SelfApproval();\n    error ERC1155Base__BurnExceedsBalance();\n    error ERC1155Base__BurnFromZeroAddress();\n    error ERC1155Base__ERC1155ReceiverRejected();\n    error ERC1155Base__ERC1155ReceiverNotImplemented();\n    error ERC1155Base__MintToZeroAddress();\n    error ERC1155Base__TransferExceedsBalance();\n    error ERC1155Base__TransferToZeroAddress();\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/enumerable/ERC1155Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC1155BaseInternal } from '../base/ERC1155BaseInternal.sol';\nimport { IERC1155Enumerable } from './IERC1155Enumerable.sol';\nimport { ERC1155EnumerableInternal, ERC1155EnumerableStorage } from './ERC1155EnumerableInternal.sol';\n\n/**\n * @title ERC1155 implementation including enumerable and aggregate functions\n */\nabstract contract ERC1155Enumerable is\n    IERC1155Enumerable,\n    ERC1155EnumerableInternal\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply(id);\n    }\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function totalHolders(uint256 id) public view virtual returns (uint256) {\n        return _totalHolders(id);\n    }\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function accountsByToken(\n        uint256 id\n    ) public view virtual returns (address[] memory) {\n        return _accountsByToken(id);\n    }\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function tokensByAccount(\n        address account\n    ) public view virtual returns (uint256[] memory) {\n        return _tokensByAccount(account);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC1155BaseInternal, ERC1155BaseStorage } from '../base/ERC1155BaseInternal.sol';\nimport { ERC1155EnumerableStorage } from './ERC1155EnumerableStorage.sol';\n\n/**\n * @title ERC1155Enumerable internal functions\n */\nabstract contract ERC1155EnumerableInternal is ERC1155BaseInternal {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @notice query total minted supply of given token\n     * @param id token id to query\n     * @return token supply\n     */\n    function _totalSupply(uint256 id) internal view virtual returns (uint256) {\n        return ERC1155EnumerableStorage.layout().totalSupply[id];\n    }\n\n    /**\n     * @notice query total number of holders for given token\n     * @param id token id to query\n     * @return quantity of holders\n     */\n    function _totalHolders(uint256 id) internal view virtual returns (uint256) {\n        return ERC1155EnumerableStorage.layout().accountsByToken[id].length();\n    }\n\n    /**\n     * @notice query holders of given token\n     * @param id token id to query\n     * @return list of holder addresses\n     */\n    function _accountsByToken(\n        uint256 id\n    ) internal view virtual returns (address[] memory) {\n        EnumerableSet.AddressSet storage accounts = ERC1155EnumerableStorage\n            .layout()\n            .accountsByToken[id];\n\n        address[] memory addresses = new address[](accounts.length());\n\n        unchecked {\n            for (uint256 i; i < accounts.length(); i++) {\n                addresses[i] = accounts.at(i);\n            }\n        }\n\n        return addresses;\n    }\n\n    /**\n     * @notice query tokens held by given address\n     * @param account address to query\n     * @return list of token ids\n     */\n    function _tokensByAccount(\n        address account\n    ) internal view virtual returns (uint256[] memory) {\n        EnumerableSet.UintSet storage tokens = ERC1155EnumerableStorage\n            .layout()\n            .tokensByAccount[account];\n\n        uint256[] memory ids = new uint256[](tokens.length());\n\n        unchecked {\n            for (uint256 i; i < tokens.length(); i++) {\n                ids[i] = tokens.at(i);\n            }\n        }\n\n        return ids;\n    }\n\n    /**\n     * @notice ERC1155 hook: update aggregate values\n     * @inheritdoc ERC1155BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from != to) {\n            ERC1155EnumerableStorage.Layout storage l = ERC1155EnumerableStorage\n                .layout();\n            mapping(uint256 => EnumerableSet.AddressSet)\n                storage tokenAccounts = l.accountsByToken;\n            EnumerableSet.UintSet storage fromTokens = l.tokensByAccount[from];\n            EnumerableSet.UintSet storage toTokens = l.tokensByAccount[to];\n\n            for (uint256 i; i < ids.length; ) {\n                uint256 amount = amounts[i];\n\n                if (amount > 0) {\n                    uint256 id = ids[i];\n\n                    if (from == address(0)) {\n                        l.totalSupply[id] += amount;\n                    } else if (_balanceOf(from, id) == amount) {\n                        tokenAccounts[id].remove(from);\n                        fromTokens.remove(id);\n                    }\n\n                    if (to == address(0)) {\n                        l.totalSupply[id] -= amount;\n                    } else if (_balanceOf(to, id) == 0) {\n                        tokenAccounts[id].add(to);\n                        toTokens.add(id);\n                    }\n                }\n\n                unchecked {\n                    i++;\n                }\n            }\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\n\nlibrary ERC1155EnumerableStorage {\n    struct Layout {\n        mapping(uint256 => uint256) totalSupply;\n        mapping(uint256 => EnumerableSet.AddressSet) accountsByToken;\n        mapping(address => EnumerableSet.UintSet) tokensByAccount;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Enumerable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/enumerable/IERC1155Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155BaseInternal } from '../base/IERC1155BaseInternal.sol';\n\n/**\n * @title ERC1155 enumerable and aggregate function interface\n */\ninterface IERC1155Enumerable is IERC1155BaseInternal {\n    /**\n     * @notice query total minted supply of given token\n     * @param id token id to query\n     * @return token supply\n     */\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    /**\n     * @notice query total number of holders for given token\n     * @param id token id to query\n     * @return quantity of holders\n     */\n    function totalHolders(uint256 id) external view returns (uint256);\n\n    /**\n     * @notice query holders of given token\n     * @param id token id to query\n     * @return list of holder addresses\n     */\n    function accountsByToken(\n        uint256 id\n    ) external view returns (address[] memory);\n\n    /**\n     * @notice query tokens held by given address\n     * @param account address to query\n     * @return list of token ids\n     */\n    function tokensByAccount(\n        address account\n    ) external view returns (uint256[] memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from '../../../utils/UintUtils.sol';\nimport { IERC1155Metadata } from './IERC1155Metadata.sol';\nimport { ERC1155MetadataInternal } from './ERC1155MetadataInternal.sol';\nimport { ERC1155MetadataStorage } from './ERC1155MetadataStorage.sol';\n\n/**\n * @title ERC1155 metadata extensions\n */\nabstract contract ERC1155Metadata is IERC1155Metadata, ERC1155MetadataInternal {\n    using UintUtils for uint256;\n\n    /**\n     * @notice inheritdoc IERC1155Metadata\n     */\n    function uri(uint256 tokenId) public view virtual returns (string memory) {\n        ERC1155MetadataStorage.Layout storage l = ERC1155MetadataStorage\n            .layout();\n\n        string memory tokenIdURI = l.tokenURIs[tokenId];\n        string memory baseURI = l.baseURI;\n\n        if (bytes(baseURI).length == 0) {\n            return tokenIdURI;\n        } else if (bytes(tokenIdURI).length > 0) {\n            return string(abi.encodePacked(baseURI, tokenIdURI));\n        } else {\n            return string(abi.encodePacked(baseURI, tokenId.toString()));\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\nimport { ERC1155MetadataStorage } from './ERC1155MetadataStorage.sol';\n\n/**\n * @title ERC1155Metadata internal functions\n */\nabstract contract ERC1155MetadataInternal is IERC1155MetadataInternal {\n    /**\n     * @notice set base metadata URI\n     * @dev base URI is a non-standard feature adapted from the ERC721 specification\n     * @param baseURI base URI\n     */\n    function _setBaseURI(string memory baseURI) internal {\n        ERC1155MetadataStorage.layout().baseURI = baseURI;\n    }\n\n    /**\n     * @notice set per-token metadata URI\n     * @param tokenId token whose metadata URI to set\n     * @param tokenURI per-token URI\n     */\n    function _setTokenURI(uint256 tokenId, string memory tokenURI) internal {\n        ERC1155MetadataStorage.layout().tokenURIs[tokenId] = tokenURI;\n        emit URI(tokenURI, tokenId);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title ERC1155 metadata extensions\n */\nlibrary ERC1155MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Metadata');\n\n    struct Layout {\n        string baseURI;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\n\n/**\n * @title ERC1155Metadata interface\n */\ninterface IERC1155Metadata is IERC1155MetadataInternal {\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function uri(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC1155Metadata interface needed by internal functions\n */\ninterface IERC1155MetadataInternal {\n    event URI(string value, uint256 indexed tokenId);\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/ERC721Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721 } from '../../../interfaces/IERC721.sol';\nimport { IERC721Base } from './IERC721Base.sol';\nimport { ERC721BaseInternal } from './ERC721BaseInternal.sol';\n\n/**\n * @title Base ERC721 implementation, excluding optional extensions\n */\nabstract contract ERC721Base is IERC721Base, ERC721BaseInternal {\n    /**\n     * @inheritdoc IERC721\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balanceOf(account);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function ownerOf(uint256 tokenId) external view returns (address) {\n        return _ownerOf(tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function getApproved(uint256 tokenId) external view returns (address) {\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool) {\n        return _isApprovedForAll(account, operator);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable {\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable {\n        _safeTransferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external payable {\n        _safeTransferFrom(from, to, tokenId, data);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function approve(address operator, uint256 tokenId) external payable {\n        _approve(operator, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function setApprovalForAll(address operator, bool status) external {\n        _setApprovalForAll(operator, status);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/ERC721BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721Receiver } from '../../../interfaces/IERC721Receiver.sol';\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { IERC721BaseInternal } from './IERC721BaseInternal.sol';\nimport { ERC721BaseStorage } from './ERC721BaseStorage.sol';\n\n/**\n * @title Base ERC721 internal functions\n */\nabstract contract ERC721BaseInternal is IERC721BaseInternal {\n    using AddressUtils for address;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    function _balanceOf(\n        address account\n    ) internal view virtual returns (uint256) {\n        if (account == address(0)) revert ERC721Base__BalanceQueryZeroAddress();\n        return ERC721BaseStorage.layout().holderTokens[account].length();\n    }\n\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        address owner = ERC721BaseStorage.layout().tokenOwners.get(tokenId);\n        if (owner == address(0)) revert ERC721Base__InvalidOwner();\n        return owner;\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return ERC721BaseStorage.layout().tokenOwners.contains(tokenId);\n    }\n\n    function _getApproved(\n        uint256 tokenId\n    ) internal view virtual returns (address) {\n        if (!_exists(tokenId)) revert ERC721Base__NonExistentToken();\n\n        return ERC721BaseStorage.layout().tokenApprovals[tokenId];\n    }\n\n    function _isApprovedForAll(\n        address account,\n        address operator\n    ) internal view virtual returns (bool) {\n        return ERC721BaseStorage.layout().operatorApprovals[account][operator];\n    }\n\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view virtual returns (bool) {\n        if (!_exists(tokenId)) revert ERC721Base__NonExistentToken();\n\n        address owner = _ownerOf(tokenId);\n\n        return (spender == owner ||\n            _getApproved(tokenId) == spender ||\n            _isApprovedForAll(owner, spender));\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        if (to == address(0)) revert ERC721Base__MintToZeroAddress();\n        if (_exists(tokenId)) revert ERC721Base__TokenAlreadyMinted();\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\n\n        l.holderTokens[to].add(tokenId);\n        l.tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, '');\n    }\n\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        if (!_checkOnERC721Received(address(0), to, tokenId, data))\n            revert ERC721Base__ERC721ReceiverNotImplemented();\n    }\n\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = _ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\n\n        l.holderTokens[owner].remove(tokenId);\n        l.tokenOwners.remove(tokenId);\n\n        l.tokenApprovals[tokenId] = address(0);\n\n        emit Approval(owner, address(0), tokenId);\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        address owner = _ownerOf(tokenId);\n\n        if (owner != from) revert ERC721Base__NotTokenOwner();\n        if (to == address(0)) revert ERC721Base__TransferToZeroAddress();\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\n\n        l.holderTokens[from].remove(tokenId);\n        l.holderTokens[to].add(tokenId);\n        l.tokenOwners.set(tokenId, to);\n        l.tokenApprovals[tokenId] = address(0);\n\n        emit Approval(owner, address(0), tokenId);\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\n        if (!_isApprovedOrOwner(msg.sender, tokenId))\n            revert ERC721Base__NotOwnerOrApproved();\n        _transfer(from, to, tokenId);\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        if (!_checkOnERC721Received(from, to, tokenId, data))\n            revert ERC721Base__ERC721ReceiverNotImplemented();\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        _safeTransferFrom(from, to, tokenId, '');\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\n        if (!_isApprovedOrOwner(msg.sender, tokenId))\n            revert ERC721Base__NotOwnerOrApproved();\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    function _approve(address operator, uint256 tokenId) internal virtual {\n        _handleApproveMessageValue(operator, tokenId, msg.value);\n\n        address owner = _ownerOf(tokenId);\n\n        if (operator == owner) revert ERC721Base__SelfApproval();\n        if (msg.sender != owner && !_isApprovedForAll(owner, msg.sender))\n            revert ERC721Base__NotOwnerOrApproved();\n\n        ERC721BaseStorage.layout().tokenApprovals[tokenId] = operator;\n        emit Approval(owner, operator, tokenId);\n    }\n\n    function _setApprovalForAll(\n        address operator,\n        bool status\n    ) internal virtual {\n        if (operator == msg.sender) revert ERC721Base__SelfApproval();\n        ERC721BaseStorage.layout().operatorApprovals[msg.sender][\n            operator\n        ] = status;\n        emit ApprovalForAll(msg.sender, operator, status);\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual returns (bool) {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes memory returnData = to.functionCall(\n            abi.encodeWithSelector(\n                IERC721Receiver(to).onERC721Received.selector,\n                msg.sender,\n                from,\n                tokenId,\n                data\n            ),\n            'ERC721: transfer to non ERC721Receiver implementer'\n        );\n\n        bytes4 returnValue = abi.decode(returnData, (bytes4));\n        return returnValue == type(IERC721Receiver).interfaceId;\n    }\n\n    /**\n     * @notice ERC721 hook, called before externally called approvals for processing of included message value\n     * @param operator beneficiary of approval\n     * @param tokenId id of transferred token\n     * @param value message value\n     */\n    function _handleApproveMessageValue(\n        address operator,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual {}\n\n    /**\n     * @notice ERC721 hook, called before externally called transfers for processing of included message value\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId id of transferred token\n     * @param value message value\n     */\n    function _handleTransferMessageValue(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual {}\n\n    /**\n     * @notice ERC721 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId id of transferred token\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/ERC721BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\n\nlibrary ERC721BaseStorage {\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC721Base');\n\n    struct Layout {\n        EnumerableMap.UintToAddressMap tokenOwners;\n        mapping(address => EnumerableSet.UintSet) holderTokens;\n        mapping(uint256 => address) tokenApprovals;\n        mapping(address => mapping(address => bool)) operatorApprovals;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/IERC721Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721 } from '../../../interfaces/IERC721.sol';\nimport { IERC721BaseInternal } from './IERC721BaseInternal.sol';\n\n/**\n * @title ERC721 base interface\n */\ninterface IERC721Base is IERC721BaseInternal, IERC721 {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/IERC721BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721Internal } from '../../../interfaces/IERC721Internal.sol';\n\n/**\n * @title ERC721 base interface\n */\ninterface IERC721BaseInternal is IERC721Internal {\n    error ERC721Base__NotOwnerOrApproved();\n    error ERC721Base__SelfApproval();\n    error ERC721Base__BalanceQueryZeroAddress();\n    error ERC721Base__ERC721ReceiverNotImplemented();\n    error ERC721Base__InvalidOwner();\n    error ERC721Base__MintToZeroAddress();\n    error ERC721Base__NonExistentToken();\n    error ERC721Base__NotTokenOwner();\n    error ERC721Base__TokenAlreadyMinted();\n    error ERC721Base__TransferToZeroAddress();\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\nimport { IERC721Enumerable } from './IERC721Enumerable.sol';\nimport { ERC721EnumerableInternal } from './ERC721EnumerableInternal.sol';\n\nabstract contract ERC721Enumerable is\n    IERC721Enumerable,\n    ERC721EnumerableInternal\n{\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply();\n    }\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) public view returns (uint256) {\n        return _tokenOfOwnerByIndex(owner, index);\n    }\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        return _tokenByIndex(index);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/ERC721EnumerableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\n\nabstract contract ERC721EnumerableInternal {\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @notice TODO\n     */\n    function _totalSupply() internal view returns (uint256) {\n        return ERC721BaseStorage.layout().tokenOwners.length();\n    }\n\n    /**\n     * @notice TODO\n     */\n    function _tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) internal view returns (uint256) {\n        return ERC721BaseStorage.layout().holderTokens[owner].at(index);\n    }\n\n    /**\n     * @notice TODO\n     */\n    function _tokenByIndex(\n        uint256 index\n    ) internal view returns (uint256 tokenId) {\n        (tokenId, ) = ERC721BaseStorage.layout().tokenOwners.at(index);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC721Enumerable {\n    /**\n     * @notice get total token supply\n     * @return total supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice get token of given owner at given internal storage index\n     * @param owner token holder to query\n     * @param index position in owner's token list to query\n     * @return tokenId id of retrieved token\n     */\n    function tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) external view returns (uint256 tokenId);\n\n    /**\n     * @notice get token at given internal storage index\n     * @param index position in global token list to query\n     * @return tokenId id of retrieved token\n     */\n    function tokenByIndex(\n        uint256 index\n    ) external view returns (uint256 tokenId);\n}\n"
    },
    "@solidstate/contracts/token/ERC721/ISolidStateERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721Base } from './base/IERC721Base.sol';\nimport { IERC721Enumerable } from './enumerable/IERC721Enumerable.sol';\nimport { IERC721Metadata } from './metadata/IERC721Metadata.sol';\n\ninterface ISolidStateERC721 is IERC721Base, IERC721Enumerable, IERC721Metadata {\n    error SolidStateERC721__PayableApproveNotSupported();\n    error SolidStateERC721__PayableTransferNotSupported();\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ERC721MetadataInternal } from './ERC721MetadataInternal.sol';\nimport { IERC721Metadata } from './IERC721Metadata.sol';\n\n/**\n * @title ERC721 metadata extensions\n */\nabstract contract ERC721Metadata is IERC721Metadata, ERC721MetadataInternal {\n    /**\n     * @notice inheritdoc IERC721Metadata\n     */\n    function name() external view virtual returns (string memory) {\n        return _name();\n    }\n\n    /**\n     * @notice inheritdoc IERC721Metadata\n     */\n    function symbol() external view virtual returns (string memory) {\n        return _symbol();\n    }\n\n    /**\n     * @notice inheritdoc IERC721Metadata\n     */\n    function tokenURI(\n        uint256 tokenId\n    ) external view virtual returns (string memory) {\n        return _tokenURI(tokenId);\n    }\n\n    /**\n     * @inheritdoc ERC721MetadataInternal\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from '../../../utils/UintUtils.sol';\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\nimport { ERC721BaseInternal } from '../base/ERC721Base.sol';\nimport { IERC721MetadataInternal } from './IERC721MetadataInternal.sol';\nimport { ERC721MetadataStorage } from './ERC721MetadataStorage.sol';\nimport { ERC721MetadataInternal } from './ERC721MetadataInternal.sol';\n\n/**\n * @title ERC721Metadata internal functions\n */\nabstract contract ERC721MetadataInternal is\n    IERC721MetadataInternal,\n    ERC721BaseInternal\n{\n    using UintUtils for uint256;\n\n    /**\n     * @notice get token name\n     * @return token name\n     */\n    function _name() internal view virtual returns (string memory) {\n        return ERC721MetadataStorage.layout().name;\n    }\n\n    /**\n     * @notice get token symbol\n     * @return token symbol\n     */\n    function _symbol() internal view virtual returns (string memory) {\n        return ERC721MetadataStorage.layout().symbol;\n    }\n\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function _tokenURI(\n        uint256 tokenId\n    ) internal view virtual returns (string memory) {\n        if (!_exists(tokenId)) revert ERC721Metadata__NonExistentToken();\n\n        ERC721MetadataStorage.Layout storage l = ERC721MetadataStorage.layout();\n\n        string memory tokenIdURI = l.tokenURIs[tokenId];\n        string memory baseURI = l.baseURI;\n\n        if (bytes(baseURI).length == 0) {\n            return tokenIdURI;\n        } else if (bytes(tokenIdURI).length > 0) {\n            return string(abi.encodePacked(baseURI, tokenIdURI));\n        } else {\n            return string(abi.encodePacked(baseURI, tokenId.toString()));\n        }\n    }\n\n    /**\n     * @notice ERC721 hook: clear per-token URI data on burn\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (to == address(0)) {\n            delete ERC721MetadataStorage.layout().tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC721MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC721Metadata');\n\n    struct Layout {\n        string name;\n        string symbol;\n        string baseURI;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721MetadataInternal } from './IERC721MetadataInternal.sol';\n\n/**\n * @title ERC721Metadata interface\n */\ninterface IERC721Metadata is IERC721MetadataInternal {\n    /**\n     * @notice get token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice get token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/IERC721MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721BaseInternal } from '../base/IERC721BaseInternal.sol';\n\n/**\n * @title ERC721Metadata internal interface\n */\ninterface IERC721MetadataInternal is IERC721BaseInternal {\n    error ERC721Metadata__NonExistentToken();\n}\n"
    },
    "@solidstate/contracts/token/ERC721/SolidStateERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ERC165Base } from '../../introspection/ERC165/base/ERC165Base.sol';\nimport { ERC721Base, ERC721BaseInternal } from './base/ERC721Base.sol';\nimport { ERC721Enumerable } from './enumerable/ERC721Enumerable.sol';\nimport { ERC721Metadata } from './metadata/ERC721Metadata.sol';\nimport { ISolidStateERC721 } from './ISolidStateERC721.sol';\n\n/**\n * @title SolidState ERC721 implementation, including recommended extensions\n */\nabstract contract SolidStateERC721 is\n    ISolidStateERC721,\n    ERC721Base,\n    ERC721Enumerable,\n    ERC721Metadata,\n    ERC165Base\n{\n    /**\n     * @notice ERC721 hook: revert if value is included in external approve function call\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _handleApproveMessageValue(\n        address operator,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual override {\n        if (value > 0) revert SolidStateERC721__PayableApproveNotSupported();\n        super._handleApproveMessageValue(operator, tokenId, value);\n    }\n\n    /**\n     * @notice ERC721 hook: revert if value is included in external transfer function call\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _handleTransferMessageValue(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual override {\n        if (value > 0) revert SolidStateERC721__PayableTransferNotSupported();\n        super._handleTransferMessageValue(from, to, tokenId, value);\n    }\n\n    /**\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721BaseInternal, ERC721Metadata) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/ArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ArrayUtils {\n    /**\n     * @notice get minimum value in given array\n     * @param array array to search\n     * @return minimum value\n     */\n    function min(bytes32[] memory array) internal pure returns (bytes32) {\n        bytes32 minValue = bytes32(type(uint256).max);\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] < minValue) {\n                    minValue = array[i];\n                }\n            }\n        }\n\n        return minValue;\n    }\n\n    /**\n     * @notice get minimum value in given array\n     * @param array array to search\n     * @return minimum value\n     */\n    function min(address[] memory array) internal pure returns (address) {\n        address minValue = address(type(uint160).max);\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] < minValue) {\n                    minValue = array[i];\n                }\n            }\n        }\n\n        return minValue;\n    }\n\n    /**\n     * @notice get minimum value in given array\n     * @param array array to search\n     * @return minimum value\n     */\n    function min(uint256[] memory array) internal pure returns (uint256) {\n        uint256 minValue = type(uint256).max;\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] < minValue) {\n                    minValue = array[i];\n                }\n            }\n        }\n\n        return minValue;\n    }\n\n    /**\n     * @notice get maximum value in given array\n     * @param array array to search\n     * @return maximum value\n     */\n    function max(bytes32[] memory array) internal pure returns (bytes32) {\n        bytes32 maxValue = bytes32(0);\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] > maxValue) {\n                    maxValue = array[i];\n                }\n            }\n        }\n\n        return maxValue;\n    }\n\n    /**\n     * @notice get maximum value in given array\n     * @param array array to search\n     * @return maximum value\n     */\n    function max(address[] memory array) internal pure returns (address) {\n        address maxValue = address(0);\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] > maxValue) {\n                    maxValue = array[i];\n                }\n            }\n        }\n\n        return maxValue;\n    }\n\n    /**\n     * @notice get maximum value in given array\n     * @param array array to search\n     * @return maximum value\n     */\n    function max(uint256[] memory array) internal pure returns (uint256) {\n        uint256 maxValue = 0;\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] > maxValue) {\n                    maxValue = array[i];\n                }\n            }\n        }\n\n        return maxValue;\n    }\n}\n"
    },
    "@solidstate/contracts/utils/IMulticall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Interface for the Multicall utility contract\n */\ninterface IMulticall {\n    /**\n     * @notice batch function calls to the contract and return the results of each\n     * @param data array of function call data payloads\n     * @return results array of function call results\n     */\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n}\n"
    },
    "@solidstate/contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IMulticall } from './IMulticall.sol';\n\n/**\n * @title Utility contract for supporting processing of multiple function calls in a single transaction\n */\nabstract contract Multicall is IMulticall {\n    /**\n     * @inheritdoc IMulticall\n     */\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n\n        unchecked {\n            for (uint256 i; i < data.length; i++) {\n                (bool success, bytes memory returndata) = address(this)\n                    .delegatecall(data[i]);\n\n                if (success) {\n                    results[i] = returndata;\n                } else {\n                    assembly {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        }\n\n        return results;\n    }\n}\n"
    },
    "@solidstate/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ReentrancyGuardStorage } from './ReentrancyGuardStorage.sol';\n\n/**\n * @title Utility contract for preventing reentrancy attacks\n */\nabstract contract ReentrancyGuard {\n    error ReentrancyGuard__ReentrantCall();\n\n    modifier nonReentrant() {\n        ReentrancyGuardStorage.Layout storage l = ReentrancyGuardStorage\n            .layout();\n        if (l.status == 2) revert ReentrancyGuard__ReentrantCall();\n        l.status = 2;\n        _;\n        l.status = 1;\n    }\n}\n"
    },
    "@solidstate/contracts/utils/ReentrancyGuardStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ReentrancyGuardStorage {\n    struct Layout {\n        uint256 status;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ReentrancyGuard');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/arcadiaDiamonds/arcadians/ArcadiansFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { ERC721BaseInternal } from \"@solidstate/contracts/token/ERC721/base/ERC721BaseInternal.sol\";\nimport { ERC721Metadata } from \"@solidstate/contracts/token/ERC721/metadata/ERC721Metadata.sol\";\nimport { ISolidStateERC721 } from \"@solidstate/contracts/token/ERC721/ISolidStateERC721.sol\";\nimport { SolidStateERC721 } from \"@solidstate/contracts/token/ERC721/SolidStateERC721.sol\";\nimport { ERC721Base } from \"@solidstate/contracts/token/ERC721/base/ERC721Base.sol\";\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\nimport { IERC721Metadata } from \"@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol\";\nimport { ArcadiansInternal } from \"./ArcadiansInternal.sol\";\nimport { ArcadiansStorage } from \"./ArcadiansStorage.sol\";\nimport { EnumerableMap } from '@solidstate/contracts/data/EnumerableMap.sol';\nimport { Multicall } from \"@solidstate/contracts/utils/Multicall.sol\";\nimport { InventoryStorage } from \"../inventory/InventoryStorage.sol\";\nimport { WhitelistStorage } from \"../whitelist/WhitelistStorage.sol\";\n\n/**\n * @title ArcadiansFacet\n * @notice This contract is an ERC721 responsible for minting and claiming Arcadian tokens.\n * @dev ReentrancyGuard and Multicall contracts are used for security and gas efficiency.\n */\ncontract ArcadiansFacet is SolidStateERC721, ArcadiansInternal, Multicall {\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    WhitelistStorage.PoolId constant GuaranteedPool = WhitelistStorage.PoolId.Guaranteed;\n    WhitelistStorage.PoolId constant RestrictedPool = WhitelistStorage.PoolId.Restricted;\n\n    /**\n     * @notice Returns the URI for a given arcadian\n     * @param tokenId ID of the token to query\n     * @return The URI for the given token ID\n     */\n    function tokenURI(\n        uint tokenId\n    ) external view override (ERC721Metadata, IERC721Metadata) returns (string memory) {\n        return _tokenURI(tokenId);\n    }\n\n    function _mint() internal returns (uint tokenId) {\n        tokenId = nextArcadianId();\n\n        ArcadiansStorage.Layout storage arcadiansSL = ArcadiansStorage.layout();\n        if (_isWhitelistClaimActive(GuaranteedPool) && _elegibleWhitelist(GuaranteedPool, msg.sender) > 0) {\n            // OG mint flow\n            _consumeWhitelist(GuaranteedPool, msg.sender, 1);\n        } else if (_isWhitelistClaimActive(RestrictedPool) && _elegibleWhitelist(RestrictedPool, msg.sender) > 0) { \n            // Whitelist mint flow\n            _consumeWhitelist(RestrictedPool, msg.sender, 1);\n            if (tokenId > MAX_SUPPLY)\n                revert Arcadians_MaximumArcadiansSupplyReached();\n\n            uint nonGuaranteedMintedAmount = _balanceOf(msg.sender) - _claimedWhitelist(GuaranteedPool, msg.sender);\n            if (nonGuaranteedMintedAmount >= arcadiansSL.maxMintPerUser) \n                revert Arcadians_MaximumMintedArcadiansPerUserReached();\n\n        } else if (arcadiansSL.isPublicMintOpen) {\n            if (msg.value != arcadiansSL.mintPrice)\n                revert Arcadians_InvalidPayAmount();\n\n            if (tokenId > MAX_SUPPLY)\n                revert Arcadians_MaximumArcadiansSupplyReached();\n\n            uint nonGuaranteedMintedAmount = _balanceOf(msg.sender) - _claimedWhitelist(GuaranteedPool, msg.sender);\n            if (nonGuaranteedMintedAmount >= arcadiansSL.maxMintPerUser) \n                revert Arcadians_MaximumMintedArcadiansPerUserReached();\n        } else {\n            revert Arcadians_NotElegibleToMint();\n        }\n\n        _safeMint(msg.sender, tokenId);\n    }\n\n    /**\n     * @notice Returns the amount of arcadians that can be minted by an account\n     * @param account account to query\n     * @return balance amount of arcadians that can be minted\n     */\n    function availableMints(address account) external view returns (uint balance) {\n        return  ArcadiansStorage.layout().maxMintPerUser - (_balanceOf(account) - _claimedWhitelist(GuaranteedPool, account)) + _elegibleWhitelist(GuaranteedPool, account);\n    }\n\n    /**\n     * @notice Returns the total amount of arcadians minted\n     * @return uint total amount of arcadians minted\n     */\n    function totalMinted() external view returns (uint) {\n        return _totalSupply();\n    }\n\n   /**\n     * @notice Mint a token and equip it with the given items\n     * @param itemsToEquip array of items to equip in the correspondent slot\n     */\n    function mintAndEquip(\n        InventoryStorage.Item[] calldata itemsToEquip\n    )\n        external payable nonReentrant\n    {\n        uint tokenId = _mint();\n        _equip(tokenId, itemsToEquip, true);\n    }\n\n    /**\n     * @notice This function sets the public mint as open/closed\n     */\n    function setPublicMintOpen(bool isOpen) external onlyManager {\n        ArcadiansStorage.Layout storage arcadiansSL = ArcadiansStorage.layout();\n        arcadiansSL.isPublicMintOpen = isOpen;\n    }\n    /**\n     * @notice Returns true if the public mint is open, false otherwise\n     */\n    function publicMintOpen() external view returns (bool) {\n        return ArcadiansStorage.layout().isPublicMintOpen;\n    }\n\n    /**\n     * @notice This function updates the price to mint an arcadian\n     * @param newMintPrice The new mint price to be set\n     */\n    function setMintPrice(uint newMintPrice) external onlyManager {\n        _setMintPrice(newMintPrice);\n    }\n\n    /**\n     * @notice This function gets the current price to mint an arcadian\n     * @return The current mint price\n     */\n    function mintPrice() external view returns (uint) {\n        return _mintPrice();\n    }\n\n    /**\n     * @notice This function sets the new maximum number of arcadians that a user can mint\n     * @param newMaxMintPerUser The new maximum number of arcadians that a user can mint\n     */\n    function setMaxMintPerUser(uint newMaxMintPerUser) external onlyManager {\n        _setMaxMintPerUser(newMaxMintPerUser);\n    }\n\n    /**\n     * @dev This function gets the current maximum number of arcadians that a user can mint\n     * @return The current maximum number of arcadians that a user can mint\n     */\n    function maxMintPerUser() external view returns (uint) {\n        return _maxMintPerUser();\n    }\n\n    /**\n     * @dev This function returns the maximum supply of arcadians\n     * @return The current maximum supply of arcadians\n     */\n    function maxSupply() external pure returns (uint) {\n        return MAX_SUPPLY;\n    }\n\n    /**\n     * @notice Set the base URI for all Arcadians metadata\n     * @notice Only the manager role can call this function\n     * @param newBaseURI The new base URI for all token metadata\n     */\n    function setBaseURI(string memory newBaseURI) external onlyManager {\n        _setBaseURI(newBaseURI);\n    }\n\n    /**\n     * @dev This function returns the base URI\n     * @return The base URI\n     */\n    function baseURI() external view returns (string memory) {\n        return _baseURI();\n    }\n\n    function nextArcadianId() internal view returns (uint arcadianId) {\n        arcadianId = _totalSupply() + 1;\n    }\n}"
    },
    "contracts/arcadiaDiamonds/arcadians/ArcadiansInit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { ArcadiansInternal } from \"./ArcadiansInternal.sol\";\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\nimport { ERC165BaseInternal } from '@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol';\n\ncontract ArcadiansInit is RolesInternal, ArcadiansInternal, ERC165BaseInternal {\n    function init(string calldata baseUri, uint maxMintPerUser, uint mintPrice) external {\n\n        _setSupportsInterface(type(IERC721).interfaceId, true);\n\n        // Roles facet\n        _initRoles();\n\n        // Arcadians facet\n        _setBaseURI(baseUri);\n        _setMaxMintPerUser(maxMintPerUser);\n        _setMintPrice(mintPrice);\n    }\n}\n"
    },
    "contracts/arcadiaDiamonds/arcadians/ArcadiansInternal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { ERC721MetadataStorage } from \"@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol\";\nimport { UintUtils } from '@solidstate/contracts/utils/UintUtils.sol';\nimport { ArcadiansStorage } from \"./ArcadiansStorage.sol\";\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { WhitelistInternal } from \"../whitelist/WhitelistInternal.sol\";\nimport { InventoryInternal } from \"../inventory/InventoryInternal.sol\";\n\ncontract ArcadiansInternal is RolesInternal, WhitelistInternal, InventoryInternal {\n\n    error Arcadians_InvalidPayAmount();\n    error Arcadians_MaximumMintedArcadiansPerUserReached();\n    error Arcadians_MaximumArcadiansSupplyReached();\n    error Arcadians_NotElegibleToMint();\n\n    event MaxMintPerUserChanged(address indexed by, uint oldMaxMintPerUser, uint newMaxMintPerUser);\n    event MintPriceChanged(address indexed by, uint oldMintPrice, uint newMintPrice);\n    event BaseURIChanged(address indexed by, string oldBaseURI, string newBaseURI);\n\n    using UintUtils for uint;\n\n    uint constant MAX_SUPPLY = 6666;\n\n    function _setBaseURI(string memory newBaseURI) internal {\n        ERC721MetadataStorage.Layout storage ERC721SL = ERC721MetadataStorage.layout();\n        emit BaseURIChanged(msg.sender, ERC721SL.baseURI, newBaseURI);\n        ERC721SL.baseURI = newBaseURI;\n    }\n\n    function _baseURI() internal view returns (string memory) {\n        return ERC721MetadataStorage.layout().baseURI;\n    }\n\n    function _mintPrice() internal view returns (uint) {\n        return ArcadiansStorage.layout().mintPrice;\n    }\n\n    function _setMintPrice(uint newMintPrice) internal {\n        ArcadiansStorage.Layout storage arcadiansSL = ArcadiansStorage.layout();\n        emit MintPriceChanged(msg.sender, arcadiansSL.mintPrice, newMintPrice);\n        arcadiansSL.mintPrice = newMintPrice;\n    }\n\n    function _setMaxMintPerUser(uint newMaxMintPerUser) internal {\n        ArcadiansStorage.Layout storage arcadiansSL = ArcadiansStorage.layout();\n        emit MaxMintPerUserChanged(msg.sender, arcadiansSL.maxMintPerUser, newMaxMintPerUser);\n        arcadiansSL.maxMintPerUser = newMaxMintPerUser;\n    }\n\n    function _maxMintPerUser() internal view returns (uint) {\n        return ArcadiansStorage.layout().maxMintPerUser;\n    }\n}"
    },
    "contracts/arcadiaDiamonds/arcadians/ArcadiansStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nlibrary ArcadiansStorage {\n\n    bytes32 constant ARCADIANS_STORAGE_POSITION =\n        keccak256(\"equippable.storage.position\");\n\n    struct Layout {\n        uint maxMintPerUser;\n        uint mintPrice;\n        bool isPublicMintOpen;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = ARCADIANS_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/inventory/InventoryFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\n\n/**\n * Crated based in the following work:\n * Authors: Moonstream DAO (engineering@moonstream.to)\n * GitHub: https://github.com/G7DAO/contracts\n */\n\npragma solidity 0.8.19;\n\nimport { ReentrancyGuard } from \"@solidstate/contracts/utils/ReentrancyGuard.sol\";\nimport { ERC1155Holder } from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport { InventoryStorage } from \"./InventoryStorage.sol\";\nimport { InventoryInternal } from \"./InventoryInternal.sol\";\n\n/**\n * @title InventoryFacet\n * @dev This contract is responsible for managing the inventory system for the Arcadians using slots. \n * It defines the functionality to equip and unequip items to Arcadians, check if a combination of items \n * are unique, and retrieve the inventory slots and allowed items for a slot. \n * This contract also implements ERC1155Holder to handle ERC1155 token transfers\n * This contract can be used as a facet of a diamond which follows the EIP-2535 diamond standard.\n * It also uses the ReentrancyGuard and Multicall contracts for security and gas efficiency.\n */\ncontract InventoryFacet is\n    ERC1155Holder,\n    ReentrancyGuard,\n    InventoryInternal\n{\n\n    /**\n     * @notice Returns the number of inventory slots\n     * @dev Slots are 1-indexed\n     * @return The number of inventory slots \n     */\n    function numSlots() external view returns (uint) {\n        return _numSlots();\n    }\n\n    function arcadianToBaseItemHash(uint arcadianId) external view returns (bytes32) {\n        return InventoryStorage.layout().arcadianToBaseItemHash[arcadianId];\n    }\n\n    /**\n     * @notice Returns the details of an inventory slot given its ID\n     * @dev Slots are 1-indexed\n     * @param slotId The ID of the inventory slot\n     * @return existentSlot The details of the inventory slot\n     */\n    function slot(uint8 slotId) external view returns (InventoryStorage.Slot memory existentSlot) {\n        return _slot(slotId);\n    }\n\n    /**\n     * @notice Returns the details of all the existent slots\n     * @dev Slots are 1-indexed\n     * @return existentSlots The details of all the inventory slots\n     */\n    function slotsAll() external view returns (InventoryStorage.Slot[] memory existentSlots) {\n        return _slotsAll();\n    }\n\n    /**\n     * @notice Creates a new inventory slot\n     * @dev This function is only accessible to the manager role\n     * @dev Slots are 1-indexed\n     * @param permanent Whether or not the slot can be unequipped once equipped\n     * @param isBase If the slot is base\n     * @param items The list of items to allow in the slot\n     */\n    function createSlot(\n        bool permanent,\n        bool isBase,\n        InventoryStorage.Item[] calldata items\n    ) external onlyManager {\n        _createSlot(permanent, isBase, items);\n    }\n\n    /**\n     * @notice Sets the slot permanent property\n     * @dev This function is only accessible to the manager role\n     * @dev Slots are 1-indexed\n     * @param permanent Whether or not the slot is permanent\n     */\n    function setSlotPermanent(\n        uint8 slotId,\n        bool permanent\n    ) external onlyManager {\n        _setSlotPermanent(slotId, permanent);\n    }\n\n    /**\n     * @notice Sets the slot base property\n     * @dev This function is only accessible to the manager role\n     * @dev Slots are 1-indexed\n     * @param isBase Whether or not the slot is base\n     */\n    function setSlotBase(\n        uint8 slotId,\n        bool isBase\n    ) external onlyManager {\n        _setSlotBase(slotId, isBase);\n    }\n\n    /**\n     * @notice Returns the number coupons available for an account that allow to modify the base traits\n     * @param account The accounts to increase the number of coupons\n     * @param slotId The slot to get the coupon amount from\n     */\n    function getBaseModifierCoupon(\n        address account,\n        uint8 slotId\n    ) external view returns (uint) {\n        return _getbaseModifierCoupon(account, slotId);\n    }\n\n    /**\n     * @notice Returns the number coupons available for an account that allow to modify the base traits\n     * @param account The accounts to increase the number of coupons\n     */\n    function getBaseModifierCouponAll(\n        address account\n    ) external view returns (BaseModifierCoupon[] memory) {\n        return _getBaseModifierCouponAll(account);\n    }\n\n    /**\n     * @notice Returns all the slots ids\n     */\n    function getBaseSlotsIds() external view returns (uint[] memory) {\n        return _getBaseSlotsIds();\n    }\n\n    /**\n     * @notice Adds coupons to accounts that allow to modify the base traits\n     * @param account The account to increase the number of coupons\n     * @param slotsIds The slots ids to increase the number of coupons\n     * @param amounts the amounts of coupons to increase\n     */\n    function addBaseModifierCoupons(\n        address account,\n        uint8[] calldata slotsIds,\n        uint[] calldata amounts\n    ) external onlyAutomation {\n        _addBaseModifierCoupons(account, slotsIds, amounts);\n    }\n\n    /**\n     * @notice Sets the items transfer required on equip\n     * @param items The list of items\n     * @param requiresTransfer If it requires item transfer to be equipped\n     */\n    function setItemsTransferRequired(\n        InventoryStorage.Item[] calldata items,\n        bool[] calldata requiresTransfer\n    ) external onlyManager {\n        _setItemsTransferRequired(items, requiresTransfer);\n    }\n\n    /**\n     * @notice Adds items to the list of allowed items for an inventory slot\n     * @param slotId The slot id\n     * @param items The list of items to allow in the slot\n     */\n    function allowItemsInSlot(\n        uint8 slotId,\n        InventoryStorage.Item[] calldata items\n    ) external onlyManager {\n        _allowItemsInSlot(slotId, items);\n    }\n    \n    /**\n     * @notice Removes items from the list of allowed items\n     * @param items The list of items to disallow in the slot\n     */\n    function disallowItems(\n        InventoryStorage.Item[] calldata items\n    ) external onlyManager {\n        _disallowItems(items);\n    }\n\n    /**\n     * @notice Returns the allowed slot for a given item\n     * @param item The item to check\n     * @return The allowed slot id for the item. Slots are 1-indexed.\n     */\n    function allowedSlot(InventoryStorage.Item calldata item) external view returns (uint) {\n        return _allowedSlot(item);\n    }\n\n    /**\n     * @notice Equips multiple items to multiple slots for a specified Arcadian NFT\n     * @param arcadianId The ID of the Arcadian NFT to equip the items for\n     * @param items An array of items to equip in the corresponding slots\n     */\n    function equip(\n        uint arcadianId,\n        InventoryStorage.Item[] calldata items\n    ) external nonReentrant {\n        _equip(arcadianId, items, false);\n    }\n\n    /**\n     * @notice Unequips the items equipped in multiple slots for a specified Arcadian NFT\n     * @param arcadianId The ID of the Arcadian NFT to equip the item for\n     * @param slotsIds The slots ids in which the items will be unequipped\n     */\n    function unequip(\n        uint arcadianId,\n        uint8[] calldata slotsIds\n    ) external nonReentrant {\n        _unequip(arcadianId, slotsIds);\n    }\n\n    /**\n     * @notice Retrieves the equipped item in a slot for a specified Arcadian NFT\n     * @param arcadianId The ID of the Arcadian NFT to query\n     * @param slotId The slot id to query\n     */\n    function equipped(\n        uint arcadianId,\n        uint8 slotId\n    ) external view returns (ItemInSlot memory item) {\n        return _equipped(arcadianId, slotId);\n    }\n\n    /**\n     * @notice Retrieves the equipped items in the slot of an Arcadian NFT\n     * @param arcadianId The ID of the Arcadian NFT to query\n     * @param slotsIds The slots ids to query\n     */\n    function equippedBatch(\n        uint arcadianId,\n        uint8[] calldata slotsIds\n    ) external view returns (ItemInSlot[] memory equippedSlot) {\n        return _equippedBatch(arcadianId, slotsIds);\n    }\n\n    /**\n     * @notice Retrieves all the equipped items for a specified Arcadian NFT\n     * @param arcadianId The ID of the Arcadian NFT to query\n     */\n    function equippedAll(\n        uint arcadianId\n    ) external view returns (ItemInSlot[] memory equippedSlot) {\n        return _equippedAll(arcadianId);\n    }\n\n    /**\n     * @notice Indicates if a list of items applied to an the arcadian is unique\n     * @dev The uniqueness is calculated using the existent arcadian items and the input items as well\n     * @dev Only items equipped in 'base' slots are considered for uniqueness\n     * @param arcadianId The ID of the Arcadian NFT to query\n     * @param items An array of items to check for uniqueness after \"equipped\" over the existent arcadian items.\n     */\n    function isArcadianUnique(\n        uint arcadianId,\n        InventoryStorage.Item[] calldata items\n    ) external view returns (bool) {\n        return _isArcadianUnique(arcadianId, items);\n    }\n}"
    },
    "contracts/arcadiaDiamonds/inventory/InventoryInternal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { ReentrancyGuard } from \"@solidstate/contracts/utils/ReentrancyGuard.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { AddressUtils } from \"@solidstate/contracts/utils/AddressUtils.sol\";\nimport { ArrayUtils } from \"@solidstate/contracts/utils/ArrayUtils.sol\";\nimport { EnumerableSet } from \"@solidstate/contracts/data/EnumerableSet.sol\";\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { InventoryStorage } from \"./InventoryStorage.sol\";\nimport { IERC1155 } from \"@solidstate/contracts/interfaces/IERC1155.sol\";\n\ncontract InventoryInternal is\n    ReentrancyGuard,\n    RolesInternal\n{\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using AddressUtils for address;\n\n    error Inventory_InvalidERC1155Contract();\n    error Inventory_UnequippingPermanentSlot();\n    error Inventory_InvalidSlotId();\n    error Inventory_ItemDoesNotHaveSlotAssigned();\n    error Inventory_InsufficientItemBalance();\n    error Inventory_UnequippingEmptySlot();\n    error Inventory_UnequippingBaseSlot();\n    error Inventory_SlotNotSpecified();\n    error Inventory_ItemNotSpecified();\n    error Inventory_NotArcadianOwner();\n    error Inventory_ArcadianNotUnique();\n    error Inventory_NotAllBaseSlotsEquipped();\n    error Inventory_InputDataMismatch();\n    error Inventory_ItemAlreadyEquippedInSlot();\n    error Inventory_CouponNeededToModifyBaseSlots();\n    error Inventory_NonBaseSlot();\n\n    event ItemsAllowedInSlotUpdated(\n        address indexed by,\n        InventoryStorage.Item[] items\n    );\n\n    event ItemsEquipped(\n        address indexed by,\n        uint indexed arcadianId,\n        uint[] slots\n    );\n\n    event ItemsUnequipped(\n        address indexed by,\n        uint indexed arcadianId,\n        uint8[] slotsIds\n    );\n\n    event SlotCreated(\n        address indexed by,\n        uint8 indexed slotId,\n        bool permanent,\n        bool isBase\n    );\n\n    event BaseModifierCouponAdded(\n        address indexed by,\n        address indexed to,\n        uint8[] slotsIds,\n        uint[] amounts\n    );\n\n    event BaseModifierCouponConsumed(\n        address indexed account,\n        uint8[] slotsIds\n    );\n\n    // Helper structs only used in view functions to ease data reading from web3\n    struct ItemInSlot {\n        uint8 slotId;\n        address erc1155Contract;\n        uint itemId;\n    }\n    struct BaseModifierCoupon {\n        uint8 slotId;\n        uint amount;\n    }\n\n    modifier onlyValidSlot(uint8 slotId) {\n        if (slotId == 0 || slotId > InventoryStorage.layout().numSlots) revert Inventory_InvalidSlotId();\n        _;\n    }\n\n    modifier onlyArcadianOwner(uint arcadianId) {\n        IERC721 arcadiansContract = IERC721(address(this));\n        if (msg.sender != arcadiansContract.ownerOf(arcadianId)) revert Inventory_NotArcadianOwner();\n        _;\n    }\n\n    function _numSlots() internal view returns (uint) {\n        return InventoryStorage.layout().numSlots;\n    }\n\n    function _equip(\n        uint arcadianId,\n        InventoryStorage.Item[] calldata items,\n        bool freeBaseModifier\n    ) internal onlyArcadianOwner(arcadianId) {\n\n        if (items.length == 0) \n            revert Inventory_ItemNotSpecified();\n\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        uint8 numBaseSlotsModified;\n        uint[] memory slotsIds = new uint[](items.length);\n        for (uint i = 0; i < items.length; i++) {\n            uint8 slotId = _equipSingleSlot(arcadianId, items[i], freeBaseModifier);\n            if (inventorySL.slots[slotId].isBase) {\n                numBaseSlotsModified++;\n            }\n            slotsIds[i] = slotId;\n        }\n\n        if (!_baseAndPermanentSlotsEquipped(arcadianId)) \n            revert Inventory_NotAllBaseSlotsEquipped();\n\n        if (numBaseSlotsModified > 0) {\n            if (!_hashBaseItemsUnchecked(arcadianId))\n                revert Inventory_ArcadianNotUnique();\n            \n            if (!freeBaseModifier) {\n                uint8[] memory baseSlotsModified = new uint8[](numBaseSlotsModified);\n                uint counter;\n                for (uint i = 0; i < items.length; i++) {\n                    uint8 slotId = inventorySL.itemSlot[items[i].erc1155Contract][items[i].id];\n                    if (inventorySL.slots[slotId].isBase) {\n                        baseSlotsModified[counter] = slotId;\n                        counter++;\n                    }\n                }\n                emit BaseModifierCouponConsumed(msg.sender, baseSlotsModified);\n            }\n        }\n\n        emit ItemsEquipped(msg.sender, arcadianId, slotsIds);\n    }\n\n    function _equipSingleSlot(\n        uint arcadianId,\n        InventoryStorage.Item calldata item,\n        bool freeBaseModifier\n    ) internal returns (uint8 slotId) {\n\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        slotId = inventorySL.itemSlot[item.erc1155Contract][item.id];\n        \n        if (slotId == 0 || slotId > InventoryStorage.layout().numSlots) \n            revert Inventory_ItemDoesNotHaveSlotAssigned();\n        \n        if (!freeBaseModifier && inventorySL.slots[slotId].isBase) {\n            if (inventorySL.baseModifierCoupon[msg.sender][slotId] == 0)\n                revert Inventory_CouponNeededToModifyBaseSlots();\n\n            inventorySL.baseModifierCoupon[msg.sender][slotId]--;\n        }\n\n        InventoryStorage.Item storage existingItem = inventorySL.equippedItems[arcadianId][slotId];\n        if (inventorySL.slots[slotId].permanent && existingItem.erc1155Contract != address(0)) \n            revert Inventory_UnequippingPermanentSlot();\n        if (existingItem.erc1155Contract == item.erc1155Contract && existingItem.id == item.id)\n            revert Inventory_ItemAlreadyEquippedInSlot();\n\n        if (inventorySL.equippedItems[arcadianId][slotId].erc1155Contract != address(0))\n            _unequipUnchecked(arcadianId, slotId);\n\n        bool requiresTransfer = inventorySL.requiresTransfer[item.erc1155Contract][item.id];\n        if (requiresTransfer) {\n            IERC1155 erc1155Contract = IERC1155(item.erc1155Contract);\n            if (erc1155Contract.balanceOf(msg.sender, item.id) < 1)\n                revert Inventory_InsufficientItemBalance();\n\n            erc1155Contract.safeTransferFrom(\n                msg.sender,\n                address(this),\n                item.id,\n                1,\n                ''\n            );\n        }\n\n        inventorySL.equippedItems[arcadianId][slotId] = item;\n    }\n\n    function _baseAndPermanentSlotsEquipped(uint arcadianId) internal view returns (bool) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        uint8 numSlots = inventorySL.numSlots;\n        for (uint8 i = 0; i < numSlots; i++) {\n            uint8 slotId = i + 1;\n            InventoryStorage.Slot storage slot = inventorySL.slots[slotId];\n            if (!slot.isBase && !slot.permanent)\n                continue;\n            if (inventorySL.equippedItems[arcadianId][slotId].erc1155Contract == address(0)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _unequipUnchecked(\n        uint arcadianId,\n        uint8 slotId\n    ) internal {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        InventoryStorage.Item storage existingItem = inventorySL.equippedItems[arcadianId][slotId];\n\n        bool requiresTransfer = inventorySL.requiresTransfer[existingItem.erc1155Contract][existingItem.id];\n        if (requiresTransfer) {\n            IERC1155 erc1155Contract = IERC1155(existingItem.erc1155Contract);\n            erc1155Contract.safeTransferFrom(\n                address(this),\n                msg.sender,\n                existingItem.id,\n                1,\n                ''\n            );\n        }\n        delete inventorySL.equippedItems[arcadianId][slotId];\n    }\n\n    function _unequip(\n        uint arcadianId,\n        uint8[] calldata slotsIds\n    ) internal onlyArcadianOwner(arcadianId) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        if (slotsIds.length == 0) \n            revert Inventory_SlotNotSpecified();\n\n        for (uint i = 0; i < slotsIds.length; i++) {\n            if (inventorySL.slots[slotsIds[i]].permanent) \n                revert Inventory_UnequippingPermanentSlot();\n\n            if (inventorySL.equippedItems[arcadianId][slotsIds[i]].erc1155Contract == address(0)) \n                revert Inventory_UnequippingEmptySlot();\n            \n            if (inventorySL.slots[slotsIds[i]].isBase)\n                revert Inventory_UnequippingBaseSlot();\n\n            _unequipUnchecked(arcadianId, slotsIds[i]);\n        }\n\n        _hashBaseItemsUnchecked(arcadianId);\n\n        emit ItemsUnequipped(\n            msg.sender,\n            arcadianId,\n            slotsIds\n        );\n    }\n\n    function _equipped(\n        uint arcadianId,\n        uint8 slotId\n    ) internal view returns (ItemInSlot memory) {\n        InventoryStorage.Item storage item = InventoryStorage.layout().equippedItems[arcadianId][slotId];\n        return ItemInSlot(slotId, item.erc1155Contract, item.id);\n    }\n\n    function _equippedBatch(\n        uint arcadianId,\n        uint8[] calldata slotsIds\n    ) internal view returns (ItemInSlot[] memory equippedSlots) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        equippedSlots = new ItemInSlot[](slotsIds.length);\n        for (uint i = 0; i < slotsIds.length; i++) {\n            InventoryStorage.Item storage equippedItem = inventorySL.equippedItems[arcadianId][slotsIds[i]];\n            equippedSlots[i] = ItemInSlot(slotsIds[i], equippedItem.erc1155Contract, equippedItem.id);\n        }\n    }\n\n    function _equippedAll(\n        uint arcadianId\n    ) internal view returns (ItemInSlot[] memory equippedSlots) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        uint8 numSlots = inventorySL.numSlots;\n        equippedSlots = new ItemInSlot[](numSlots);\n        for (uint8 i = 0; i < numSlots; i++) {\n            uint8 slotId = i + 1;\n            InventoryStorage.Item storage equippedItem = inventorySL.equippedItems[arcadianId][slotId];\n            equippedSlots[i] = ItemInSlot(slotId, equippedItem.erc1155Contract, equippedItem.id);\n        }\n    }\n\n    function _isArcadianUnique(\n        uint arcadianId,\n        InventoryStorage.Item[] calldata items\n    ) internal view returns (bool) {\n\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        bytes memory encodedItems;\n        uint numBaseSlots = inventorySL.baseSlotsIds.length();\n\n        for (uint8 i = 0; i < numBaseSlots; i++) {\n            uint8 slotId = uint8(inventorySL.baseSlotsIds.at(i));\n\n            InventoryStorage.Item memory item;\n            for (uint j = 0; j < items.length; j++) {\n                if (_allowedSlot(items[j]) == slotId) {\n                    item = items[j];\n                    break;\n                }\n            }\n            if (item.erc1155Contract == address(0)) {\n                if (inventorySL.equippedItems[arcadianId][slotId].erc1155Contract != address(0)) {\n                    item = inventorySL.equippedItems[arcadianId][slotId];\n                } else {\n                    revert Inventory_NotAllBaseSlotsEquipped();\n                }\n            }\n            \n            encodedItems = abi.encodePacked(encodedItems, slotId, item.erc1155Contract, item.id);\n        }\n\n        return !inventorySL.baseItemsHashes.contains(keccak256(encodedItems));\n    }\n\n    function _hashBaseItemsUnchecked(\n        uint arcadianId\n    ) internal returns (bool isUnique) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        bytes memory encodedItems;\n        uint numBaseSlots = inventorySL.baseSlotsIds.length();\n\n        for (uint8 i = 0; i < numBaseSlots; i++) {\n            uint8 slotId = uint8(inventorySL.baseSlotsIds.at(i));\n            \n            InventoryStorage.Item storage equippedItem = inventorySL.equippedItems[arcadianId][slotId];\n            encodedItems = abi.encodePacked(encodedItems, slotId, equippedItem.erc1155Contract, equippedItem.id);\n        }\n\n        bytes32 baseItemsHash = keccak256(encodedItems);\n        isUnique = !inventorySL.baseItemsHashes.contains(baseItemsHash);\n        inventorySL.baseItemsHashes.remove(inventorySL.arcadianToBaseItemHash[arcadianId]);\n        inventorySL.baseItemsHashes.add(baseItemsHash);\n        inventorySL.arcadianToBaseItemHash[arcadianId] = baseItemsHash;\n    }\n\n    function _createSlot(\n        bool permanent,\n        bool isBase,\n        InventoryStorage.Item[] calldata allowedItems\n    ) internal {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        // slots are 1-index\n        inventorySL.numSlots += 1;\n        uint8 newSlotId = inventorySL.numSlots;\n        inventorySL.slots[newSlotId].permanent = permanent;\n        inventorySL.slots[newSlotId].isBase = isBase;\n        inventorySL.slots[newSlotId].id = newSlotId;\n\n        _setSlotBase(newSlotId, isBase);\n\n        if (allowedItems.length > 0) {\n            _allowItemsInSlot(newSlotId, allowedItems);\n        }\n\n        emit SlotCreated(msg.sender, newSlotId, permanent, isBase);\n    }\n\n    function _setSlotBase(\n        uint8 slotId,\n        bool isBase\n    ) internal onlyValidSlot(slotId) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        inventorySL.slots[slotId].isBase = isBase;\n\n        if (isBase) {\n            inventorySL.baseSlotsIds.add(slotId);\n        } else {\n            inventorySL.baseSlotsIds.remove(slotId);\n        }\n    }\n\n    function _setSlotPermanent(\n        uint8 slotId,\n        bool permanent\n    ) internal onlyValidSlot(slotId) {\n        InventoryStorage.layout().slots[slotId].permanent = permanent;\n    }\n\n    function _addBaseModifierCoupons(\n        address account,\n        uint8[] calldata slotsIds,\n        uint[] calldata amounts\n    ) internal {\n        if (slotsIds.length != amounts.length)\n            revert Inventory_InputDataMismatch();\n\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        uint8 numSlots = inventorySL.numSlots;\n\n        for (uint i = 0; i < slotsIds.length; i++) {\n            if (slotsIds[i] == 0 && slotsIds[i] > numSlots) \n                revert Inventory_InvalidSlotId();\n            if (!inventorySL.slots[slotsIds[i]].isBase) {\n                revert Inventory_NonBaseSlot();\n            }\n            InventoryStorage.layout().baseModifierCoupon[account][slotsIds[i]] += amounts[i];\n        }\n\n        emit BaseModifierCouponAdded(msg.sender, account, slotsIds, amounts);\n    }\n\n    function _getbaseModifierCoupon(address account, uint8 slotId) internal view onlyValidSlot(slotId) returns (uint) {\n        if (!InventoryStorage.layout().slots[slotId].isBase) {\n            revert Inventory_NonBaseSlot();\n        }\n        return InventoryStorage.layout().baseModifierCoupon[account][slotId];\n    }\n\n    function _getBaseModifierCouponAll(address account) internal view returns (BaseModifierCoupon[] memory) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        uint numBaseSlots = inventorySL.baseSlotsIds.length();\n\n        BaseModifierCoupon[] memory coupons = new BaseModifierCoupon[](numBaseSlots);\n        uint counter;\n        for (uint8 i = 0; i < numBaseSlots; i++) {\n            uint8 slotId = uint8(inventorySL.baseSlotsIds.at(i));\n\n            coupons[counter].slotId = slotId;\n            coupons[counter].amount = inventorySL.baseModifierCoupon[account][slotId];\n            counter++;\n        }\n        return coupons;\n    }\n\n    function _getBaseSlotsIds() internal view returns (uint[] memory) {\n        return InventoryStorage.layout().baseSlotsIds.toArray();\n    }\n\n    function _setItemsTransferRequired(\n        InventoryStorage.Item[] calldata items,\n        bool[] calldata requiresTransfer\n    ) internal {\n        if (items.length != requiresTransfer.length)\n            revert Inventory_InputDataMismatch();\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        for (uint i = 0; i < items.length; i++) {\n            inventorySL.requiresTransfer[items[i].erc1155Contract][items[i].id] = requiresTransfer[i];\n        }\n    }\n    \n    function _allowItemsInSlot(\n        uint8 slotId,\n        InventoryStorage.Item[] calldata items\n    ) internal virtual onlyValidSlot(slotId) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        for (uint i = 0; i < items.length; i++) {\n            if (!items[i].erc1155Contract.isContract()) \n                revert Inventory_InvalidERC1155Contract();\n\n            inventorySL.itemSlot[items[i].erc1155Contract][items[i].id] = slotId;\n        }\n\n        emit ItemsAllowedInSlotUpdated(msg.sender, items);\n    }\n\n    function _disallowItems(\n        InventoryStorage.Item[] calldata items\n    ) internal virtual {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        for (uint i = 0; i < items.length; i++) {\n            delete inventorySL.itemSlot[items[i].erc1155Contract][items[i].id];\n        }\n\n        emit ItemsAllowedInSlotUpdated(msg.sender, items);\n    }\n\n    function _allowedSlot(InventoryStorage.Item calldata item) internal view returns (uint) {\n        return InventoryStorage.layout().itemSlot[item.erc1155Contract][item.id];\n    }\n\n    function _slot(uint8 slotId) internal view returns (InventoryStorage.Slot storage slot) {\n        return InventoryStorage.layout().slots[slotId];\n    }\n\n    function _slotsAll() internal view returns (InventoryStorage.Slot[] memory slotsAll) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        \n        uint8 numSlots = inventorySL.numSlots;\n        slotsAll = new InventoryStorage.Slot[](numSlots);\n\n        for (uint8 i = 0; i < numSlots; i++) {\n            uint8 slotId = i + 1;\n            slotsAll[i] = inventorySL.slots[slotId];\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/inventory/InventoryStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport {ReentrancyGuard} from \"@solidstate/contracts/utils/ReentrancyGuard.sol\";\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { EnumerableSet } from \"@solidstate/contracts/data/EnumerableSet.sol\";\n\n/**\nLibInventory defines the storage structure used by the Inventory contract as a facet for an EIP-2535 Diamond\nproxy.\n */\nlibrary InventoryStorage {\n    bytes32 constant INVENTORY_STORAGE_POSITION =\n        keccak256(\"inventory.storage.position\");\n\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // Holds the information needed to identify an ERC1155 item\n    struct Item {\n        address erc1155Contract;\n        uint id;\n    }\n\n    // Holds the general information about a slot\n    struct Slot {\n        uint8 id;\n        bool permanent;\n        bool isBase;\n    }\n\n    struct Layout {\n        uint8 numSlots;\n\n        // Slot id => Slot\n        mapping(uint8 => Slot) slots;\n\n        // arcadian id => slot id => Items equipped\n        mapping(uint => mapping(uint8 => Item)) equippedItems;\n\n        // item address => item id => allowed slot id\n        mapping(address => mapping(uint => uint8)) itemSlot;\n        \n        // item address => item id => equip items requires transfer\n        mapping(address => mapping(uint => bool)) requiresTransfer;\n\n        // List of all the base slots ids\n        EnumerableSet.UintSet baseSlotsIds;\n\n        // List of all the existent hashes\n        EnumerableSet.Bytes32Set baseItemsHashes;\n        // arcadian id => base items hash\n        mapping(uint => bytes32) arcadianToBaseItemHash;\n\n        // account => slotId => number of coupons to modify the base traits\n        mapping(address => mapping(uint => uint)) baseModifierCoupon;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage istore)\n    {\n        bytes32 position = INVENTORY_STORAGE_POSITION;\n        assembly {\n            istore.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/items/ItemsFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { ERC1155Base } from \"@solidstate/contracts/token/ERC1155/base/ERC1155Base.sol\";\nimport { ERC1155BaseInternal } from \"@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol\";\nimport { ERC1155Enumerable } from \"@solidstate/contracts/token/ERC1155/enumerable/ERC1155Enumerable.sol\";\nimport { ERC1155EnumerableInternal } from \"@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableInternal.sol\";\nimport { ERC1155Metadata } from \"@solidstate/contracts/token/ERC1155/metadata/ERC1155Metadata.sol\";\nimport { ReentrancyGuard } from \"@solidstate/contracts/utils/ReentrancyGuard.sol\";\nimport { ItemsInternal } from \"./ItemsInternal.sol\";\nimport { ItemsStorage } from \"./ItemsStorage.sol\";\nimport { Multicall } from \"@solidstate/contracts/utils/Multicall.sol\";\nimport { IERC1155 } from '@solidstate/contracts/interfaces/IERC1155.sol';\n\n/**\n * @title ItemsFacet\n * @dev This contract handles the creation and management of items\n * It uses ERC1155 tokens to represent items and provides methods to mint new items,\n * claim items via Merkle tree or a whitelist, and set the base and URIs for\n * the items. It also uses the ReentrancyGuard and Multicall contracts for security\n * and gas efficiency.\n */\ncontract ItemsFacet is ERC1155Base, ERC1155Enumerable, ERC1155Metadata, ReentrancyGuard, ItemsInternal, Multicall {\n    \n    /**\n     * @notice Claims an item if present in the Merkle tree\n     * @param itemId The ID of the item to claim\n     * @param amount The amount of the item to claim\n     * @param proof The Merkle proof for the item\n     */\n    function claimMerkle(uint itemId, uint amount, bytes32[] calldata proof)\n        public nonReentrant\n    {\n        _claimMerkle(msg.sender, itemId, amount, proof);\n    }\n\n    /**\n     * @notice Claims items if present in the Merkle tree\n     * @param itemsIds The IDs of the items to claim\n     * @param amounts The amounts of the items to claim\n     * @param proofs The Merkle proofs for the items\n     */\n    function claimMerkleBatch(uint[] calldata itemsIds, uint[] calldata amounts, bytes32[][] calldata proofs) external nonReentrant {\n        _claimMerkleBatch(msg.sender, itemsIds, amounts, proofs);\n    }\n\n    /**\n     * @notice Claims items from a whitelist\n     * @param itemIds The IDs of the items to claim\n     * @param amounts The amounts of the items to claim\n     */\n    function claimWhitelist(uint[] calldata itemIds, uint[] calldata amounts) external {\n        _claimWhitelist(itemIds, amounts);\n    }\n\n    /**\n     * @notice Amount claimed by an address of a specific item\n     * @param account the account to query\n     * @param itemId the item id to query\n     * @return amount returns the claimed amount given an account and an item id\n     */\n    function claimedAmount(address account, uint itemId) external view returns (uint amount) {\n        return _claimedAmount(account, itemId);\n    }\n\n    /**\n     * @notice Mints a new item. Only minter role account can mint\n     * @param to The address to mint the item to\n     * @param itemId The ID of the item to mint\n     * @param amount The item amount to be minted\n     */\n    function mint(address to, uint itemId, uint amount)\n        public onlyManager\n    {\n        _mint(to, itemId, amount);\n    }\n\n    /**\n     * @notice Mint a batch of items to a specific address. Only minter role account can mint\n     * @param to The address to receive the minted items\n     * @param itemIds An array of items IDs to be minted\n     * @param amounts The items amounts to be minted\n     */\n    function mintBatch(address to, uint[] calldata itemIds, uint[] calldata amounts)\n        public onlyManager\n    {\n        _mintBatch(to, itemIds, amounts);\n    }\n\n    /**\n     * @notice Set the base URI for all items metadata\n     * @dev Only the manager role can call this function\n     * @param baseURI The new base URI\n     */\n    function setBaseURI(string calldata baseURI) external onlyManager {\n        _setBaseURI(baseURI);\n    }\n\n    /**\n     * @notice Set the base URI for all items metadata\n     * @dev Only the manager role can call this function\n     * @param newBaseURI The new base URI\n     * @param migrate Should migrate to IPFS\n     */\n    function migrateToIPFS(string calldata newBaseURI, bool migrate) external onlyManager {\n        _migrateToIPFS(newBaseURI, migrate);\n    }\n\n    /**\n     * @dev Returns the current inventory address\n     * @return The address of the inventory contract\n     */\n    function getInventoryAddress() external view returns (address) {\n        return _getInventoryAddress();\n    }\n\n    /**\n     * @dev Sets the inventory address\n     * @param inventoryAddress The new address of the inventory contract\n     */\n    function setInventoryAddress(address inventoryAddress) external onlyManager {\n        _setInventoryAddress(inventoryAddress);\n    }\n\n    /**\n     * @notice Override ERC1155Metadata\n     */\n    function uri(uint tokenId) public view override returns (string memory) {\n        if (ItemsStorage.layout().isMigratedToIPFS) {\n            return string.concat(super.uri(tokenId), \".json\");\n        } else {\n            return super.uri(tokenId);\n        }\n    }\n\n    /**\n     * @notice Set the URI for a specific item ID\n     * @dev Only the manager role can call this function\n     * @param tokenId The ID of the item to set the URI for\n     * @param tokenURI The new item URI\n     */\n    function setTokenURI(uint tokenId, string calldata tokenURI) external onlyManager {\n        _setTokenURI(tokenId, tokenURI);\n    }\n\n\n    // overrides\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint id,\n        uint amount,\n        bytes memory data\n    ) public override (ERC1155Base) {\n        // Add red carpet logic for the inventory\n        if (from != msg.sender && !isApprovedForAll(from, msg.sender) && _getInventoryAddress() != msg.sender )\n            revert ERC1155Base__NotOwnerOrApproved();\n        _safeTransfer(msg.sender, from, to, id, amount, data);\n    }\n\n    function supportsInterface(bytes4 _interface) external pure returns (bool) {\n        return type(IERC1155).interfaceId == _interface;\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint[] memory ids,\n        uint[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n        override (ERC1155BaseInternal, ERC1155EnumerableInternal, ItemsInternal)\n    {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n}"
    },
    "contracts/arcadiaDiamonds/items/ItemsInit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { ERC1155BaseInternal } from \"@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol\";\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { ItemsInternal } from \"./ItemsInternal.sol\";\nimport { InventoryInternal } from \"../inventory/InventoryInternal.sol\";\nimport { ERC165BaseInternal } from '@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol';\nimport { IERC1155 } from '@solidstate/contracts/interfaces/IERC1155.sol';\n\ncontract ItemsInit is RolesInternal, ItemsInternal, InventoryInternal, ERC165BaseInternal {    \n    function init(bytes32 merkleRoot, string calldata baseUri, address inventoryAddress) external {\n\n        _setSupportsInterface(type(IERC1155).interfaceId, true);\n\n        _updateMerkleRoot(merkleRoot);\n\n        _initRoles();\n\n        _setBaseURI(baseUri);\n        _setInventoryAddress(inventoryAddress);\n    }\n}\n"
    },
    "contracts/arcadiaDiamonds/items/ItemsInternal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { ERC1155BaseInternal } from \"@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol\";\nimport { ERC1155EnumerableInternal } from \"@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableInternal.sol\";\nimport { ERC1155MetadataInternal } from \"@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataInternal.sol\";\nimport { ItemsStorage } from \"./ItemsStorage.sol\";\nimport { MerkleInternal } from \"../merkle/MerkleInternal.sol\";\nimport { WhitelistInternal } from \"../whitelist/WhitelistInternal.sol\";\nimport { ArrayUtils } from \"@solidstate/contracts/utils/ArrayUtils.sol\";\nimport { WhitelistStorage } from \"../whitelist/WhitelistStorage.sol\";\n\ncontract ItemsInternal is MerkleInternal, WhitelistInternal, ERC1155BaseInternal, ERC1155EnumerableInternal, ERC1155MetadataInternal {\n\n    error Items_InputsLengthMistatch();\n    error Items_InvalidItemId();\n    error Items_ItemsBasicStatusAlreadyUpdated();\n    error Items_MintingNonBasicItem();\n    error Items_MaximumItemMintsExceeded();\n\n    event ItemClaimedMerkle(address indexed to, uint indexed itemId, uint amount);\n\n    using ArrayUtils for uint[];\n\n    function _claimMerkle(address to, uint itemId, uint amount, bytes32[] memory proof)\n        internal\n    {\n        if (itemId < 1) revert Items_InvalidItemId();\n\n        ItemsStorage.Layout storage itemsSL = ItemsStorage.layout();\n\n        bytes memory leaf = abi.encode(to, itemId, amount);\n        _consumeLeaf(proof, leaf);\n\n        ERC1155BaseInternal._mint(to, itemId, amount, \"\");\n\n        itemsSL.amountClaimed[to][itemId] += amount;\n        emit ItemClaimedMerkle(to, itemId, amount);\n    }\n\n    function _claimMerkleBatch(address to, uint[] calldata itemIds, uint[] calldata amounts, bytes32[][] calldata proofs) \n        internal\n    {\n        if (itemIds.length != amounts.length) \n            revert Items_InputsLengthMistatch();\n        \n        for (uint i = 0; i < itemIds.length; i++) {\n            _claimMerkle(to, itemIds[i], amounts[i], proofs[i]);\n        }\n    }\n    \n    function _claimWhitelist(uint[] calldata itemIds, uint[] calldata amounts) internal {\n        if (itemIds.length != amounts.length) \n            revert Items_InputsLengthMistatch();\n\n\n        uint totalAmount = 0;\n        for (uint i = 0; i < itemIds.length; i++) {\n            if (itemIds[i] < 1) \n                revert Items_InvalidItemId();\n\n            ERC1155BaseInternal._mint(msg.sender, itemIds[i], amounts[i], \"\");\n            totalAmount += amounts[i];\n        }\n        _consumeWhitelist(WhitelistStorage.PoolId.Guaranteed, msg.sender, totalAmount);\n    }\n\n    function _claimedAmount(address account, uint itemId) internal view returns (uint) {\n        return ItemsStorage.layout().amountClaimed[account][itemId];\n    }\n\n    function _mint(address to, uint itemId, uint amount)\n        internal\n    {\n        if (itemId < 1) revert Items_InvalidItemId();\n\n        ERC1155BaseInternal._mint(to, itemId, amount, \"\");\n    }\n\n    function _mintBatch(address to, uint[] calldata itemsIds, uint[] calldata amounts)\n        internal\n    {\n        if (itemsIds.min() < 1) revert Items_InvalidItemId();\n\n        ERC1155BaseInternal._mintBatch(to, itemsIds, amounts, \"\");\n    }\n\n    function _migrateToIPFS(string calldata newBaseURI, bool migrate) internal {\n        _setBaseURI(newBaseURI);\n        ItemsStorage.layout().isMigratedToIPFS = migrate;\n    }\n\n    function _getInventoryAddress() internal view returns (address) {\n        return ItemsStorage.layout().inventoryAddress;\n    }\n\n    function _setInventoryAddress(address inventoryAddress) internal {\n        ItemsStorage.layout().inventoryAddress = inventoryAddress;\n    }\n\n    // overrides\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint[] memory ids,\n        uint[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n        override (ERC1155BaseInternal, ERC1155EnumerableInternal)\n    {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n}"
    },
    "contracts/arcadiaDiamonds/items/ItemsStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nlibrary ItemsStorage {\n\n    bytes32 constant ITEMS_STORAGE_POSITION =\n        keccak256(\"items.storage.position\");\n\n    struct Layout {\n        // wallet address => token id => is claimed \n        mapping(address => mapping(uint => uint)) amountClaimed;\n        bool isMigratedToIPFS;\n\n        // token id => is basic item\n        mapping(uint => bool) isBasicItem;\n        uint[] basicItemsIds;\n        address inventoryAddress;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = ITEMS_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/merkle/MerkleFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { MerkleInternal } from './MerkleInternal.sol';\n\n/**\n * @title MerkleFacet\n * @notice This contract provides external functions to retrieve and update the Merkle root hash,\n * which is used to verify the authenticity of data in a Merkle tree.\n * This contract can be used as a facet of a diamond which follows the EIP-2535 diamond standard.\n */\ncontract MerkleFacet is MerkleInternal {\n\n    /**\n     * @notice Returns the current Merkle root hash\n     * @return The current Merkle root hash\n     */\n    function merkleRoot() external view returns (bytes32) {\n        return _merkleRoot();\n    }\n    \n    /**\n     * @notice Updates the Merkle root hash with a new value\n     * @dev This function can only be called by an address with the manager role\n     * @param newMerkleRoot The new Merkle root hash value to be set\n     */\n    function updateMerkleRoot(bytes32 newMerkleRoot) external onlyManager {\n        _updateMerkleRoot(newMerkleRoot);\n    }\n\n    /**\n     * @notice Updates the claim state to active and enables the claim of tokens\n     * @dev This function can only be called by an address with the manager role\n     */\n    function setMerkleClaimActive() external onlyManager {\n        _setMerkleClaimActive();\n    }\n\n    /**\n     * @notice Updates the claim state to inactive and disables the claim of tokens\n     * @dev This function can only be called by an address with the manager role\n     */\n    function setMerkleClaimInactive() external onlyManager {\n        _setMerkleClaimInactive();\n    }\n\n    /**\n     * @notice Returns true if elegible tokens can be claimed, or false otherwise\n     * @return active bool indicating if claim is active\n     */\n    function isMerkleClaimActive() view external returns (bool active) {\n        return _isMerkleClaimActive();\n    }\n}"
    },
    "contracts/arcadiaDiamonds/merkle/MerkleInternal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { MerkleProof } from \"@solidstate/contracts/cryptography/MerkleProof.sol\";\nimport { MerkleStorage } from \"./MerkleStorage.sol\";\nimport { RolesInternal } from \"./../roles/RolesInternal.sol\";\n\ncontract MerkleInternal is RolesInternal {\n\n    error Merkle_AlreadyClaimed();\n    error Merkle_InvalidClaimAmount();\n    error Merkle_NotIncludedInMerkleTree();\n    error Merkle_ClaimInactive();\n    error Merkle_ClaimStateAlreadyUpdated();\n\n    function _merkleRoot() internal view returns (bytes32) {\n        return MerkleStorage.layout().merkleRoot;\n    }\n\n    function _updateMerkleRoot(bytes32 newMerkleRoot) internal {\n        MerkleStorage.layout().merkleRoot = newMerkleRoot;\n    }\n\n    function _isMerkleClaimActive() view internal returns (bool) {\n        return !MerkleStorage.layout().claimInactive;\n    }\n\n    function _setMerkleClaimActive() internal {\n        MerkleStorage.Layout storage merkleSL = MerkleStorage.layout();\n\n        if (!merkleSL.claimInactive) revert Merkle_ClaimStateAlreadyUpdated();\n        \n        merkleSL.claimInactive = false;\n    }\n\n    function _setMerkleClaimInactive() internal {\n        MerkleStorage.Layout storage merkleSL = MerkleStorage.layout();\n\n        if (merkleSL.claimInactive) revert Merkle_ClaimStateAlreadyUpdated();\n        \n        merkleSL.claimInactive = true;\n    }\n\n    // To create 'leaf' use abi.encode(leafProp1, leafProp2, ...)\n    function _consumeLeaf(bytes32[] memory proof, bytes memory _leaf) internal {\n        MerkleStorage.Layout storage merkleSL = MerkleStorage.layout();\n\n        if (merkleSL.claimInactive) revert Merkle_ClaimInactive();\n\n        // TODO: IMPORTANT: ON PRODUCTION REVERT CHANGED ON ITEMS MERKLE CLAIM, TO AVOID INFINITE CLAIM\n        bytes32 proofHash = keccak256(abi.encodePacked(proof));\n        // if (merkleSL.claimedProof[proofHash]) revert Merkle_AlreadyClaimed();\n\n        bytes32 leaf = keccak256(bytes.concat(keccak256(_leaf)));\n        bool isValid = MerkleProof.verify(proof, merkleSL.merkleRoot, leaf);\n        \n        if (!isValid) revert Merkle_NotIncludedInMerkleTree();\n        \n        merkleSL.claimedProof[proofHash] = true;\n    }\n}"
    },
    "contracts/arcadiaDiamonds/merkle/MerkleStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nlibrary MerkleStorage {\n\n    bytes32 constant MERKLE_STORAGE_POSITION =\n        keccak256(\"merkle.storage.position\");\n\n    struct Layout {\n        bytes32 merkleRoot;\n        bool claimInactive;\n        mapping(bytes32 => bool) claimedProof;\n        mapping(address => uint) amountClaimed;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = MERKLE_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/roles/RolesFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { AccessControl } from \"@solidstate/contracts/access/access_control/AccessControl.sol\";\nimport { RolesInternal } from './RolesInternal.sol';\n/**\n * @title RolesFacet\n * @notice This contract provides external functions to retrieve the role IDs used by the AccessControl contract.\n * The contract extends the RolesInternal contract which provides internal functions to manage roles.\n * This contract can be used as a facet of a diamond which follows the EIP-2535 diamond standard\n */\ncontract RolesFacet is RolesInternal, AccessControl {\n    /**\n     * @notice Returns the ID of the default admin role\n     * @return The ID of the default admin role\n     */\n    function defaultAdminRole() external pure returns (bytes32) {\n        return _defaultAdminRole();\n    }\n\n    /**\n     * @notice Returns the ID of the manager role\n     * @return The ID of the manager role\n     */\n    function managerRole() external view returns (bytes32) {\n        return _managerRole();\n    }\n\n    /**\n     * @notice Returns the ID of the automation role\n     * @return The ID of the automation role\n     */\n    function automationRole() external view returns (bytes32) {\n        return _automationRole();\n    }\n}"
    },
    "contracts/arcadiaDiamonds/roles/RolesInternal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { AccessControlInternal } from \"@solidstate/contracts/access/access_control/AccessControlInternal.sol\";\nimport { AccessControlStorage } from \"@solidstate/contracts/access/access_control/AccessControlStorage.sol\";\nimport { RolesStorage } from './RolesStorage.sol';\n\ncontract RolesInternal is AccessControlInternal {\n\n    error Roles_MissingAdminRole();\n    error Roles_MissingManagerRole();\n    error Roles_MissingAutomationRole();\n\n    modifier onlyDefaultAdmin() {\n        if (!_hasRole(_defaultAdminRole(), msg.sender))\n            revert Roles_MissingAdminRole();\n        _;\n    }\n\n    modifier onlyManager() {\n        if (!_hasRole(_managerRole(), msg.sender))\n            revert Roles_MissingManagerRole();\n        _;\n    }\n\n    modifier onlyAutomation() {\n        if (!_hasRole(_managerRole(), msg.sender) && !_hasRole(_automationRole(), msg.sender))\n            revert Roles_MissingAutomationRole();\n        _;\n    }\n\n    function _defaultAdminRole() internal pure returns (bytes32) {\n        return AccessControlStorage.DEFAULT_ADMIN_ROLE;\n    }\n\n    function _managerRole() internal view returns (bytes32) {\n        return RolesStorage.layout().managerRole;\n    }\n\n    function _automationRole() internal view returns (bytes32) {\n        return RolesStorage.layout().automationRole;\n    }\n\n    function _initRoles() internal {\n        RolesStorage.Layout storage rolesSL = RolesStorage.layout();\n        rolesSL.managerRole = keccak256(\"manager.role\");\n        rolesSL.automationRole = keccak256(\"automation.role\");\n\n        _grantRole(_defaultAdminRole(), msg.sender);\n        _grantRole(_managerRole(), msg.sender);\n    }\n}"
    },
    "contracts/arcadiaDiamonds/roles/RolesStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nlibrary RolesStorage {\n\n    bytes32 constant ROLES_STORAGE_POSITION =\n        keccak256(\"roles.storage.position\");\n\n    struct Layout {\n        bytes32 managerRole;\n        bytes32 automationRole;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = ROLES_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/whitelist/WhitelistFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { WhitelistInternal } from './WhitelistInternal.sol';\nimport { WhitelistStorage } from \"./WhitelistStorage.sol\";\n\n/**\n * @title WhitelistFacet\n * @notice This contract allows the admins to whitelist an address with a specific amount,\n * which can then be used to claim tokens in other contracts.\n * To consume the whitelist, the token contracts should call the internal functions from WhitelistInternal.\n * This contract can be used as a facet of a diamond which follows the EIP-2535 diamond standard.\n */\ncontract WhitelistFacet is WhitelistInternal {\n    WhitelistStorage.PoolId constant GuaranteedPool = WhitelistStorage.PoolId.Guaranteed;\n    WhitelistStorage.PoolId constant RestrictedPool = WhitelistStorage.PoolId.Restricted;\n\n    /**\n     * @return The amount claimed from the guaranteed pool by the account\n     */\n    function claimedGuaranteedPool(address account) external view returns (uint) {\n        return _claimedWhitelist(GuaranteedPool, account);\n    }\n\n    /**\n     * @return The amount claimed from the restricted pool by the account \n     */\n    function claimedRestrictedPool(address account) external view returns (uint) {\n        return _claimedWhitelist(RestrictedPool, account);\n    }\n\n    /**\n     * @return The account elegible amount from the guaranteed pool\n     */\n    function elegibleGuaranteedPool(address account) external view returns (uint) {\n        return _elegibleWhitelist(GuaranteedPool, account);\n    }\n\n    /**\n     * @return The account elegible amount from the restricted pool\n     */\n    function elegibleRestrictedPool(address account) external view returns (uint) {\n        return _elegibleWhitelist(RestrictedPool, account);\n    }\n    \n    /**\n     * @return The total claimed amount from the Guaranteed pool\n     */\n    function totalClaimedGuaranteedPool() external view returns (uint) {\n        return _totalClaimedWhitelist(GuaranteedPool);\n    }\n    \n    /**\n     * @return The total claimed amount from the Restricted pool\n     */\n    function totalClaimedRestrictedPool() external view returns (uint) {\n        return _totalClaimedWhitelist(RestrictedPool);\n    }\n    \n    /**\n     * @return The total elegible amount from the Guaranteed pool\n     */\n    function totalElegibleGuaranteedPool() external view returns (uint) {\n        return _totalElegibleWhitelist(GuaranteedPool);\n    }\n\n    /**\n     * @return The total elegible amount from the Restricted pool\n     */\n    function totalElegibleRestrictedPool() external view returns (uint) {\n        return _totalElegibleWhitelist(RestrictedPool);\n    }\n\n    /**\n     * @notice Increase the account whitelist elegible amount in the Guaranteed pool\n     * @dev This function can only be called by an address with the manager role\n     * @param account The address to add to the whitelist\n     * @param amount The amount to whitelist for the address\n     */\n    function increaseElegibleGuaranteedPool(address account, uint amount) onlyManager external {\n        _increaseWhitelistElegible(GuaranteedPool, account, amount);\n    }\n\n    /**\n     * @notice Increase the account whitelist elegible amount in the restricted pool\n     * @dev This function can only be called by an address with the manager role\n     * @param account The address to add to the whitelist\n     * @param amount The amount to whitelist for the address\n     */\n    function increaseElegibleRestrictedPool(address account, uint amount) onlyManager external {\n        _increaseWhitelistElegible(RestrictedPool, account, amount);\n    }\n\n    /**\n     * @notice Increase the guaranteed pool elegible amounts for multiple addresses\n     * @dev This function can only be called by an address with the manager role\n     * @param accounts An array of addresses to add to the whitelist\n     * @param amounts An array of amounts to whitelist for each address\n     */\n    function increaseElegibleGuaranteedPoolBatch(address[] calldata accounts, uint[] calldata amounts) external onlyManager {\n        _increaseWhitelistElegibleBatch(GuaranteedPool, accounts, amounts);\n    }\n\n    /**\n     * @notice Increase the restricted pool elegible amounts for multiple addresses\n     * @dev This function can only be called by an address with the manager role\n     * @param accounts An array of addresses to add to the whitelist\n     * @param amounts An array of amounts to whitelist for each address\n     */\n    function increaseElegibleRestrictedPoolBatch(address[] calldata accounts, uint[] calldata amounts) external onlyManager {\n        _increaseWhitelistElegibleBatch(RestrictedPool, accounts, amounts);\n    }\n\n    /**\n     * @notice Adds a new address to the Guaranteed Pool with a specific amount\n     * @dev This function can only be called by an address with the manager role\n     * @param account The address to add to the whitelist\n     * @param totalAmount The amount to whitelist for the address\n     */\n    function setElegibleGuaranteedPool(address account, uint totalAmount) onlyManager external {\n        _setWhitelistElegible(GuaranteedPool, account, totalAmount);\n    }\n\n    /**\n     * @notice Adds a new address to the Restricted Pool with a specific amount\n     * @dev This function can only be called by an address with the manager role\n     * @param account The address to add to the whitelist\n     * @param totalAmount The amount to whitelist for the address\n     */\n    function setElegibleRestrictedPool(address account, uint totalAmount) onlyManager external {\n        _setWhitelistElegible(RestrictedPool, account, totalAmount);\n    }\n\n    /**\n     * @notice Adds multiple addresses to the Guaranteed Pool with specific amounts\n     * @dev This function can only be called by an address with the manager role\n     * @param accounts An array of addresses to add to the whitelist\n     * @param totalAmounts An array of amounts to whitelist for each address\n     */\n    function setElegibleGuaranteedPoolBatch(address[] calldata accounts, uint[] calldata totalAmounts) external onlyManager {\n        _setWhitelistElegibleBatch(GuaranteedPool, accounts, totalAmounts);\n    }\n\n    /**\n     * @notice Adds multiple addresses to the Restricted Pool with specific amounts\n     * @dev This function can only be called by an address with the manager role\n     * @param accounts An array of addresses to add to the whitelist\n     * @param totalAmounts An array of amounts to whitelist for each address\n     */\n    function setElegibleRestrictedPoolBatch(address[] calldata accounts, uint[] calldata totalAmounts) external onlyManager {\n        _setWhitelistElegibleBatch(RestrictedPool, accounts, totalAmounts);\n    }\n\n    /**\n     * @notice Updates the claim state to active and enables the guaranteed pool token claim\n     * @dev This function can only be called by an address with the manager role\n     */\n    function setClaimActiveGuaranteedPool(bool active) external onlyManager {\n        _setWhitelistClaimActive(GuaranteedPool, active);\n    }\n\n    /**\n     * @notice Updates the claim state to active and enables the restricted pool token claim\n     * @dev This function can only be called by an address with the manager role\n     */\n    function setClaimActiveRestrictedPool(bool active) external onlyManager {\n        _setWhitelistClaimActive(RestrictedPool, active);\n    }\n\n    /**\n     * @notice Returns true if elegible tokens can be claimed in the guaranteed pool, or false otherwise\n     * @return active bool indicating if claim is active\n     */\n    function isClaimActiveGuaranteedPool() view external returns (bool active) {\n        return _isWhitelistClaimActive(GuaranteedPool);\n    }\n\n    /**\n     * @notice Returns true if elegible tokens can be claimed in the restricted pool, or false otherwise\n     * @return active bool indicating if claim is active\n     */\n    function isClaimActiveRestrictedPool() view external returns (bool active) {\n        return _isWhitelistClaimActive(RestrictedPool);\n    }\n}"
    },
    "contracts/arcadiaDiamonds/whitelist/WhitelistInternal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { WhitelistStorage } from \"./WhitelistStorage.sol\";\nimport { RolesInternal } from \"./../roles/RolesInternal.sol\";\n\ncontract WhitelistInternal is RolesInternal {\n\n    error Whitelist_ExceedsElegibleAmount();\n    error Whitelist_InputDataMismatch();\n    error Whitelist_ClaimStateAlreadyUpdated();\n    error Whitelist_ClaimInactive();\n\n    event WhitelistBalanceChanged(address indexed account, WhitelistStorage.PoolId poolId, uint totalElegibleAmount, uint totalClaimedAmount);\n\n    function _totalClaimedWhitelist(WhitelistStorage.PoolId poolId) internal view returns (uint) {\n        return WhitelistStorage.layout().pools[poolId].totalClaimed;\n    }\n\n    function _totalElegibleWhitelist(WhitelistStorage.PoolId poolId) internal view returns (uint) {\n        return WhitelistStorage.layout().pools[poolId].totalElegible;\n    }\n\n    function _claimedWhitelist(WhitelistStorage.PoolId poolId, address account) internal view returns (uint) {\n        return WhitelistStorage.layout().pools[poolId].claimed[account];\n    }\n\n    function _elegibleWhitelist(WhitelistStorage.PoolId poolId, address account) internal view returns (uint) {\n        return WhitelistStorage.layout().pools[poolId].elegible[account];\n    }\n\n    function _consumeWhitelist(WhitelistStorage.PoolId poolId, address account, uint amount) internal {\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        WhitelistStorage.Pool storage pool = whitelistSL.pools[poolId];\n\n        if (!pool.claimActive)\n            revert Whitelist_ClaimInactive();\n\n        if (pool.elegible[account] < amount) \n            revert Whitelist_ExceedsElegibleAmount();\n\n        pool.elegible[account] -= amount;\n        pool.claimed[account] += amount;\n        pool.totalClaimed += amount;\n        pool.totalElegible -= amount;\n\n        emit WhitelistBalanceChanged(account, poolId, pool.elegible[account], pool.claimed[account]);\n    }\n\n    function _increaseWhitelistElegible(WhitelistStorage.PoolId poolId, address account, uint amount) internal {\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        WhitelistStorage.Pool storage pool = whitelistSL.pools[poolId];\n        pool.elegible[account] += amount;\n        pool.totalElegible += amount;\n        \n        emit WhitelistBalanceChanged(account, poolId, pool.elegible[account], pool.claimed[account]);\n    }\n\n    function _increaseWhitelistElegibleBatch(WhitelistStorage.PoolId poolId, address[] calldata accounts, uint[] calldata amounts) internal {\n        if (accounts.length != amounts.length) revert Whitelist_InputDataMismatch();\n\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        WhitelistStorage.Pool storage pool = whitelistSL.pools[poolId];\n\n        for (uint i = 0; i < accounts.length; i++) {\n            pool.elegible[accounts[i]] += amounts[i];\n            pool.totalElegible += amounts[i];\n            emit WhitelistBalanceChanged(accounts[i], poolId, pool.elegible[accounts[i]], pool.claimed[accounts[i]]);\n        }\n    }\n\n    function _setWhitelistElegible(WhitelistStorage.PoolId poolId, address account, uint amount) internal {\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        WhitelistStorage.Pool storage pool = whitelistSL.pools[poolId];\n\n        pool.totalElegible += amount - pool.elegible[account];\n        pool.elegible[account] += amount;\n        emit WhitelistBalanceChanged(account, poolId, pool.elegible[account], pool.claimed[account]);\n    }\n\n    function _setWhitelistElegibleBatch(WhitelistStorage.PoolId poolId, address[] calldata accounts, uint[] calldata amounts) internal {\n        if (accounts.length != amounts.length) revert Whitelist_InputDataMismatch();\n\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        WhitelistStorage.Pool storage pool = whitelistSL.pools[poolId];\n\n        for (uint i = 0; i < accounts.length; i++) {\n            pool.totalElegible += amounts[i] - pool.elegible[accounts[i]];\n            pool.elegible[accounts[i]] = amounts[i];\n            emit WhitelistBalanceChanged(accounts[i], poolId, pool.elegible[accounts[i]], pool.claimed[accounts[i]]);\n        }\n    }\n\n    function _isWhitelistClaimActive(WhitelistStorage.PoolId poolId) view internal returns (bool) {\n        return WhitelistStorage.layout().pools[poolId].claimActive;\n    }\n\n    function _setWhitelistClaimActive(WhitelistStorage.PoolId poolId, bool active) internal {\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        WhitelistStorage.Pool storage pool = whitelistSL.pools[poolId];\n\n        if (active == pool.claimActive) \n            revert Whitelist_ClaimStateAlreadyUpdated();\n        \n        pool.claimActive = active;\n    }\n}"
    },
    "contracts/arcadiaDiamonds/whitelist/WhitelistStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nlibrary WhitelistStorage {\n\n    bytes32 constant WHITELIST_STORAGE_POSITION =\n        keccak256(\"whitelist.storage.position\");\n\n    enum PoolId { Guaranteed, Restricted }\n    \n    struct Pool {\n        mapping(address => uint) claimed;\n        mapping(address => uint) elegible;\n        uint totalClaimed;\n        uint totalElegible;\n        bool claimActive;\n    }\n\n    struct Layout {\n        // pool id => tokens pool\n        mapping(PoolId => Pool) pools;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = WHITELIST_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 250
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}