{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { UintUtils } from '../../utils/UintUtils.sol';\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\nimport { AccessControlStorage } from './AccessControlStorage.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControlInternal is IAccessControlInternal {\n    using AddressUtils for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using UintUtils for uint256;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function _hasRole(\n        bytes32 role,\n        address account\n    ) internal view virtual returns (bool) {\n        return\n            AccessControlStorage.layout().roles[role].members.contains(account);\n    }\n\n    /**\n     * @notice revert if sender does not have given role\n     * @param role role to query\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, msg.sender);\n    }\n\n    /**\n     * @notice revert if given account does not have given role\n     * @param role role to query\n     * @param account to query\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!_hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        'AccessControl: account ',\n                        account.toString(),\n                        ' is missing role ',\n                        uint256(role).toHexString(32)\n                    )\n                )\n            );\n        }\n    }\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function _getRoleAdmin(\n        bytes32 role\n    ) internal view virtual returns (bytes32) {\n        return AccessControlStorage.layout().roles[role].adminRole;\n    }\n\n    /**\n     * @notice set role as admin role\n     * @param role role to set\n     * @param adminRole admin role to set\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = _getRoleAdmin(role);\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.remove(account);\n        emit RoleRevoked(role, account, msg.sender);\n    }\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function _renounceRole(bytes32 role) internal virtual {\n        _revokeRole(role, msg.sender);\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\n\nlibrary AccessControlStorage {\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) roles;\n    }\n\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.AccessControl');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial AccessControl interface needed by internal functions\n */\ninterface IAccessControlInternal {\n    event RoleAdminChanged(\n        bytes32 indexed role,\n        bytes32 indexed previousAdminRole,\n        bytes32 indexed newAdminRole\n    );\n\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n}\n"
    },
    "@solidstate/contracts/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Merkle tree verification utility\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary MerkleProof {\n    /**\n     * @notice verify whether given leaf is contained within Merkle tree defined by given root\n     * @param proof proof that Merkle tree contains given leaf\n     * @param root Merkle tree root\n     * @param leaf element whose presence in Merkle tree to prove\n     * @return whether leaf is proven to be contained within Merkle tree defined by root\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        unchecked {\n            bytes32 computedHash = leaf;\n\n            for (uint256 i = 0; i < proof.length; i++) {\n                bytes32 proofElement = proof[i];\n\n                if (computedHash <= proofElement) {\n                    computedHash = keccak256(\n                        abi.encodePacked(computedHash, proofElement)\n                    );\n                } else {\n                    computedHash = keccak256(\n                        abi.encodePacked(proofElement, computedHash)\n                    );\n                }\n            }\n\n            return computedHash == root;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/data/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    error EnumerableSet__IndexOutOfBounds();\n\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(\n        Bytes32Set storage set,\n        uint256 index\n    ) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    function at(\n        AddressSet storage set,\n        uint256 index\n    ) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(\n        UintSet storage set,\n        uint256 index\n    ) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    function contains(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function contains(\n        AddressSet storage set,\n        address value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function indexOf(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, value);\n    }\n\n    function indexOf(\n        AddressSet storage set,\n        address value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function indexOf(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(value));\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function add(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function remove(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        UintSet storage set,\n        uint256 value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function toArray(\n        Bytes32Set storage set\n    ) internal view returns (bytes32[] memory) {\n        return set._inner._values;\n    }\n\n    function toArray(\n        AddressSet storage set\n    ) internal view returns (address[] memory) {\n        bytes32[] storage values = set._inner._values;\n        address[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function toArray(\n        UintSet storage set\n    ) internal view returns (uint256[] memory) {\n        bytes32[] storage values = set._inner._values;\n        uint256[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function _at(\n        Set storage set,\n        uint256 index\n    ) private view returns (bytes32) {\n        if (index >= set._values.length)\n            revert EnumerableSet__IndexOutOfBounds();\n        return set._values[index];\n    }\n\n    function _contains(\n        Set storage set,\n        bytes32 value\n    ) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _indexOf(\n        Set storage set,\n        bytes32 value\n    ) private view returns (uint256) {\n        unchecked {\n            return set._indexes[value] - 1;\n        }\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            status = true;\n        }\n    }\n\n    function _remove(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            unchecked {\n                bytes32 last = set._values[set._values.length - 1];\n\n                // move last value to now-vacant index\n\n                set._values[valueIndex - 1] = last;\n                set._indexes[last] = valueIndex;\n            }\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            status = true;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\nimport { IERC1155Internal } from './IERC1155Internal.sol';\n\n/**\n * @title ERC1155 interface\n * @dev see https://github.com/ethereum/EIPs/issues/1155\n */\ninterface IERC1155 is IERC1155Internal, IERC165 {\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external view returns (uint256);\n\n    /**\n     * @notice query the balances of given tokens held by given addresses\n     * @param accounts addresss to query\n     * @param ids tokens to query\n     * @return token balances\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool);\n\n    /**\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\n     * @param operator address whose approval status to update\n     * @param status whether operator should be considered approved\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to transfer\n     * @param data data payload\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC1155 interface needed by internal functions\n */\ninterface IERC1155Internal {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\n\n/**\n * @title ERC1155 transfer receiver interface\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @notice validate receipt of ERC1155 transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param id token ID received\n     * @param value quantity of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @notice validate receipt of ERC1155 batch transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param ids token IDs received\n     * @param values quantities of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 is IERC165Internal {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n */\ninterface IERC165Internal {\n\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165BaseInternal is IERC165BaseInternal {\n    /**\n     * @notice indicates whether an interface is already supported based on the interfaceId\n     * @param interfaceId id of interface to check\n     * @return bool indicating whether interface is supported\n     */\n    function _supportsInterface(\n        bytes4 interfaceId\n    ) internal view returns (bool) {\n        return ERC165BaseStorage.layout().supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @notice sets status of interface support\n     * @param interfaceId id of interface to set status for\n     * @param status boolean indicating whether interface will be set as supported\n     */\n    function _setSupportsInterface(bytes4 interfaceId, bool status) internal {\n        if (interfaceId == 0xffffffff) revert ERC165Base__InvalidInterfaceId();\n        ERC165BaseStorage.layout().supportedInterfaces[interfaceId] = status;\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC165BaseStorage {\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC165Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/IERC165BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165Internal } from '../../../interfaces/IERC165Internal.sol';\n\ninterface IERC165BaseInternal is IERC165Internal {\n    error ERC165Base__InvalidInterfaceId();\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155 } from '../../../interfaces/IERC1155.sol';\nimport { IERC1155Receiver } from '../../../interfaces/IERC1155Receiver.sol';\nimport { IERC1155Base } from './IERC1155Base.sol';\nimport { ERC1155BaseInternal, ERC1155BaseStorage } from './ERC1155BaseInternal.sol';\n\n/**\n * @title Base ERC1155 contract\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155Base is IERC1155Base, ERC1155BaseInternal {\n    /**\n     * @inheritdoc IERC1155\n     */\n    function balanceOf(\n        address account,\n        uint256 id\n    ) public view virtual returns (uint256) {\n        return _balanceOf(account, id);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual returns (uint256[] memory) {\n        if (accounts.length != ids.length)\n            revert ERC1155Base__ArrayLengthMismatch();\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        unchecked {\n            for (uint256 i; i < accounts.length; i++) {\n                if (accounts[i] == address(0))\n                    revert ERC1155Base__BalanceQueryZeroAddress();\n                batchBalances[i] = balances[ids[i]][accounts[i]];\n            }\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) public view virtual returns (bool) {\n        return ERC1155BaseStorage.layout().operatorApprovals[account][operator];\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function setApprovalForAll(address operator, bool status) public virtual {\n        if (msg.sender == operator) revert ERC1155Base__SelfApproval();\n        ERC1155BaseStorage.layout().operatorApprovals[msg.sender][\n            operator\n        ] = status;\n        emit ApprovalForAll(msg.sender, operator, status);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        if (from != msg.sender && !isApprovedForAll(from, msg.sender))\n            revert ERC1155Base__NotOwnerOrApproved();\n        _safeTransfer(msg.sender, from, to, id, amount, data);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        if (from != msg.sender && !isApprovedForAll(from, msg.sender))\n            revert ERC1155Base__NotOwnerOrApproved();\n        _safeTransferBatch(msg.sender, from, to, ids, amounts, data);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155Receiver } from '../../../interfaces/IERC1155Receiver.sol';\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { IERC1155BaseInternal } from './IERC1155BaseInternal.sol';\nimport { ERC1155BaseStorage } from './ERC1155BaseStorage.sol';\n\n/**\n * @title Base ERC1155 internal functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155BaseInternal is IERC1155BaseInternal {\n    using AddressUtils for address;\n\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function _balanceOf(\n        address account,\n        uint256 id\n    ) internal view virtual returns (uint256) {\n        if (account == address(0))\n            revert ERC1155Base__BalanceQueryZeroAddress();\n        return ERC1155BaseStorage.layout().balances[id][account];\n    }\n\n    /**\n     * @notice mint given quantity of tokens for given address\n     * @dev ERC1155Receiver implementation is not checked\n     * @param account beneficiary of minting\n     * @param id token ID\n     * @param amount quantity of tokens to mint\n     * @param data data payload\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__MintToZeroAddress();\n\n        _beforeTokenTransfer(\n            msg.sender,\n            address(0),\n            account,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        ERC1155BaseStorage.layout().balances[id][account] += amount;\n\n        emit TransferSingle(msg.sender, address(0), account, id, amount);\n    }\n\n    /**\n     * @notice mint given quantity of tokens for given address\n     * @param account beneficiary of minting\n     * @param id token ID\n     * @param amount quantity of tokens to mint\n     * @param data data payload\n     */\n    function _safeMint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _mint(account, id, amount, data);\n\n        _doSafeTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            account,\n            id,\n            amount,\n            data\n        );\n    }\n\n    /**\n     * @notice mint batch of tokens for given address\n     * @dev ERC1155Receiver implementation is not checked\n     * @param account beneficiary of minting\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to mint\n     * @param data data payload\n     */\n    function _mintBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__MintToZeroAddress();\n        if (ids.length != amounts.length)\n            revert ERC1155Base__ArrayLengthMismatch();\n\n        _beforeTokenTransfer(\n            msg.sender,\n            address(0),\n            account,\n            ids,\n            amounts,\n            data\n        );\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        for (uint256 i; i < ids.length; ) {\n            balances[ids[i]][account] += amounts[i];\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), account, ids, amounts);\n    }\n\n    /**\n     * @notice mint batch of tokens for given address\n     * @param account beneficiary of minting\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to mint\n     * @param data data payload\n     */\n    function _safeMintBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _mintBatch(account, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            account,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @notice burn given quantity of tokens held by given address\n     * @param account holder of tokens to burn\n     * @param id token ID\n     * @param amount quantity of tokens to burn\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__BurnFromZeroAddress();\n\n        _beforeTokenTransfer(\n            msg.sender,\n            account,\n            address(0),\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            ''\n        );\n\n        mapping(address => uint256) storage balances = ERC1155BaseStorage\n            .layout()\n            .balances[id];\n\n        unchecked {\n            if (amount > balances[account])\n                revert ERC1155Base__BurnExceedsBalance();\n            balances[account] -= amount;\n        }\n\n        emit TransferSingle(msg.sender, account, address(0), id, amount);\n    }\n\n    /**\n     * @notice burn given batch of tokens held by given address\n     * @param account holder of tokens to burn\n     * @param ids token IDs\n     * @param amounts quantities of tokens to burn\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__BurnFromZeroAddress();\n        if (ids.length != amounts.length)\n            revert ERC1155Base__ArrayLengthMismatch();\n\n        _beforeTokenTransfer(msg.sender, account, address(0), ids, amounts, '');\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        unchecked {\n            for (uint256 i; i < ids.length; i++) {\n                uint256 id = ids[i];\n                if (amounts[i] > balances[id][account])\n                    revert ERC1155Base__BurnExceedsBalance();\n                balances[id][account] -= amounts[i];\n            }\n        }\n\n        emit TransferBatch(msg.sender, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @notice transfer tokens between given addresses\n     * @dev ERC1155Receiver implementation is not checked\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _transfer(\n        address operator,\n        address sender,\n        address recipient,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        if (recipient == address(0))\n            revert ERC1155Base__TransferToZeroAddress();\n\n        _beforeTokenTransfer(\n            operator,\n            sender,\n            recipient,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        unchecked {\n            uint256 senderBalance = balances[id][sender];\n            if (amount > senderBalance)\n                revert ERC1155Base__TransferExceedsBalance();\n            balances[id][sender] = senderBalance - amount;\n        }\n\n        balances[id][recipient] += amount;\n\n        emit TransferSingle(operator, sender, recipient, id, amount);\n    }\n\n    /**\n     * @notice transfer tokens between given addresses\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _safeTransfer(\n        address operator,\n        address sender,\n        address recipient,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _transfer(operator, sender, recipient, id, amount, data);\n\n        _doSafeTransferAcceptanceCheck(\n            operator,\n            sender,\n            recipient,\n            id,\n            amount,\n            data\n        );\n    }\n\n    /**\n     * @notice transfer batch of tokens between given addresses\n     * @dev ERC1155Receiver implementation is not checked\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _transferBatch(\n        address operator,\n        address sender,\n        address recipient,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (recipient == address(0))\n            revert ERC1155Base__TransferToZeroAddress();\n        if (ids.length != amounts.length)\n            revert ERC1155Base__ArrayLengthMismatch();\n\n        _beforeTokenTransfer(operator, sender, recipient, ids, amounts, data);\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        for (uint256 i; i < ids.length; ) {\n            uint256 token = ids[i];\n            uint256 amount = amounts[i];\n\n            unchecked {\n                uint256 senderBalance = balances[token][sender];\n\n                if (amount > senderBalance)\n                    revert ERC1155Base__TransferExceedsBalance();\n\n                balances[token][sender] = senderBalance - amount;\n\n                i++;\n            }\n\n            // balance increase cannot be unchecked because ERC1155Base neither tracks nor validates a totalSupply\n            balances[token][recipient] += amount;\n        }\n\n        emit TransferBatch(operator, sender, recipient, ids, amounts);\n    }\n\n    /**\n     * @notice transfer batch of tokens between given addresses\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _safeTransferBatch(\n        address operator,\n        address sender,\n        address recipient,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _transferBatch(operator, sender, recipient, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            operator,\n            sender,\n            recipient,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @notice wrap given element in array of length 1\n     * @param element element to wrap\n     * @return singleton array\n     */\n    function _asSingletonArray(\n        uint256 element\n    ) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n        return array;\n    }\n\n    /**\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155Received(\n                    operator,\n                    from,\n                    id,\n                    amount,\n                    data\n                )\n            returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector)\n                    revert ERC1155Base__ERC1155ReceiverRejected();\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert ERC1155Base__ERC1155ReceiverNotImplemented();\n            }\n        }\n    }\n\n    /**\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155BatchReceived(\n                    operator,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                )\n            returns (bytes4 response) {\n                if (\n                    response != IERC1155Receiver.onERC1155BatchReceived.selector\n                ) revert ERC1155Base__ERC1155ReceiverRejected();\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert ERC1155Base__ERC1155ReceiverNotImplemented();\n            }\n        }\n    }\n\n    /**\n     * @notice ERC1155 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @dev called for both single and batch transfers\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC1155BaseStorage {\n    struct Layout {\n        mapping(uint256 => mapping(address => uint256)) balances;\n        mapping(address => mapping(address => bool)) operatorApprovals;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/IERC1155Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155 } from '../../../interfaces/IERC1155.sol';\nimport { IERC1155BaseInternal } from './IERC1155BaseInternal.sol';\n\n/**\n * @title ERC1155 base interface\n */\ninterface IERC1155Base is IERC1155BaseInternal, IERC1155 {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/IERC1155BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155Internal } from '../../../interfaces/IERC1155Internal.sol';\n\n/**\n * @title ERC1155 base interface\n */\ninterface IERC1155BaseInternal is IERC1155Internal {\n    error ERC1155Base__ArrayLengthMismatch();\n    error ERC1155Base__BalanceQueryZeroAddress();\n    error ERC1155Base__NotOwnerOrApproved();\n    error ERC1155Base__SelfApproval();\n    error ERC1155Base__BurnExceedsBalance();\n    error ERC1155Base__BurnFromZeroAddress();\n    error ERC1155Base__ERC1155ReceiverRejected();\n    error ERC1155Base__ERC1155ReceiverNotImplemented();\n    error ERC1155Base__MintToZeroAddress();\n    error ERC1155Base__TransferExceedsBalance();\n    error ERC1155Base__TransferToZeroAddress();\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/enumerable/ERC1155Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC1155BaseInternal } from '../base/ERC1155BaseInternal.sol';\nimport { IERC1155Enumerable } from './IERC1155Enumerable.sol';\nimport { ERC1155EnumerableInternal, ERC1155EnumerableStorage } from './ERC1155EnumerableInternal.sol';\n\n/**\n * @title ERC1155 implementation including enumerable and aggregate functions\n */\nabstract contract ERC1155Enumerable is\n    IERC1155Enumerable,\n    ERC1155EnumerableInternal\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply(id);\n    }\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function totalHolders(uint256 id) public view virtual returns (uint256) {\n        return _totalHolders(id);\n    }\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function accountsByToken(\n        uint256 id\n    ) public view virtual returns (address[] memory) {\n        return _accountsByToken(id);\n    }\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function tokensByAccount(\n        address account\n    ) public view virtual returns (uint256[] memory) {\n        return _tokensByAccount(account);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC1155BaseInternal, ERC1155BaseStorage } from '../base/ERC1155BaseInternal.sol';\nimport { ERC1155EnumerableStorage } from './ERC1155EnumerableStorage.sol';\n\n/**\n * @title ERC1155Enumerable internal functions\n */\nabstract contract ERC1155EnumerableInternal is ERC1155BaseInternal {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @notice query total minted supply of given token\n     * @param id token id to query\n     * @return token supply\n     */\n    function _totalSupply(uint256 id) internal view virtual returns (uint256) {\n        return ERC1155EnumerableStorage.layout().totalSupply[id];\n    }\n\n    /**\n     * @notice query total number of holders for given token\n     * @param id token id to query\n     * @return quantity of holders\n     */\n    function _totalHolders(uint256 id) internal view virtual returns (uint256) {\n        return ERC1155EnumerableStorage.layout().accountsByToken[id].length();\n    }\n\n    /**\n     * @notice query holders of given token\n     * @param id token id to query\n     * @return list of holder addresses\n     */\n    function _accountsByToken(\n        uint256 id\n    ) internal view virtual returns (address[] memory) {\n        EnumerableSet.AddressSet storage accounts = ERC1155EnumerableStorage\n            .layout()\n            .accountsByToken[id];\n\n        address[] memory addresses = new address[](accounts.length());\n\n        unchecked {\n            for (uint256 i; i < accounts.length(); i++) {\n                addresses[i] = accounts.at(i);\n            }\n        }\n\n        return addresses;\n    }\n\n    /**\n     * @notice query tokens held by given address\n     * @param account address to query\n     * @return list of token ids\n     */\n    function _tokensByAccount(\n        address account\n    ) internal view virtual returns (uint256[] memory) {\n        EnumerableSet.UintSet storage tokens = ERC1155EnumerableStorage\n            .layout()\n            .tokensByAccount[account];\n\n        uint256[] memory ids = new uint256[](tokens.length());\n\n        unchecked {\n            for (uint256 i; i < tokens.length(); i++) {\n                ids[i] = tokens.at(i);\n            }\n        }\n\n        return ids;\n    }\n\n    /**\n     * @notice ERC1155 hook: update aggregate values\n     * @inheritdoc ERC1155BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from != to) {\n            ERC1155EnumerableStorage.Layout storage l = ERC1155EnumerableStorage\n                .layout();\n            mapping(uint256 => EnumerableSet.AddressSet)\n                storage tokenAccounts = l.accountsByToken;\n            EnumerableSet.UintSet storage fromTokens = l.tokensByAccount[from];\n            EnumerableSet.UintSet storage toTokens = l.tokensByAccount[to];\n\n            for (uint256 i; i < ids.length; ) {\n                uint256 amount = amounts[i];\n\n                if (amount > 0) {\n                    uint256 id = ids[i];\n\n                    if (from == address(0)) {\n                        l.totalSupply[id] += amount;\n                    } else if (_balanceOf(from, id) == amount) {\n                        tokenAccounts[id].remove(from);\n                        fromTokens.remove(id);\n                    }\n\n                    if (to == address(0)) {\n                        l.totalSupply[id] -= amount;\n                    } else if (_balanceOf(to, id) == 0) {\n                        tokenAccounts[id].add(to);\n                        toTokens.add(id);\n                    }\n                }\n\n                unchecked {\n                    i++;\n                }\n            }\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\n\nlibrary ERC1155EnumerableStorage {\n    struct Layout {\n        mapping(uint256 => uint256) totalSupply;\n        mapping(uint256 => EnumerableSet.AddressSet) accountsByToken;\n        mapping(address => EnumerableSet.UintSet) tokensByAccount;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Enumerable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/enumerable/IERC1155Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155BaseInternal } from '../base/IERC1155BaseInternal.sol';\n\n/**\n * @title ERC1155 enumerable and aggregate function interface\n */\ninterface IERC1155Enumerable is IERC1155BaseInternal {\n    /**\n     * @notice query total minted supply of given token\n     * @param id token id to query\n     * @return token supply\n     */\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    /**\n     * @notice query total number of holders for given token\n     * @param id token id to query\n     * @return quantity of holders\n     */\n    function totalHolders(uint256 id) external view returns (uint256);\n\n    /**\n     * @notice query holders of given token\n     * @param id token id to query\n     * @return list of holder addresses\n     */\n    function accountsByToken(\n        uint256 id\n    ) external view returns (address[] memory);\n\n    /**\n     * @notice query tokens held by given address\n     * @param account address to query\n     * @return list of token ids\n     */\n    function tokensByAccount(\n        address account\n    ) external view returns (uint256[] memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from '../../../utils/UintUtils.sol';\nimport { IERC1155Metadata } from './IERC1155Metadata.sol';\nimport { ERC1155MetadataInternal } from './ERC1155MetadataInternal.sol';\nimport { ERC1155MetadataStorage } from './ERC1155MetadataStorage.sol';\n\n/**\n * @title ERC1155 metadata extensions\n */\nabstract contract ERC1155Metadata is IERC1155Metadata, ERC1155MetadataInternal {\n    using UintUtils for uint256;\n\n    /**\n     * @notice inheritdoc IERC1155Metadata\n     */\n    function uri(uint256 tokenId) public view virtual returns (string memory) {\n        ERC1155MetadataStorage.Layout storage l = ERC1155MetadataStorage\n            .layout();\n\n        string memory tokenIdURI = l.tokenURIs[tokenId];\n        string memory baseURI = l.baseURI;\n\n        if (bytes(baseURI).length == 0) {\n            return tokenIdURI;\n        } else if (bytes(tokenIdURI).length > 0) {\n            return string(abi.encodePacked(baseURI, tokenIdURI));\n        } else {\n            return string(abi.encodePacked(baseURI, tokenId.toString()));\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\nimport { ERC1155MetadataStorage } from './ERC1155MetadataStorage.sol';\n\n/**\n * @title ERC1155Metadata internal functions\n */\nabstract contract ERC1155MetadataInternal is IERC1155MetadataInternal {\n    /**\n     * @notice set base metadata URI\n     * @dev base URI is a non-standard feature adapted from the ERC721 specification\n     * @param baseURI base URI\n     */\n    function _setBaseURI(string memory baseURI) internal {\n        ERC1155MetadataStorage.layout().baseURI = baseURI;\n    }\n\n    /**\n     * @notice set per-token metadata URI\n     * @param tokenId token whose metadata URI to set\n     * @param tokenURI per-token URI\n     */\n    function _setTokenURI(uint256 tokenId, string memory tokenURI) internal {\n        ERC1155MetadataStorage.layout().tokenURIs[tokenId] = tokenURI;\n        emit URI(tokenURI, tokenId);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title ERC1155 metadata extensions\n */\nlibrary ERC1155MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Metadata');\n\n    struct Layout {\n        string baseURI;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\n\n/**\n * @title ERC1155Metadata interface\n */\ninterface IERC1155Metadata is IERC1155MetadataInternal {\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function uri(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC1155Metadata interface needed by internal functions\n */\ninterface IERC1155MetadataInternal {\n    event URI(string value, uint256 indexed tokenId);\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/ArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ArrayUtils {\n    /**\n     * @notice get minimum value in given array\n     * @param array array to search\n     * @return minimum value\n     */\n    function min(bytes32[] memory array) internal pure returns (bytes32) {\n        bytes32 minValue = bytes32(type(uint256).max);\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] < minValue) {\n                    minValue = array[i];\n                }\n            }\n        }\n\n        return minValue;\n    }\n\n    /**\n     * @notice get minimum value in given array\n     * @param array array to search\n     * @return minimum value\n     */\n    function min(address[] memory array) internal pure returns (address) {\n        address minValue = address(type(uint160).max);\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] < minValue) {\n                    minValue = array[i];\n                }\n            }\n        }\n\n        return minValue;\n    }\n\n    /**\n     * @notice get minimum value in given array\n     * @param array array to search\n     * @return minimum value\n     */\n    function min(uint256[] memory array) internal pure returns (uint256) {\n        uint256 minValue = type(uint256).max;\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] < minValue) {\n                    minValue = array[i];\n                }\n            }\n        }\n\n        return minValue;\n    }\n\n    /**\n     * @notice get maximum value in given array\n     * @param array array to search\n     * @return maximum value\n     */\n    function max(bytes32[] memory array) internal pure returns (bytes32) {\n        bytes32 maxValue = bytes32(0);\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] > maxValue) {\n                    maxValue = array[i];\n                }\n            }\n        }\n\n        return maxValue;\n    }\n\n    /**\n     * @notice get maximum value in given array\n     * @param array array to search\n     * @return maximum value\n     */\n    function max(address[] memory array) internal pure returns (address) {\n        address maxValue = address(0);\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] > maxValue) {\n                    maxValue = array[i];\n                }\n            }\n        }\n\n        return maxValue;\n    }\n\n    /**\n     * @notice get maximum value in given array\n     * @param array array to search\n     * @return maximum value\n     */\n    function max(uint256[] memory array) internal pure returns (uint256) {\n        uint256 maxValue = 0;\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] > maxValue) {\n                    maxValue = array[i];\n                }\n            }\n        }\n\n        return maxValue;\n    }\n}\n"
    },
    "@solidstate/contracts/utils/IMulticall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Interface for the Multicall utility contract\n */\ninterface IMulticall {\n    /**\n     * @notice batch function calls to the contract and return the results of each\n     * @param data array of function call data payloads\n     * @return results array of function call results\n     */\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n}\n"
    },
    "@solidstate/contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IMulticall } from './IMulticall.sol';\n\n/**\n * @title Utility contract for supporting processing of multiple function calls in a single transaction\n */\nabstract contract Multicall is IMulticall {\n    /**\n     * @inheritdoc IMulticall\n     */\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n\n        unchecked {\n            for (uint256 i; i < data.length; i++) {\n                (bool success, bytes memory returndata) = address(this)\n                    .delegatecall(data[i]);\n\n                if (success) {\n                    results[i] = returndata;\n                } else {\n                    assembly {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        }\n\n        return results;\n    }\n}\n"
    },
    "@solidstate/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ReentrancyGuardStorage } from './ReentrancyGuardStorage.sol';\n\n/**\n * @title Utility contract for preventing reentrancy attacks\n */\nabstract contract ReentrancyGuard {\n    error ReentrancyGuard__ReentrantCall();\n\n    modifier nonReentrant() {\n        ReentrancyGuardStorage.Layout storage l = ReentrancyGuardStorage\n            .layout();\n        if (l.status == 2) revert ReentrancyGuard__ReentrantCall();\n        l.status = 2;\n        _;\n        l.status = 1;\n    }\n}\n"
    },
    "@solidstate/contracts/utils/ReentrancyGuardStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ReentrancyGuardStorage {\n    struct Layout {\n        uint256 status;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ReentrancyGuard');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/arcadiaDiamonds/inventory/InventoryInternal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { ReentrancyGuard } from \"@solidstate/contracts/utils/ReentrancyGuard.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { AddressUtils } from \"@solidstate/contracts/utils/AddressUtils.sol\";\nimport { ArrayUtils } from \"@solidstate/contracts/utils/ArrayUtils.sol\";\nimport { EnumerableSet } from \"@solidstate/contracts/data/EnumerableSet.sol\";\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { InventoryStorage } from \"./InventoryStorage.sol\";\nimport { IERC1155 } from \"@solidstate/contracts/interfaces/IERC1155.sol\";\n\ncontract InventoryInternal is\n    ReentrancyGuard,\n    RolesInternal\n{\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using AddressUtils for address;\n\n    error Inventory_InvalidERC1155Contract();\n    error Inventory_UnequippingPermanentSlot();\n    error Inventory_InvalidSlotId();\n    error Inventory_ItemDoesNotHaveSlotAssigned();\n    error Inventory_InsufficientItemBalance();\n    error Inventory_UnequippingEmptySlot();\n    error Inventory_UnequippingBaseSlot();\n    error Inventory_SlotNotSpecified();\n    error Inventory_ItemNotSpecified();\n    error Inventory_NotArcadianOwner();\n    error Inventory_ArcadianNotUnique();\n    error Inventory_NotAllBaseSlotsEquipped();\n    error Inventory_InputDataMismatch();\n    error Inventory_ItemAlreadyEquippedInSlot();\n    error Inventory_CouponNeededToModifyBaseSlots();\n    error Inventory_NonBaseSlot();\n\n    event ItemsAllowedInSlotUpdated(\n        address indexed by,\n        InventoryStorage.Item[] items\n    );\n\n    event ItemsEquipped(\n        address indexed by,\n        uint indexed arcadianId,\n        uint[] slots\n    );\n\n    event ItemsUnequipped(\n        address indexed by,\n        uint indexed arcadianId,\n        uint[] slots\n    );\n\n    event SlotCreated(\n        address indexed by,\n        uint slotId,\n        bool permanent,\n        bool isBase\n    );\n\n    event BaseModifierCouponAdded(\n        address indexed by,\n        address indexed to,\n        uint[] slotsIds,\n        uint[] amounts\n    );\n\n    event BaseModifierCouponConsumed(\n        address indexed account,\n        uint[] slotsIds\n    );\n\n    // Helper structs only used in view functions to ease data reading from web3\n    struct ItemInSlot {\n        uint slotId;\n        address erc721Contract;\n        uint itemId;\n    }\n    struct BaseModifierCoupon {\n        uint slotId;\n        uint amount;\n    }\n\n    modifier onlyValidSlot(uint slotId) {\n        if (slotId == 0 || slotId > InventoryStorage.layout().numSlots) revert Inventory_InvalidSlotId();\n        _;\n    }\n\n    modifier onlyArcadianOwner(uint arcadianId) {\n        IERC721 arcadiansContract = IERC721(address(this));\n        if (msg.sender != arcadiansContract.ownerOf(arcadianId)) revert Inventory_NotArcadianOwner();\n        _;\n    }\n\n    function _numSlots() internal view returns (uint) {\n        return InventoryStorage.layout().numSlots;\n    }\n\n    function _transferRequired(InventoryStorage.Slot storage slot) internal view returns (bool required) {\n        required = !slot.isBase && !slot.permanent;\n    }\n\n    function _equip(\n        uint arcadianId,\n        InventoryStorage.Item[] calldata items,\n        bool freeBaseModifier\n    ) internal onlyArcadianOwner(arcadianId) {\n\n        if (items.length == 0) \n            revert Inventory_ItemNotSpecified();\n\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        uint numBaseSlotsModified;\n        uint[] memory slotsIds = new uint[](items.length);\n        for (uint i = 0; i < items.length; i++) {\n            uint slotId = _equipSingleSlot(arcadianId, items[i], freeBaseModifier);\n            if (inventorySL.slots[slotId].isBase) {\n                numBaseSlotsModified++;\n            }\n            slotsIds[i] = slotId;\n        }\n\n        if (!_baseSlotsEquipped(arcadianId)) \n            revert Inventory_NotAllBaseSlotsEquipped();\n\n        if (numBaseSlotsModified > 0) {\n            if (!_hashBaseItemsUnchecked(arcadianId))\n                revert Inventory_ArcadianNotUnique();\n            \n            if (!freeBaseModifier) {\n                uint[] memory baseSlotsModified = new uint[](numBaseSlotsModified);\n                uint counter;\n                for (uint i = 0; i < items.length; i++) {\n                    uint slotId = inventorySL.itemSlot[items[i].erc721Contract][items[i].id];\n                    if (inventorySL.slots[slotId].isBase) {\n                        baseSlotsModified[counter] = slotId;\n                        counter++;\n                    }\n                }\n                emit BaseModifierCouponConsumed(msg.sender, baseSlotsModified);\n            }\n        }\n\n        emit ItemsEquipped(msg.sender, arcadianId, slotsIds);\n    }\n\n    function _equipSingleSlot(\n        uint arcadianId,\n        InventoryStorage.Item calldata item,\n        bool freeBaseModifier\n    ) internal returns (uint slotId) {\n\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        slotId = inventorySL.itemSlot[item.erc721Contract][item.id];\n        \n        if (slotId == 0 || slotId > InventoryStorage.layout().numSlots) \n            revert Inventory_ItemDoesNotHaveSlotAssigned();\n        \n        if (!freeBaseModifier && inventorySL.slots[slotId].isBase) {\n            if (inventorySL.baseModifierCoupon[msg.sender][slotId] < 1)\n                revert Inventory_CouponNeededToModifyBaseSlots();\n\n            inventorySL.baseModifierCoupon[msg.sender][slotId]--;\n        }\n\n        InventoryStorage.Item storage existingItem = inventorySL.equippedItems[arcadianId][slotId];\n        if (inventorySL.slots[slotId].permanent && existingItem.erc721Contract != address(0)) \n            revert Inventory_UnequippingPermanentSlot();\n        if (existingItem.erc721Contract == item.erc721Contract && existingItem.id == item.id)\n            revert Inventory_ItemAlreadyEquippedInSlot();\n\n        if (inventorySL.equippedItems[arcadianId][slotId].erc721Contract != address(0))\n            _unequipUnchecked(arcadianId, slotId);\n\n        bool requiresTransfer = inventorySL.requiresTransfer[item.erc721Contract][item.id];\n        if (requiresTransfer) {\n            IERC1155 erc1155Contract = IERC1155(item.erc721Contract);\n            if (erc1155Contract.balanceOf(msg.sender, item.id) < 1)\n                revert Inventory_InsufficientItemBalance();\n\n            erc1155Contract.safeTransferFrom(\n                msg.sender,\n                address(this),\n                item.id,\n                1,\n                ''\n            );\n        }\n\n        inventorySL.equippedItems[arcadianId][slotId] = item;\n    }\n\n    function _baseSlotsEquipped(uint arcadianId) internal view returns (bool) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        uint numSlots = inventorySL.numSlots;\n        for (uint i = 0; i < numSlots; i++) {\n            uint slotId = i + 1;\n            if (!inventorySL.slots[slotId].isBase)\n                continue;\n            if (inventorySL.slots[slotId].isBase && inventorySL.equippedItems[arcadianId][slotId].erc721Contract == address(0)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _unequipUnchecked(\n        uint arcadianId,\n        uint slotId\n    ) internal {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        InventoryStorage.Item storage existingItem = inventorySL.equippedItems[arcadianId][slotId];\n\n        bool requiresTransfer = inventorySL.requiresTransfer[existingItem.erc721Contract][existingItem.id];\n        if (requiresTransfer) {\n            IERC1155 erc1155Contract = IERC1155(existingItem.erc721Contract);\n            erc1155Contract.safeTransferFrom(\n                address(this),\n                msg.sender,\n                existingItem.id,\n                1,\n                ''\n            );\n        }\n        delete inventorySL.equippedItems[arcadianId][slotId];\n    }\n\n    function _unequip(\n        uint arcadianId,\n        uint[] calldata slotIds\n    ) internal onlyArcadianOwner(arcadianId) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        if (slotIds.length == 0) \n            revert Inventory_SlotNotSpecified();\n\n        for (uint i = 0; i < slotIds.length; i++) {\n            if (inventorySL.slots[slotIds[i]].permanent) \n                revert Inventory_UnequippingPermanentSlot();\n\n            if (inventorySL.equippedItems[arcadianId][slotIds[i]].erc721Contract == address(0)) \n                revert Inventory_UnequippingEmptySlot();\n            \n            if (inventorySL.slots[slotIds[i]].isBase)\n                revert Inventory_UnequippingBaseSlot();\n\n            _unequipUnchecked(arcadianId, slotIds[i]);\n        }\n\n        _hashBaseItemsUnchecked(arcadianId);\n\n        emit ItemsUnequipped(\n            msg.sender,\n            arcadianId,\n            slotIds\n        );\n    }\n\n    function _equipped(\n        uint arcadianId,\n        uint slotId\n    ) internal view returns (ItemInSlot memory) {\n        InventoryStorage.Item storage item = InventoryStorage.layout().equippedItems[arcadianId][slotId];\n        return ItemInSlot(slotId, item.erc721Contract, item.id);\n    }\n\n    function _equippedBatch(\n        uint arcadianId,\n        uint[] calldata slotIds\n    ) internal view returns (ItemInSlot[] memory equippedSlots) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        equippedSlots = new ItemInSlot[](slotIds.length);\n        for (uint i = 0; i < slotIds.length; i++) {\n            InventoryStorage.Item storage equippedItem = inventorySL.equippedItems[arcadianId][slotIds[i]];\n            equippedSlots[i] = ItemInSlot(slotIds[i], equippedItem.erc721Contract, equippedItem.id);\n        }\n    }\n\n    function _equippedAll(\n        uint arcadianId\n    ) internal view returns (ItemInSlot[] memory equippedSlots) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        uint numSlots = inventorySL.numSlots;\n        equippedSlots = new ItemInSlot[](numSlots);\n        for (uint i = 0; i < numSlots; i++) {\n            uint slot = i + 1;\n            InventoryStorage.Item storage equippedItem = inventorySL.equippedItems[arcadianId][slot];\n            equippedSlots[i] = ItemInSlot(slot, equippedItem.erc721Contract, equippedItem.id);\n        }\n    }\n\n    function _isArcadianUnique(\n        uint arcadianId,\n        InventoryStorage.Item[] calldata items\n    ) internal view returns (bool) {\n\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        uint numSlots = inventorySL.numSlots;\n\n        bytes memory encodedItems;\n        for (uint i = 0; i < numSlots; i++) {\n            uint slotId = i + 1;\n            if (!inventorySL.slots[slotId].isBase)\n                continue;\n\n            InventoryStorage.Item memory item;\n            for (uint j = 0; j < items.length; j++) {\n                if (_allowedSlot(items[j]) == slotId) {\n                    item = items[j];\n                    break;\n                }\n            }\n            if (item.erc721Contract == address(0)) {\n                if (inventorySL.equippedItems[arcadianId][slotId].erc721Contract != address(0)) {\n                    item = inventorySL.equippedItems[arcadianId][slotId];\n                } else {\n                    revert Inventory_NotAllBaseSlotsEquipped();\n                }\n            }\n            \n            encodedItems = abi.encodePacked(encodedItems, slotId, item.erc721Contract, item.id);\n        }\n\n        return !inventorySL.baseItemsHashes.contains(keccak256(encodedItems));\n    }\n\n    function _hashBaseItemsUnchecked(\n        uint arcadianId\n    ) internal returns (bool isUnique) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        bytes memory encodedItems;\n        uint numSlots = inventorySL.numSlots;\n\n        for (uint i = 0; i < numSlots; i++) {\n            uint slotId = i + 1;\n            if (!inventorySL.slots[slotId].isBase)\n                continue;\n            InventoryStorage.Item storage equippedItem = inventorySL.equippedItems[arcadianId][slotId];\n            encodedItems = abi.encodePacked(encodedItems, slotId, equippedItem.erc721Contract, equippedItem.id);\n        }\n\n        bytes32 baseItemsHash = keccak256(encodedItems);\n        isUnique = !inventorySL.baseItemsHashes.contains(baseItemsHash);\n        inventorySL.baseItemsHashes.remove(inventorySL.arcadianToBaseItemHash[arcadianId]);\n        inventorySL.baseItemsHashes.add(baseItemsHash);\n        inventorySL.arcadianToBaseItemHash[arcadianId] = baseItemsHash;\n    }\n\n    function _createSlot(\n        bool permanent,\n        bool isBase,\n        InventoryStorage.Item[] calldata allowedItems\n    ) internal {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        // slots are 1-index\n        inventorySL.numSlots += 1;\n        uint newSlot = inventorySL.numSlots;\n        inventorySL.slots[newSlot].permanent = permanent;\n        inventorySL.slots[newSlot].isBase = isBase;\n        inventorySL.slots[newSlot].id = newSlot;\n\n        if (allowedItems.length > 0) {\n            _allowItemsInSlot(newSlot, allowedItems);\n        }\n\n        emit SlotCreated(msg.sender, newSlot, permanent, isBase);\n    }\n\n    function _setSlotBase(\n        uint slotId,\n        bool isBase\n    ) internal onlyValidSlot(slotId) {\n        InventoryStorage.layout().slots[slotId].isBase = isBase;\n    }\n\n    function _setSlotPermanent(\n        uint slotId,\n        bool permanent\n    ) internal onlyValidSlot(slotId) {\n        InventoryStorage.layout().slots[slotId].permanent = permanent;\n    }\n\n    function _addBaseModifierCoupons(\n        address account,\n        uint[] calldata slotIds,\n        uint[] calldata amounts\n    ) internal {\n        if (slotIds.length != amounts.length)\n            revert Inventory_InputDataMismatch();\n\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        uint numSlots = inventorySL.numSlots;\n\n        for (uint i = 0; i < slotIds.length; i++) {\n            if (slotIds[i] == 0 && slotIds[i] > numSlots) \n                revert Inventory_InvalidSlotId();\n            if (!inventorySL.slots[slotIds[i]].isBase) {\n                revert Inventory_NonBaseSlot();\n            }\n            InventoryStorage.layout().baseModifierCoupon[account][slotIds[i]] += amounts[i];\n        }\n\n        emit BaseModifierCouponAdded(msg.sender, account, slotIds, amounts);\n    }\n\n    function _getbaseModifierCoupon(address account, uint slotId) internal view onlyValidSlot(slotId) returns (uint) {\n        if (!InventoryStorage.layout().slots[slotId].isBase) {\n            revert Inventory_NonBaseSlot();\n        }\n        return InventoryStorage.layout().baseModifierCoupon[account][slotId];\n    }\n\n    function _getBaseModifierCouponAll(address account) internal view returns (BaseModifierCoupon[] memory) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        uint numSlots = inventorySL.numSlots;\n\n        uint baseCounter;\n        for (uint i = 0; i < numSlots; i++) {\n            uint slotId = i + 1;\n            if (inventorySL.slots[slotId].isBase) {\n                baseCounter++;\n            }\n        }\n\n        BaseModifierCoupon[] memory coupons = new BaseModifierCoupon[](baseCounter);\n        uint counter;\n        for (uint i = 0; i < numSlots; i++) {\n            uint slotId = i + 1;\n            if (!inventorySL.slots[slotId].isBase)\n                continue;\n            coupons[counter].slotId = slotId;\n            coupons[counter].amount = inventorySL.baseModifierCoupon[account][slotId];\n            counter++;\n        }\n        return coupons;\n    }\n\n    function _setItemsTransferRequired(\n        InventoryStorage.Item[] calldata items,\n        bool[] calldata requiresTransfer\n    ) internal {\n        if (items.length != requiresTransfer.length)\n            revert Inventory_InputDataMismatch();\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        for (uint i = 0; i < items.length; i++) {\n            inventorySL.requiresTransfer[items[i].erc721Contract][items[i].id] = requiresTransfer[i];\n        }\n    }\n    \n    function _allowItemsInSlot(\n        uint slotId,\n        InventoryStorage.Item[] calldata items\n    ) internal virtual onlyValidSlot(slotId) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        for (uint i = 0; i < items.length; i++) {\n            if (!items[i].erc721Contract.isContract()) \n                revert Inventory_InvalidERC1155Contract();\n\n            inventorySL.itemSlot[items[i].erc721Contract][items[i].id] = slotId;\n        }\n\n        emit ItemsAllowedInSlotUpdated(msg.sender, items);\n    }\n\n    function _disallowItems(\n        InventoryStorage.Item[] calldata items\n    ) internal virtual {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        for (uint i = 0; i < items.length; i++) {\n            delete inventorySL.itemSlot[items[i].erc721Contract][items[i].id];\n        }\n\n        emit ItemsAllowedInSlotUpdated(msg.sender, items);\n    }\n\n    function _allowedSlot(InventoryStorage.Item calldata item) internal view returns (uint) {\n        return InventoryStorage.layout().itemSlot[item.erc721Contract][item.id];\n    }\n\n    function _slot(uint slotId) internal view returns (InventoryStorage.Slot storage slot) {\n        return InventoryStorage.layout().slots[slotId];\n    }\n\n    function _slotsAll() internal view returns (InventoryStorage.Slot[] memory slotsAll) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        \n        uint numSlots = inventorySL.numSlots;\n        slotsAll = new InventoryStorage.Slot[](numSlots);\n\n        for (uint i = 0; i < numSlots; i++) {\n            uint slotId = i + 1;\n            slotsAll[i] = inventorySL.slots[slotId];\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/inventory/InventoryStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport {ReentrancyGuard} from \"@solidstate/contracts/utils/ReentrancyGuard.sol\";\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { EnumerableSet } from \"@solidstate/contracts/data/EnumerableSet.sol\";\n\n/**\nLibInventory defines the storage structure used by the Inventory contract as a facet for an EIP-2535 Diamond\nproxy.\n */\nlibrary InventoryStorage {\n    bytes32 constant INVENTORY_STORAGE_POSITION =\n        keccak256(\"inventory.storage.position\");\n\n    uint constant ERC721_ITEM_TYPE = 721;\n    uint constant ERC1155_ITEM_TYPE = 1155;\n\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // Holds the information needed to identify an ERC1155 item\n    struct Item {\n        address erc721Contract;\n        uint id;\n    }\n\n    // Holds the general information about a slot\n    struct Slot {\n        uint id;\n        bool permanent;\n        bool isBase;\n    }\n\n    struct Layout {\n        uint numSlots;\n\n        // Slot id => Slot\n        mapping(uint => Slot) slots;\n\n        // arcadian id => slot id => Items equipped\n        mapping(uint => mapping(uint => Item)) equippedItems;\n\n        // item address => item id => allowed slot id\n        mapping(address => mapping(uint => uint)) itemSlot;\n        \n        // item address => item id => equip items requires transfer\n        mapping(address => mapping(uint => bool)) requiresTransfer;\n\n        // List of all the existent hashes\n        EnumerableSet.Bytes32Set baseItemsHashes;\n        // arcadian id => base items hash\n        mapping(uint => bytes32) arcadianToBaseItemHash;\n\n        // account => slotId => number of coupons to modify the base traits\n        mapping(address => mapping(uint => uint)) baseModifierCoupon;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage istore)\n    {\n        bytes32 position = INVENTORY_STORAGE_POSITION;\n        assembly {\n            istore.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/items/ItemsFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { ERC1155Base } from \"@solidstate/contracts/token/ERC1155/base/ERC1155Base.sol\";\nimport { ERC1155BaseInternal } from \"@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol\";\nimport { ERC1155Enumerable } from \"@solidstate/contracts/token/ERC1155/enumerable/ERC1155Enumerable.sol\";\nimport { ERC1155EnumerableInternal } from \"@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableInternal.sol\";\nimport { ERC1155Metadata } from \"@solidstate/contracts/token/ERC1155/metadata/ERC1155Metadata.sol\";\nimport { ReentrancyGuard } from \"@solidstate/contracts/utils/ReentrancyGuard.sol\";\nimport { ItemsInternal } from \"./ItemsInternal.sol\";\nimport { ItemsStorage } from \"./ItemsStorage.sol\";\nimport { Multicall } from \"@solidstate/contracts/utils/Multicall.sol\";\nimport { IERC1155 } from '@solidstate/contracts/interfaces/IERC1155.sol';\n\n/**\n * @title ItemsFacet\n * @dev This contract handles the creation and management of items\n * It uses ERC1155 tokens to represent items and provides methods to mint new items,\n * claim items via Merkle tree or a whitelist, and set the base and URIs for\n * the items. It also uses the ReentrancyGuard and Multicall contracts for security\n * and gas efficiency.\n */\ncontract ItemsFacet is ERC1155Base, ERC1155Enumerable, ERC1155Metadata, ReentrancyGuard, ItemsInternal, Multicall {\n    \n    /**\n     * @notice Claims an item if present in the Merkle tree\n     * @param itemId The ID of the item to claim\n     * @param amount The amount of the item to claim\n     * @param proof The Merkle proof for the item\n     */\n    function claimMerkle(uint itemId, uint amount, bytes32[] calldata proof)\n        public nonReentrant\n    {\n        _claimMerkle(msg.sender, itemId, amount, proof);\n    }\n\n    /**\n     * @notice Claims items if present in the Merkle tree\n     * @param itemsIds The IDs of the items to claim\n     * @param amounts The amounts of the items to claim\n     * @param proofs The Merkle proofs for the items\n     */\n    function claimMerkleBatch(uint256[] calldata itemsIds, uint[] calldata amounts, bytes32[][] calldata proofs) external nonReentrant {\n        _claimMerkleBatch(msg.sender, itemsIds, amounts, proofs);\n    }\n\n    /**\n     * @notice Claims items from a whitelist\n     * @param itemIds The IDs of the items to claim\n     * @param amounts The amounts of the items to claim\n     */\n    function claimWhitelist(uint[] calldata itemIds, uint[] calldata amounts) external {\n        _claimWhitelist(itemIds, amounts);\n    }\n\n    /**\n     * @notice Amount claimed by an address of a specific item\n     * @param account the account to query\n     * @param itemId the item id to query\n     * @return amount returns the claimed amount given an account and an item id\n     */\n    function claimedAmount(address account, uint itemId) external view returns (uint amount) {\n        return _claimedAmount(account, itemId);\n    }\n\n    /**\n     * @notice Mints a new item. Only minter role account can mint\n     * @param to The address to mint the item to\n     * @param itemId The ID of the item to mint\n     * @param amount The item amount to be minted\n     */\n    function mint(address to, uint256 itemId, uint256 amount)\n        public onlyManager\n    {\n        _mint(to, itemId, amount);\n    }\n\n    /**\n     * @notice Mint a batch of items to a specific address. Only minter role account can mint\n     * @param to The address to receive the minted items\n     * @param itemIds An array of items IDs to be minted\n     * @param amounts The items amounts to be minted\n     */\n    function mintBatch(address to, uint256[] calldata itemIds, uint256[] calldata amounts)\n        public onlyManager\n    {\n        _mintBatch(to, itemIds, amounts);\n    }\n\n    /**\n     * @notice Set the base URI for all items metadata\n     * @dev Only the manager role can call this function\n     * @param baseURI The new base URI\n     */\n    function setBaseURI(string calldata baseURI) external onlyManager {\n        _setBaseURI(baseURI);\n    }\n\n    /**\n     * @notice Set the base URI for all items metadata\n     * @dev Only the manager role can call this function\n     * @param newBaseURI The new base URI\n     * @param migrate Should migrate to IPFS\n     */\n    function migrateToIPFS(string calldata newBaseURI, bool migrate) external onlyManager {\n        _migrateToIPFS(newBaseURI, migrate);\n    }\n\n    /**\n     * @dev Returns the current inventory address\n     * @return The address of the inventory contract\n     */\n    function getInventoryAddress() external view returns (address) {\n        return _getInventoryAddress();\n    }\n\n    /**\n     * @dev Sets the inventory address\n     * @param inventoryAddress The new address of the inventory contract\n     */\n    function setInventoryAddress(address inventoryAddress) external onlyManager {\n        _setInventoryAddress(inventoryAddress);\n    }\n\n    /**\n     * @notice Override ERC1155Metadata\n     */\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        if (ItemsStorage.layout().isMigratedToIPFS) {\n            return string.concat(super.uri(tokenId), \".json\");\n        } else {\n            return super.uri(tokenId);\n        }\n    }\n\n    /**\n     * @notice Set the URI for a specific item ID\n     * @dev Only the manager role can call this function\n     * @param tokenId The ID of the item to set the URI for\n     * @param tokenURI The new item URI\n     */\n    function setTokenURI(uint tokenId, string calldata tokenURI) external onlyManager {\n        _setTokenURI(tokenId, tokenURI);\n    }\n\n\n    // overrides\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public override (ERC1155Base) {\n        // Add red carpet logic for the inventory\n        if (from != msg.sender && !isApprovedForAll(from, msg.sender) && _getInventoryAddress() != msg.sender )\n            revert ERC1155Base__NotOwnerOrApproved();\n        _safeTransfer(msg.sender, from, to, id, amount, data);\n    }\n\n    function supportsInterface(bytes4 _interface) external pure returns (bool) {\n        return type(IERC1155).interfaceId == _interface;\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n        override (ERC1155BaseInternal, ERC1155EnumerableInternal, ItemsInternal)\n    {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n}"
    },
    "contracts/arcadiaDiamonds/items/ItemsInit.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { ERC1155BaseInternal } from \"@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol\";\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { ItemsInternal } from \"./ItemsInternal.sol\";\nimport { InventoryInternal } from \"../inventory/InventoryInternal.sol\";\nimport { ERC165BaseInternal } from '@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol';\nimport { IERC1155 } from '@solidstate/contracts/interfaces/IERC1155.sol';\n\ncontract ItemsInit is RolesInternal, ItemsInternal, InventoryInternal, ERC165BaseInternal {    \n    function init(bytes32 merkleRoot, string calldata baseUri, address inventoryAddress) external {\n\n        _setSupportsInterface(type(IERC1155).interfaceId, true);\n\n        _updateMerkleRoot(merkleRoot);\n\n        _initRoles();\n\n        _setBaseURI(baseUri);\n        _setInventoryAddress(inventoryAddress);\n    }\n}\n"
    },
    "contracts/arcadiaDiamonds/items/ItemsInternal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { ERC1155BaseInternal } from \"@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol\";\nimport { ERC1155EnumerableInternal } from \"@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableInternal.sol\";\nimport { ERC1155MetadataInternal } from \"@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataInternal.sol\";\nimport { ItemsStorage } from \"./ItemsStorage.sol\";\nimport { MerkleInternal } from \"../merkle/MerkleInternal.sol\";\nimport { WhitelistInternal } from \"../whitelist/WhitelistInternal.sol\";\nimport { ArrayUtils } from \"@solidstate/contracts/utils/ArrayUtils.sol\";\nimport { WhitelistStorage } from \"../whitelist/WhitelistStorage.sol\";\n\ncontract ItemsInternal is MerkleInternal, WhitelistInternal, ERC1155BaseInternal, ERC1155EnumerableInternal, ERC1155MetadataInternal {\n\n    error Items_InputsLengthMistatch();\n    error Items_InvalidItemId();\n    error Items_ItemsBasicStatusAlreadyUpdated();\n    error Items_MintingNonBasicItem();\n    error Items_MaximumItemMintsExceeded();\n\n    event ItemClaimedMerkle(address indexed to, uint256 indexed itemId, uint amount);\n\n    using ArrayUtils for uint[];\n\n    function _claimMerkle(address to, uint itemId, uint amount, bytes32[] memory proof)\n        internal\n    {\n        if (itemId < 1) revert Items_InvalidItemId();\n\n        ItemsStorage.Layout storage itemsSL = ItemsStorage.layout();\n\n        bytes memory leaf = abi.encode(to, itemId, amount);\n        _consumeLeaf(proof, leaf);\n\n        ERC1155BaseInternal._mint(to, itemId, amount, \"\");\n\n        itemsSL.amountClaimed[to][itemId] += amount;\n        emit ItemClaimedMerkle(to, itemId, amount);\n    }\n\n    function _claimMerkleBatch(address to, uint256[] calldata itemIds, uint[] calldata amounts, bytes32[][] calldata proofs) \n        internal\n    {\n        if (itemIds.length != amounts.length) \n            revert Items_InputsLengthMistatch();\n        \n        for (uint256 i = 0; i < itemIds.length; i++) {\n            _claimMerkle(to, itemIds[i], amounts[i], proofs[i]);\n        }\n    }\n    \n    function _claimWhitelist(uint[] calldata itemIds, uint[] calldata amounts) internal {\n        if (itemIds.length != amounts.length) \n            revert Items_InputsLengthMistatch();\n\n\n        uint totalAmount = 0;\n        for (uint i = 0; i < itemIds.length; i++) {\n            if (itemIds[i] < 1) \n                revert Items_InvalidItemId();\n\n            ERC1155BaseInternal._mint(msg.sender, itemIds[i], amounts[i], \"\");\n            totalAmount += amounts[i];\n        }\n        _consumeWhitelist(WhitelistStorage.PoolId.Guaranteed, msg.sender, totalAmount);\n    }\n\n    function _claimedAmount(address account, uint itemId) internal view returns (uint) {\n        return ItemsStorage.layout().amountClaimed[account][itemId];\n    }\n\n    function _mint(address to, uint256 itemId, uint256 amount)\n        internal\n    {\n        if (itemId < 1) revert Items_InvalidItemId();\n\n        ERC1155BaseInternal._mint(to, itemId, amount, \"\");\n    }\n\n    function _mintBatch(address to, uint256[] calldata itemsIds, uint256[] calldata amounts)\n        internal\n    {\n        if (itemsIds.min() < 1) revert Items_InvalidItemId();\n\n        ERC1155BaseInternal._mintBatch(to, itemsIds, amounts, \"\");\n    }\n\n    function _migrateToIPFS(string calldata newBaseURI, bool migrate) internal {\n        _setBaseURI(newBaseURI);\n        ItemsStorage.layout().isMigratedToIPFS = migrate;\n    }\n\n    function _getInventoryAddress() internal view returns (address) {\n        return ItemsStorage.layout().inventoryAddress;\n    }\n\n    function _setInventoryAddress(address inventoryAddress) internal {\n        ItemsStorage.layout().inventoryAddress = inventoryAddress;\n    }\n\n    // overrides\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n        override (ERC1155BaseInternal, ERC1155EnumerableInternal)\n    {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n}"
    },
    "contracts/arcadiaDiamonds/items/ItemsStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nlibrary ItemsStorage {\n\n    bytes32 constant ITEMS_STORAGE_POSITION =\n        keccak256(\"items.storage.position\");\n\n    struct Layout {\n        // wallet address => token id => is claimed \n        mapping(address => mapping(uint => uint)) amountClaimed;\n        bool isMigratedToIPFS;\n\n        // token id => is basic item\n        mapping(uint => bool) isBasicItem;\n        uint[] basicItemsIds;\n        address inventoryAddress;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = ITEMS_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/merkle/MerkleInternal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { MerkleProof } from \"@solidstate/contracts/cryptography/MerkleProof.sol\";\nimport { MerkleStorage } from \"./MerkleStorage.sol\";\nimport { RolesInternal } from \"./../roles/RolesInternal.sol\";\n\ncontract MerkleInternal is RolesInternal {\n\n    error Merkle_AlreadyClaimed();\n    error Merkle_InvalidClaimAmount();\n    error Merkle_NotIncludedInMerkleTree();\n    error Merkle_ClaimInactive();\n    error Merkle_ClaimStateAlreadyUpdated();\n\n    function _merkleRoot() internal view returns (bytes32) {\n        return MerkleStorage.layout().merkleRoot;\n    }\n\n    function _updateMerkleRoot(bytes32 newMerkleRoot) internal {\n        MerkleStorage.layout().merkleRoot = newMerkleRoot;\n    }\n\n    function _isMerkleClaimActive() view internal returns (bool) {\n        return !MerkleStorage.layout().claimInactive;\n    }\n\n    function _setMerkleClaimActive() internal {\n        MerkleStorage.Layout storage merkleSL = MerkleStorage.layout();\n\n        if (!merkleSL.claimInactive) revert Merkle_ClaimStateAlreadyUpdated();\n        \n        merkleSL.claimInactive = false;\n    }\n\n    function _setMerkleClaimInactive() internal {\n        MerkleStorage.Layout storage merkleSL = MerkleStorage.layout();\n\n        if (merkleSL.claimInactive) revert Merkle_ClaimStateAlreadyUpdated();\n        \n        merkleSL.claimInactive = true;\n    }\n\n    // To create 'leaf' use abi.encode(leafProp1, leafProp2, ...)\n    function _consumeLeaf(bytes32[] memory proof, bytes memory _leaf) internal {\n        MerkleStorage.Layout storage merkleSL = MerkleStorage.layout();\n\n        if (merkleSL.claimInactive) revert Merkle_ClaimInactive();\n\n        // TODO: IMPORTANT: ON PRODUCTION REVERT CHANGED ON ITEMS MERKLE CLAIM, TO AVOID INFINITE CLAIM\n        bytes32 proofHash = keccak256(abi.encodePacked(proof));\n        // if (merkleSL.claimedProof[proofHash]) revert Merkle_AlreadyClaimed();\n\n        bytes32 leaf = keccak256(bytes.concat(keccak256(_leaf)));\n        bool isValid = MerkleProof.verify(proof, merkleSL.merkleRoot, leaf);\n        \n        if (!isValid) revert Merkle_NotIncludedInMerkleTree();\n        \n        merkleSL.claimedProof[proofHash] = true;\n    }\n}"
    },
    "contracts/arcadiaDiamonds/merkle/MerkleStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nlibrary MerkleStorage {\n\n    bytes32 constant MERKLE_STORAGE_POSITION =\n        keccak256(\"merkle.storage.position\");\n\n    struct Layout {\n        bytes32 merkleRoot;\n        bool claimInactive;\n        mapping(bytes32 => bool) claimedProof;\n        mapping(address => uint) amountClaimed;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = MERKLE_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/roles/RolesInternal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { AccessControlInternal } from \"@solidstate/contracts/access/access_control/AccessControlInternal.sol\";\nimport { AccessControlStorage } from \"@solidstate/contracts/access/access_control/AccessControlStorage.sol\";\nimport { RolesStorage } from './RolesStorage.sol';\n\ncontract RolesInternal is AccessControlInternal {\n\n    error Roles_MissingAdminRole();\n    error Roles_MissingManagerRole();\n    error Roles_MissingAutomationRole();\n\n    modifier onlyDefaultAdmin() {\n        if (!_hasRole(_defaultAdminRole(), msg.sender))\n            revert Roles_MissingAdminRole();\n        _;\n    }\n\n    modifier onlyManager() {\n        if (!_hasRole(_managerRole(), msg.sender))\n            revert Roles_MissingManagerRole();\n        _;\n    }\n\n    modifier onlyAutomation() {\n        if (!_hasRole(_managerRole(), msg.sender) && !_hasRole(_automationRole(), msg.sender))\n            revert Roles_MissingAutomationRole();\n        _;\n    }\n\n    function _defaultAdminRole() internal pure returns (bytes32) {\n        return AccessControlStorage.DEFAULT_ADMIN_ROLE;\n    }\n\n    function _managerRole() internal view returns (bytes32) {\n        return RolesStorage.layout().managerRole;\n    }\n\n    function _automationRole() internal view returns (bytes32) {\n        return RolesStorage.layout().automationRole;\n    }\n\n    function _initRoles() internal {\n        RolesStorage.Layout storage rolesSL = RolesStorage.layout();\n        rolesSL.managerRole = keccak256(\"manager.role\");\n        rolesSL.automationRole = keccak256(\"automation.role\");\n\n        _grantRole(_defaultAdminRole(), msg.sender);\n        _grantRole(_managerRole(), msg.sender);\n    }\n}"
    },
    "contracts/arcadiaDiamonds/roles/RolesStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nlibrary RolesStorage {\n\n    bytes32 constant ROLES_STORAGE_POSITION =\n        keccak256(\"roles.storage.position\");\n\n    struct Layout {\n        bytes32 managerRole;\n        bytes32 automationRole;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = ROLES_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/whitelist/WhitelistInternal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { WhitelistStorage } from \"./WhitelistStorage.sol\";\nimport { RolesInternal } from \"./../roles/RolesInternal.sol\";\n\ncontract WhitelistInternal is RolesInternal {\n\n    error Whitelist_ExceedsElegibleAmount();\n    error Whitelist_InputDataMismatch();\n    error Whitelist_ClaimStateAlreadyUpdated();\n    error Whitelist_ClaimInactive();\n\n    event WhitelistBalanceChanged(address account, WhitelistStorage.PoolId poolId, uint totalElegibleAmount, uint totalClaimedAmount);\n\n    function _totalClaimedWhitelist(WhitelistStorage.PoolId poolId) internal view returns (uint) {\n        return WhitelistStorage.layout().pools[poolId].totalClaimed;\n    }\n\n    function _totalElegibleWhitelist(WhitelistStorage.PoolId poolId) internal view returns (uint) {\n        return WhitelistStorage.layout().pools[poolId].totalElegible;\n    }\n\n    function _claimedWhitelist(WhitelistStorage.PoolId poolId, address account) internal view returns (uint) {\n        return WhitelistStorage.layout().pools[poolId].claimed[account];\n    }\n\n    function _elegibleWhitelist(WhitelistStorage.PoolId poolId, address account) internal view returns (uint) {\n        return WhitelistStorage.layout().pools[poolId].elegible[account];\n    }\n\n    function _consumeWhitelist(WhitelistStorage.PoolId poolId, address account, uint amount) internal {\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n\n        if (!whitelistSL.pools[poolId].claimActive)\n            revert Whitelist_ClaimInactive();\n\n        if (whitelistSL.pools[poolId].elegible[account] < amount) \n            revert Whitelist_ExceedsElegibleAmount();\n\n        whitelistSL.pools[poolId].elegible[account] -= amount;\n        whitelistSL.pools[poolId].claimed[account] += amount;\n        whitelistSL.pools[poolId].totalClaimed += amount;\n        whitelistSL.pools[poolId].totalElegible -= amount;\n\n        emit WhitelistBalanceChanged(account, poolId, whitelistSL.pools[poolId].elegible[account], whitelistSL.pools[poolId].claimed[account]);\n    }\n\n    function _increaseWhitelistElegible(WhitelistStorage.PoolId poolId, address account, uint amount) internal {\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        whitelistSL.pools[poolId].elegible[account] += amount;\n        whitelistSL.pools[poolId].totalElegible += amount;\n        \n        emit WhitelistBalanceChanged(account, poolId, whitelistSL.pools[poolId].elegible[account], whitelistSL.pools[poolId].claimed[account]);\n    }\n\n    function _increaseWhitelistElegibleBatch(WhitelistStorage.PoolId poolId, address[] calldata accounts, uint[] calldata amounts) internal {\n        if (accounts.length != amounts.length) revert Whitelist_InputDataMismatch();\n\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n\n        for (uint i = 0; i < accounts.length; i++) {\n            whitelistSL.pools[poolId].elegible[accounts[i]] += amounts[i];\n            whitelistSL.pools[poolId].totalElegible += amounts[i];\n            emit WhitelistBalanceChanged(accounts[i], poolId, whitelistSL.pools[poolId].elegible[accounts[i]], whitelistSL.pools[poolId].claimed[accounts[i]]);\n        }\n    }\n\n    function _setWhitelistElegible(WhitelistStorage.PoolId poolId, address account, uint amount) internal {\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        whitelistSL.pools[poolId].totalElegible += amount - whitelistSL.pools[poolId].elegible[account];\n        whitelistSL.pools[poolId].elegible[account] += amount;\n        emit WhitelistBalanceChanged(account, poolId, whitelistSL.pools[poolId].elegible[account], whitelistSL.pools[poolId].claimed[account]);\n    }\n\n    function _setWhitelistElegibleBatch(WhitelistStorage.PoolId poolId, address[] calldata accounts, uint[] calldata amounts) internal {\n        if (accounts.length != amounts.length) revert Whitelist_InputDataMismatch();\n\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n\n        for (uint i = 0; i < accounts.length; i++) {\n            whitelistSL.pools[poolId].totalElegible += amounts[i] - whitelistSL.pools[poolId].elegible[accounts[i]];\n            whitelistSL.pools[poolId].elegible[accounts[i]] = amounts[i];\n            emit WhitelistBalanceChanged(accounts[i], poolId, whitelistSL.pools[poolId].elegible[accounts[i]], whitelistSL.pools[poolId].claimed[accounts[i]]);\n        }\n    }\n\n    function _isWhitelistClaimActive(WhitelistStorage.PoolId poolId) view internal returns (bool) {\n        return WhitelistStorage.layout().pools[poolId].claimActive;\n    }\n\n    function _setWhitelistClaimActive(WhitelistStorage.PoolId poolId, bool active) internal {\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n\n        if (active == whitelistSL.pools[poolId].claimActive) \n            revert Whitelist_ClaimStateAlreadyUpdated();\n        \n        whitelistSL.pools[poolId].claimActive = active;\n    }\n}"
    },
    "contracts/arcadiaDiamonds/whitelist/WhitelistStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nlibrary WhitelistStorage {\n\n    bytes32 constant WHITELIST_STORAGE_POSITION =\n        keccak256(\"whitelist.storage.position\");\n\n    enum PoolId { Guaranteed, Restricted }\n    \n    struct Pool {\n        mapping(address => uint) claimed;\n        mapping(address => uint) elegible;\n        uint totalClaimed;\n        uint totalElegible;\n        bool claimActive;\n    }\n\n    struct Layout {\n        // pool id => tokens pool\n        mapping(PoolId => Pool) pools;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = WHITELIST_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 250
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}