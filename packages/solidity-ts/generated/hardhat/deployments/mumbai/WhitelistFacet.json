{
  "address": "0x44AD1E1dB2aB20ba5bd7Cba7DC3a65868af647F7",
  "abi": [
    {
      "inputs": [],
      "name": "UintUtils__InsufficientHexLength",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "previousAdminRole",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "newAdminRole",
          "type": "bytes32"
        }
      ],
      "name": "RoleAdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleGranted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleRevoked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "amount",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalElegibleAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalClaimedAmount",
          "type": "uint256"
        }
      ],
      "name": "WhitelistBalanceChanged",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "addToWhitelist",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "accounts",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "addToWhitelistBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "whitelistBalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "whitelistClaimed",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xb7490340065fd7ff4a1dcb54ad62c017649bacd3e6703bf46904bef84db0a7ed",
  "receipt": {
    "to": null,
    "from": "0xaD733B7055eCAebFb3B38626f0148c5d12158F03",
    "contractAddress": "0x44AD1E1dB2aB20ba5bd7Cba7DC3a65868af647F7",
    "transactionIndex": 4,
    "gasUsed": "599215",
    "logsBloom": "0x00000000800000000000000000000000000000000000000000000010000000000000000000000020000000000000000000008000000000000000000000000000000000000000000000000000000000800000000200000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100000001000000000000000000000000000000000000001000000000000000000000000100000",
    "blockHash": "0xc3e04c3f627daee86b6f6a6aaf5997de008260533e925b729a14e2b7232b5ea0",
    "transactionHash": "0xb7490340065fd7ff4a1dcb54ad62c017649bacd3e6703bf46904bef84db0a7ed",
    "logs": [
      {
        "transactionIndex": 4,
        "blockNumber": 33773089,
        "transactionHash": "0xb7490340065fd7ff4a1dcb54ad62c017649bacd3e6703bf46904bef84db0a7ed",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000ad733b7055ecaebfb3b38626f0148c5d12158f03",
          "0x000000000000000000000000f903ba9e006193c1527bfbe65fe2123704ea3f99"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000552750903a49bf00000000000000000000000000000000000000000000000017ca069e725918cd000000000000000000000000000000000000000000000c74bf32078543845e490000000000000000000000000000000000000000000000001774df4de21ecf0e000000000000000000000000000000000000000000000c74bf872ed5d3bea808",
        "logIndex": 23,
        "blockHash": "0xc3e04c3f627daee86b6f6a6aaf5997de008260533e925b729a14e2b7232b5ea0"
      }
    ],
    "blockNumber": 33773089,
    "cumulativeGasUsed": "2556107",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 5,
  "solcInputHash": "ceec884e4f0fd5652164bc56988e9b64",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"UintUtils__InsufficientHexLength\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalElegibleAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalClaimedAmount\",\"type\":\"uint256\"}],\"name\":\"WhitelistBalanceChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"addToWhitelistBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"whitelistBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"whitelistClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addToWhitelist(address,uint256)\":{\"details\":\"This function can only be called by an address with the manager role\",\"params\":{\"account\":\"The address to add to the whitelist\",\"amount\":\"The amount to whitelist for the address\"}},\"addToWhitelistBatch(address[],uint256[])\":{\"details\":\"This function can only be called by an address with the manager role\",\"params\":{\"accounts\":\"An array of addresses to add to the whitelist\",\"amounts\":\"An array of amounts to whitelist for each address\"}},\"whitelistBalance(address)\":{\"params\":{\"account\":\"The address of the account to query\"},\"returns\":{\"_0\":\"The remaining balance of the account\"}},\"whitelistClaimed(address)\":{\"params\":{\"account\":\"The address of the account to query\"},\"returns\":{\"_0\":\"The amount claimed by the account\"}}},\"title\":\"WhitelistFacet\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addToWhitelist(address,uint256)\":{\"notice\":\"Adds a new address to the whitelist with a specific amount\"},\"addToWhitelistBatch(address[],uint256[])\":{\"notice\":\"Adds multiple addresses to the whitelist with specific amounts\"},\"whitelistBalance(address)\":{\"notice\":\"Returns the remaining balance for a whitelisted account\"},\"whitelistClaimed(address)\":{\"notice\":\"Returns the amount claimed by a whitelisted account\"}},\"notice\":\"This contract allows the admins to whitelist an address with a specific amount, which can then be used to claim tokens in other contracts. To consume the whitelist, the token contracts should call the internal functions from WhitelistInternal. This contract can be used as a facet of a diamond which follows the EIP-2535 diamond standard.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/arcadiaDiamonds/whitelist/WhitelistFacet.sol\":\"WhitelistFacet\"},\"evmVersion\":\"paris\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x00000000d41867734bbee4c6863d9255b2b06ac1\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":250},\"remappings\":[]},\"sources\":{\"@solidstate/contracts/access/access_control/AccessControlInternal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\\nimport { UintUtils } from '../../utils/UintUtils.sol';\\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\\nimport { AccessControlStorage } from './AccessControlStorage.sol';\\n\\n/**\\n * @title Role-based access control system\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nabstract contract AccessControlInternal is IAccessControlInternal {\\n    using AddressUtils for address;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using UintUtils for uint256;\\n\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /*\\n     * @notice query whether role is assigned to account\\n     * @param role role to query\\n     * @param account account to query\\n     * @return whether role is assigned to account\\n     */\\n    function _hasRole(\\n        bytes32 role,\\n        address account\\n    ) internal view virtual returns (bool) {\\n        return\\n            AccessControlStorage.layout().roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @notice revert if sender does not have given role\\n     * @param role role to query\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, msg.sender);\\n    }\\n\\n    /**\\n     * @notice revert if given account does not have given role\\n     * @param role role to query\\n     * @param account to query\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!_hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        'AccessControl: account ',\\n                        account.toString(),\\n                        ' is missing role ',\\n                        uint256(role).toHexString(32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /*\\n     * @notice query admin role for given role\\n     * @param role role to query\\n     * @return admin role\\n     */\\n    function _getRoleAdmin(\\n        bytes32 role\\n    ) internal view virtual returns (bytes32) {\\n        return AccessControlStorage.layout().roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @notice set role as admin role\\n     * @param role role to set\\n     * @param adminRole admin role to set\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = _getRoleAdmin(role);\\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /*\\n     * @notice assign role to given account\\n     * @param role role to assign\\n     * @param account recipient of role assignment\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        AccessControlStorage.layout().roles[role].members.add(account);\\n        emit RoleGranted(role, account, msg.sender);\\n    }\\n\\n    /*\\n     * @notice unassign role from given account\\n     * @param role role to unassign\\n     * @parm account\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        AccessControlStorage.layout().roles[role].members.remove(account);\\n        emit RoleRevoked(role, account, msg.sender);\\n    }\\n\\n    /**\\n     * @notice relinquish role\\n     * @param role role to relinquish\\n     */\\n    function _renounceRole(bytes32 role) internal virtual {\\n        _revokeRole(role, msg.sender);\\n    }\\n}\\n\",\"keccak256\":\"0x5c32c5b490b9a2dd9daa533a75f940f0b0f69c9033776f5e274cd2446c224513\",\"license\":\"MIT\"},\"@solidstate/contracts/access/access_control/AccessControlStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\\n\\nlibrary AccessControlStorage {\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    struct Layout {\\n        mapping(bytes32 => RoleData) roles;\\n    }\\n\\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.AccessControl');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xae788d37a6e20edf7f94be23d78517324f50bccbf0541e10ce0850d7d5bca062\",\"license\":\"MIT\"},\"@solidstate/contracts/access/access_control/IAccessControlInternal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial AccessControl interface needed by internal functions\\n */\\ninterface IAccessControlInternal {\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n}\\n\",\"keccak256\":\"0xcc4a1d78a60955d673104adaee1211de3b3cfb95668f1fbfc43ed0e7f36ad110\",\"license\":\"MIT\"},\"@solidstate/contracts/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Merkle tree verification utility\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @notice verify whether given leaf is contained within Merkle tree defined by given root\\n     * @param proof proof that Merkle tree contains given leaf\\n     * @param root Merkle tree root\\n     * @param leaf element whose presence in Merkle tree to prove\\n     * @return whether leaf is proven to be contained within Merkle tree defined by root\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        unchecked {\\n            bytes32 computedHash = leaf;\\n\\n            for (uint256 i = 0; i < proof.length; i++) {\\n                bytes32 proofElement = proof[i];\\n\\n                if (computedHash <= proofElement) {\\n                    computedHash = keccak256(\\n                        abi.encodePacked(computedHash, proofElement)\\n                    );\\n                } else {\\n                    computedHash = keccak256(\\n                        abi.encodePacked(proofElement, computedHash)\\n                    );\\n                }\\n            }\\n\\n            return computedHash == root;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf3a6592d4e2c90f92ccae441401241b4a8837e95a15f3c3887abc544e85e362c\",\"license\":\"MIT\"},\"@solidstate/contracts/data/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n    error EnumerableSet__IndexOutOfBounds();\\n\\n    struct Set {\\n        bytes32[] _values;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function at(\\n        Bytes32Set storage set,\\n        uint256 index\\n    ) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    function at(\\n        AddressSet storage set,\\n        uint256 index\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function at(\\n        UintSet storage set,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function contains(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function contains(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function indexOf(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, value);\\n    }\\n\\n    function indexOf(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function indexOf(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(value));\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function add(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    function add(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function remove(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function toArray(\\n        Bytes32Set storage set\\n    ) internal view returns (bytes32[] memory) {\\n        return set._inner._values;\\n    }\\n\\n    function toArray(\\n        AddressSet storage set\\n    ) internal view returns (address[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        address[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function toArray(\\n        UintSet storage set\\n    ) internal view returns (uint256[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        uint256[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function _at(\\n        Set storage set,\\n        uint256 index\\n    ) private view returns (bytes32) {\\n        if (index >= set._values.length)\\n            revert EnumerableSet__IndexOutOfBounds();\\n        return set._values[index];\\n    }\\n\\n    function _contains(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _indexOf(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (uint256) {\\n        unchecked {\\n            return set._indexes[value] - 1;\\n        }\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _add(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            status = true;\\n        }\\n    }\\n\\n    function _remove(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            unchecked {\\n                bytes32 last = set._values[set._values.length - 1];\\n\\n                // move last value to now-vacant index\\n\\n                set._values[valueIndex - 1] = last;\\n                set._indexes[last] = valueIndex;\\n            }\\n            // clear last index\\n\\n            set._values.pop();\\n            delete set._indexes[value];\\n\\n            status = true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbbaaeb805b3e1e704ceba33c9093285220254b1ff6b4b7f577e515b118e116f6\",\"license\":\"MIT\"},\"@solidstate/contracts/utils/AddressUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { UintUtils } from './UintUtils.sol';\\n\\nlibrary AddressUtils {\\n    using UintUtils for uint256;\\n\\n    error AddressUtils__InsufficientBalance();\\n    error AddressUtils__NotContract();\\n    error AddressUtils__SendValueFailed();\\n\\n    function toString(address account) internal pure returns (string memory) {\\n        return uint256(uint160(account)).toHexString(20);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        if (!success) revert AddressUtils__SendValueFailed();\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        if (value > address(this).balance)\\n            revert AddressUtils__InsufficientBalance();\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    /**\\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\\n     * @param target recipient of call\\n     * @param gasAmount gas allowance for call\\n     * @param value native token value to include in call\\n     * @param maxCopy maximum number of bytes to copy from return data\\n     * @param data encoded call data\\n     * @return success whether call is successful\\n     * @return returnData copied return data\\n     */\\n    function excessivelySafeCall(\\n        address target,\\n        uint256 gasAmount,\\n        uint256 value,\\n        uint16 maxCopy,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        returnData = new bytes(maxCopy);\\n\\n        assembly {\\n            // execute external call via assembly to avoid automatic copying of return data\\n            success := call(\\n                gasAmount,\\n                target,\\n                value,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0\\n            )\\n\\n            // determine whether to limit amount of data to copy\\n            let toCopy := returndatasize()\\n\\n            if gt(toCopy, maxCopy) {\\n                toCopy := maxCopy\\n            }\\n\\n            // store the length of the copied bytes\\n            mstore(returnData, toCopy)\\n\\n            // copy the bytes from returndata[0:toCopy]\\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\\n        }\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        if (!isContract(target)) revert AddressUtils__NotContract();\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7d924db4dbd9210923ab08db77db3c77438014c255fd49fa208ebce283d991bf\",\"license\":\"MIT\"},\"@solidstate/contracts/utils/UintUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title utility functions for uint256 operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary UintUtils {\\n    error UintUtils__InsufficientHexLength();\\n\\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\\n\\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? sub(a, -b) : a + uint256(b);\\n    }\\n\\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? add(a, -b) : a - uint256(b);\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0';\\n        }\\n\\n        uint256 temp = value;\\n        uint256 digits;\\n\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        bytes memory buffer = new bytes(digits);\\n\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0x00';\\n        }\\n\\n        uint256 length = 0;\\n\\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\\n            unchecked {\\n                length++;\\n            }\\n        }\\n\\n        return toHexString(value, length);\\n    }\\n\\n    function toHexString(\\n        uint256 value,\\n        uint256 length\\n    ) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = '0';\\n        buffer[1] = 'x';\\n\\n        unchecked {\\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\\n                value >>= 4;\\n            }\\n        }\\n\\n        if (value != 0) revert UintUtils__InsufficientHexLength();\\n\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x5aaeaea22a0800402c6f2d8ce6185293bc64f74f6c390c1b1c53b624b43972f8\",\"license\":\"MIT\"},\"contracts/arcadiaDiamonds/roles/RolesInternal.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport { AccessControlInternal } from \\\"@solidstate/contracts/access/access_control/AccessControlInternal.sol\\\";\\nimport { AccessControlStorage } from \\\"@solidstate/contracts/access/access_control/AccessControlStorage.sol\\\";\\nimport { RolesStorage } from './RolesStorage.sol';\\n\\ncontract RolesInternal is AccessControlInternal {\\n\\n    modifier onlyDefaultAdmin() {\\n        _checkRole(_defaultAdminRole());\\n        _;\\n    }\\n\\n    modifier onlyManager() {\\n        _checkRole(_managerRole());\\n        _;\\n    }\\n\\n    modifier onlyMinter() {\\n        _checkRole(_minterRole());\\n        _;\\n    }\\n\\n    function _defaultAdminRole() internal pure returns (bytes32) {\\n        return AccessControlStorage.DEFAULT_ADMIN_ROLE;\\n    }\\n\\n    function _managerRole() internal view returns (bytes32) {\\n        return RolesStorage.layout().managerRole;\\n    }\\n\\n    function _minterRole() internal view returns (bytes32) {\\n        return RolesStorage.layout().minterRole;\\n    }\\n\\n    function _initRoles() internal {\\n        RolesStorage.Layout storage rolesSL = RolesStorage.layout();\\n        rolesSL.managerRole = keccak256(\\\"manager.role\\\");\\n        rolesSL.minterRole = keccak256(\\\"minter.role\\\");\\n\\n        _grantRole(_defaultAdminRole(), msg.sender);\\n        _grantRole(_managerRole(), msg.sender);\\n        _grantRole(_minterRole(), msg.sender);\\n    }\\n}\",\"keccak256\":\"0xd3fa8bcc9380c117c2e22aeb6b4489ad01c31433b3c2d412742b681c94cf407d\",\"license\":\"UNLICENSED\"},\"contracts/arcadiaDiamonds/roles/RolesStorage.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nlibrary RolesStorage {\\n\\n    bytes32 constant ROLES_STORAGE_POSITION =\\n        keccak256(\\\"roles.storage.position\\\");\\n\\n    struct Layout {\\n        bytes32 managerRole;\\n        bytes32 minterRole;\\n    }\\n\\n    function layout()\\n        internal\\n        pure\\n        returns (Layout storage es)\\n    {\\n        bytes32 position = ROLES_STORAGE_POSITION;\\n        assembly {\\n            es.slot := position\\n        }\\n    }\\n}\",\"keccak256\":\"0x203cfbe268a1ac5fe32593c66ace04b576dfb2e25173e02654e504cf0de44d71\",\"license\":\"UNLICENSED\"},\"contracts/arcadiaDiamonds/whitelist/WhitelistFacet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport { WhitelistInternal } from './WhitelistInternal.sol';\\n\\n/**\\n * @title WhitelistFacet\\n * @notice This contract allows the admins to whitelist an address with a specific amount,\\n * which can then be used to claim tokens in other contracts.\\n * To consume the whitelist, the token contracts should call the internal functions from WhitelistInternal.\\n * This contract can be used as a facet of a diamond which follows the EIP-2535 diamond standard.\\n */\\ncontract WhitelistFacet is WhitelistInternal {\\n\\n    /**\\n     * @notice Returns the amount claimed by a whitelisted account\\n     * @param account The address of the account to query\\n     * @return The amount claimed by the account\\n     */\\n    function whitelistClaimed(address account) external view returns (uint) {\\n        return _whitelistClaimed(account);\\n    }\\n\\n    /**\\n     * @notice Returns the remaining balance for a whitelisted account\\n     * @param account The address of the account to query\\n     * @return The remaining balance of the account\\n     */\\n    function whitelistBalance(address account) external view returns (uint) {\\n        return _whitelistBalance(account);\\n    }\\n\\n    /**\\n     * @notice Adds a new address to the whitelist with a specific amount\\n     * @dev This function can only be called by an address with the manager role\\n     * @param account The address to add to the whitelist\\n     * @param amount The amount to whitelist for the address\\n     */\\n    function addToWhitelist(address account, uint amount) onlyManager external {\\n        _addToWhitelist(account, amount);\\n    }\\n\\n    /**\\n     * @notice Adds multiple addresses to the whitelist with specific amounts\\n     * @dev This function can only be called by an address with the manager role\\n     * @param accounts An array of addresses to add to the whitelist\\n     * @param amounts An array of amounts to whitelist for each address\\n     */\\n    function addToWhitelistBatch(address[] calldata accounts, uint[] calldata amounts) external onlyManager {\\n        _addToWhitelistBatch(accounts, amounts);\\n    }\\n}\",\"keccak256\":\"0x0b13389dbf8c44f0346138d6c82346aa745cce3fa1ed254ae789f91d87b1c863\",\"license\":\"UNLICENSED\"},\"contracts/arcadiaDiamonds/whitelist/WhitelistInternal.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport { MerkleProof } from \\\"@solidstate/contracts/cryptography/MerkleProof.sol\\\";\\nimport { WhitelistStorage } from \\\"./WhitelistStorage.sol\\\";\\nimport { RolesInternal } from \\\"./../roles/RolesInternal.sol\\\";\\n\\ncontract WhitelistInternal is RolesInternal {\\n\\n    event WhitelistBalanceChanged(address account, int amount, uint totalElegibleAmount, uint totalClaimedAmount);\\n\\n    function _whitelistClaimed(address account) internal view returns (uint) {\\n        return WhitelistStorage.layout().claimed[account];\\n    }\\n\\n    function _whitelistBalance(address account) internal view returns (uint) {\\n        return WhitelistStorage.layout().elegible[account];\\n    }\\n\\n    function _consumeWhitelist(address account, uint amount) internal {\\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\\n        require(whitelistSL.elegible[account] >= amount, \\\"WhitelistInternal._consumeWhitelist: amount exceeds elegible amount\\\");\\n        whitelistSL.elegible[account] -= amount;\\n        whitelistSL.claimed[account] += amount;\\n        emit WhitelistBalanceChanged(msg.sender, int(amount), whitelistSL.elegible[account], whitelistSL.claimed[account]);\\n    }\\n\\n    function _addToWhitelist(address account, uint amount) onlyManager internal {\\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\\n        whitelistSL.elegible[account] += amount;\\n        emit WhitelistBalanceChanged(msg.sender, int(amount), whitelistSL.elegible[account], whitelistSL.claimed[account]);\\n    }\\n\\n    function _addToWhitelistBatch(address[] calldata accounts, uint[] calldata amounts) onlyManager internal {\\n        require(accounts.length == amounts.length, \\\"WhitelistInternal._addToWhitelistBatch: Inputs length mismatch\\\");\\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\\n        for (uint i = 0; i < accounts.length; i++) {\\n            whitelistSL.elegible[accounts[i]] += amounts[i];\\n            emit WhitelistBalanceChanged(msg.sender, int(amounts[i]), whitelistSL.elegible[accounts[i]], whitelistSL.claimed[accounts[i]]);\\n        }\\n    }\\n}\",\"keccak256\":\"0x2fbd9e7092fbe7ed4a738a0b999307adacac14f6e59aa7a189b04f1fbb2061dc\",\"license\":\"UNLICENSED\"},\"contracts/arcadiaDiamonds/whitelist/WhitelistStorage.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nlibrary WhitelistStorage {\\n\\n    bytes32 constant WHITELIST_STORAGE_POSITION =\\n        keccak256(\\\"whitelist.storage.position\\\");\\n\\n    struct Layout {\\n        mapping(address => uint) claimed;\\n        mapping(address => uint) elegible;\\n    }\\n\\n    function layout()\\n        internal\\n        pure\\n        returns (Layout storage es)\\n    {\\n        bytes32 position = WHITELIST_STORAGE_POSITION;\\n        assembly {\\n            es.slot := position\\n        }\\n    }\\n}\",\"keccak256\":\"0x1eae9928eb6da719f50ca96c4081e0d83e8d5cfb6dee9ca57c4f0e3a5fc9cd39\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506109e1806100206000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c8063214405fc14610051578063368e186114610066578063601288dc1461008b578063db4bec441461009e575b600080fd5b61006461005f36600461075d565b6100b1565b005b610079610074366004610787565b6100ef565b60405190815260200160405180910390f35b6100646100993660046107ee565b61012e565b6100796100ac366004610787565b61016b565b6100e16100dc7ff6deb63e40d71b08820818e006e23fcceb1fce7a499bc15b71b2526cbf9efa725490565b6101a8565b6100eb82826101b5565b5050565b6001600160a01b03811660009081527ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358960205260408120545b92915050565b6101596100dc7ff6deb63e40d71b08820818e006e23fcceb1fce7a499bc15b71b2526cbf9efa725490565b610165848484846102c0565b50505050565b6001600160a01b03811660009081527ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb35886020526040812054610128565b6101b2813361051e565b50565b6101e06100dc7ff6deb63e40d71b08820818e006e23fcceb1fce7a499bc15b71b2526cbf9efa725490565b6001600160a01b03821660009081527ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb35896020526040812080547ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358892849291610249908490610870565b90915550506001600160a01b0383166000908152600182016020908152604080832054848352928190205481513381529283018690529082019290925260608101919091527fdb4f4d78cc1c961ddedd2f43596d41d07e607b7517c7106d83f6421215e1f6a79060800160405180910390a1505050565b6102eb6100dc7ff6deb63e40d71b08820818e006e23fcceb1fce7a499bc15b71b2526cbf9efa725490565b8281146103655760405162461bcd60e51b815260206004820152603e60248201527f57686974656c697374496e7465726e616c2e5f616464546f57686974656c697360448201527f7442617463683a20496e70757473206c656e677468206d69736d61746368000060648201526084015b60405180910390fd5b7ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358860005b84811015610516578383828181106103a3576103a3610883565b905060200201358260010160008888858181106103c2576103c2610883565b90506020020160208101906103d79190610787565b6001600160a01b03166001600160a01b0316815260200190815260200160002060008282546104069190610870565b909155507fdb4f4d78cc1c961ddedd2f43596d41d07e607b7517c7106d83f6421215e1f6a790503385858481811061044057610440610883565b905060200201358460010160008a8a8781811061045f5761045f610883565b90506020020160208101906104749190610787565b6001600160a01b03166001600160a01b03168152602001908152602001600020548560000160008b8b888181106104ad576104ad610883565b90506020020160208101906104c29190610787565b6001600160a01b03908116825260208083019390935260409182016000205482519690911686529185019390935291830152606082015260800160405180910390a18061050e81610899565b915050610389565b505050505050565b6105288282610580565b6100eb5761053e816001600160a01b03166105dc565b6105498360206105ee565b60405160200161055a9291906108d6565b60408051601f198184030181529082905262461bcd60e51b825261035c9160040161094b565b60006105d5827fd3889cc5458b268d0544e5534672df1296288ca3f93cbd39bd6f497a5c622811600086815260209190915260409020906001600160a01b038116600090815260018301602052604081205415155b9392505050565b60606101286001600160a01b03831660145b606060006105fd83600261097e565b610608906002610870565b67ffffffffffffffff81111561062057610620610995565b6040519080825280601f01601f19166020018201604052801561064a576020820181803683370190505b509050600360fc1b8160008151811061066557610665610883565b60200101906001600160f81b031916908160001a905350600f60fb1b8160018151811061069457610694610883565b60200101906001600160f81b031916908160001a905350600160028402015b6001811115610721576f181899199a1a9b1b9c1cb0b131b232b360811b85600f16601081106106e4576106e4610883565b1a60f81b8282815181106106fa576106fa610883565b60200101906001600160f81b031916908160001a90535060049490941c93600019016106b3565b5083156105d55760405163c913478560e01b815260040160405180910390fd5b80356001600160a01b038116811461075857600080fd5b919050565b6000806040838503121561077057600080fd5b61077983610741565b946020939093013593505050565b60006020828403121561079957600080fd5b6105d582610741565b60008083601f8401126107b457600080fd5b50813567ffffffffffffffff8111156107cc57600080fd5b6020830191508360208260051b85010111156107e757600080fd5b9250929050565b6000806000806040858703121561080457600080fd5b843567ffffffffffffffff8082111561081c57600080fd5b610828888389016107a2565b9096509450602087013591508082111561084157600080fd5b5061084e878288016107a2565b95989497509550505050565b634e487b7160e01b600052601160045260246000fd5b808201808211156101285761012861085a565b634e487b7160e01b600052603260045260246000fd5b6000600182016108ab576108ab61085a565b5060010190565b60005b838110156108cd5781810151838201526020016108b5565b50506000910152565b7f416363657373436f6e74726f6c3a206163636f756e742000000000000000000081526000835161090e8160178501602088016108b2565b7001034b99036b4b9b9b4b733903937b6329607d1b601791840191820152835161093f8160288401602088016108b2565b01602801949350505050565b602081526000825180602084015261096a8160408501602087016108b2565b601f01601f19169190910160400192915050565b80820281158282048414176101285761012861085a565b634e487b7160e01b600052604160045260246000fdfea2646970667358221220694acbd01ea7edfff1d67dbcad74e4505e3e770e54b5fe2c239db17651b1d98a64736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c8063214405fc14610051578063368e186114610066578063601288dc1461008b578063db4bec441461009e575b600080fd5b61006461005f36600461075d565b6100b1565b005b610079610074366004610787565b6100ef565b60405190815260200160405180910390f35b6100646100993660046107ee565b61012e565b6100796100ac366004610787565b61016b565b6100e16100dc7ff6deb63e40d71b08820818e006e23fcceb1fce7a499bc15b71b2526cbf9efa725490565b6101a8565b6100eb82826101b5565b5050565b6001600160a01b03811660009081527ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358960205260408120545b92915050565b6101596100dc7ff6deb63e40d71b08820818e006e23fcceb1fce7a499bc15b71b2526cbf9efa725490565b610165848484846102c0565b50505050565b6001600160a01b03811660009081527ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb35886020526040812054610128565b6101b2813361051e565b50565b6101e06100dc7ff6deb63e40d71b08820818e006e23fcceb1fce7a499bc15b71b2526cbf9efa725490565b6001600160a01b03821660009081527ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb35896020526040812080547ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358892849291610249908490610870565b90915550506001600160a01b0383166000908152600182016020908152604080832054848352928190205481513381529283018690529082019290925260608101919091527fdb4f4d78cc1c961ddedd2f43596d41d07e607b7517c7106d83f6421215e1f6a79060800160405180910390a1505050565b6102eb6100dc7ff6deb63e40d71b08820818e006e23fcceb1fce7a499bc15b71b2526cbf9efa725490565b8281146103655760405162461bcd60e51b815260206004820152603e60248201527f57686974656c697374496e7465726e616c2e5f616464546f57686974656c697360448201527f7442617463683a20496e70757473206c656e677468206d69736d61746368000060648201526084015b60405180910390fd5b7ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358860005b84811015610516578383828181106103a3576103a3610883565b905060200201358260010160008888858181106103c2576103c2610883565b90506020020160208101906103d79190610787565b6001600160a01b03166001600160a01b0316815260200190815260200160002060008282546104069190610870565b909155507fdb4f4d78cc1c961ddedd2f43596d41d07e607b7517c7106d83f6421215e1f6a790503385858481811061044057610440610883565b905060200201358460010160008a8a8781811061045f5761045f610883565b90506020020160208101906104749190610787565b6001600160a01b03166001600160a01b03168152602001908152602001600020548560000160008b8b888181106104ad576104ad610883565b90506020020160208101906104c29190610787565b6001600160a01b03908116825260208083019390935260409182016000205482519690911686529185019390935291830152606082015260800160405180910390a18061050e81610899565b915050610389565b505050505050565b6105288282610580565b6100eb5761053e816001600160a01b03166105dc565b6105498360206105ee565b60405160200161055a9291906108d6565b60408051601f198184030181529082905262461bcd60e51b825261035c9160040161094b565b60006105d5827fd3889cc5458b268d0544e5534672df1296288ca3f93cbd39bd6f497a5c622811600086815260209190915260409020906001600160a01b038116600090815260018301602052604081205415155b9392505050565b60606101286001600160a01b03831660145b606060006105fd83600261097e565b610608906002610870565b67ffffffffffffffff81111561062057610620610995565b6040519080825280601f01601f19166020018201604052801561064a576020820181803683370190505b509050600360fc1b8160008151811061066557610665610883565b60200101906001600160f81b031916908160001a905350600f60fb1b8160018151811061069457610694610883565b60200101906001600160f81b031916908160001a905350600160028402015b6001811115610721576f181899199a1a9b1b9c1cb0b131b232b360811b85600f16601081106106e4576106e4610883565b1a60f81b8282815181106106fa576106fa610883565b60200101906001600160f81b031916908160001a90535060049490941c93600019016106b3565b5083156105d55760405163c913478560e01b815260040160405180910390fd5b80356001600160a01b038116811461075857600080fd5b919050565b6000806040838503121561077057600080fd5b61077983610741565b946020939093013593505050565b60006020828403121561079957600080fd5b6105d582610741565b60008083601f8401126107b457600080fd5b50813567ffffffffffffffff8111156107cc57600080fd5b6020830191508360208260051b85010111156107e757600080fd5b9250929050565b6000806000806040858703121561080457600080fd5b843567ffffffffffffffff8082111561081c57600080fd5b610828888389016107a2565b9096509450602087013591508082111561084157600080fd5b5061084e878288016107a2565b95989497509550505050565b634e487b7160e01b600052601160045260246000fd5b808201808211156101285761012861085a565b634e487b7160e01b600052603260045260246000fd5b6000600182016108ab576108ab61085a565b5060010190565b60005b838110156108cd5781810151838201526020016108b5565b50506000910152565b7f416363657373436f6e74726f6c3a206163636f756e742000000000000000000081526000835161090e8160178501602088016108b2565b7001034b99036b4b9b9b4b733903937b6329607d1b601791840191820152835161093f8160288401602088016108b2565b01602801949350505050565b602081526000825180602084015261096a8160408501602087016108b2565b601f01601f19169190910160400192915050565b80820281158282048414176101285761012861085a565b634e487b7160e01b600052604160045260246000fdfea2646970667358221220694acbd01ea7edfff1d67dbcad74e4505e3e770e54b5fe2c239db17651b1d98a64736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "addToWhitelist(address,uint256)": {
        "details": "This function can only be called by an address with the manager role",
        "params": {
          "account": "The address to add to the whitelist",
          "amount": "The amount to whitelist for the address"
        }
      },
      "addToWhitelistBatch(address[],uint256[])": {
        "details": "This function can only be called by an address with the manager role",
        "params": {
          "accounts": "An array of addresses to add to the whitelist",
          "amounts": "An array of amounts to whitelist for each address"
        }
      },
      "whitelistBalance(address)": {
        "params": {
          "account": "The address of the account to query"
        },
        "returns": {
          "_0": "The remaining balance of the account"
        }
      },
      "whitelistClaimed(address)": {
        "params": {
          "account": "The address of the account to query"
        },
        "returns": {
          "_0": "The amount claimed by the account"
        }
      }
    },
    "title": "WhitelistFacet",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "addToWhitelist(address,uint256)": {
        "notice": "Adds a new address to the whitelist with a specific amount"
      },
      "addToWhitelistBatch(address[],uint256[])": {
        "notice": "Adds multiple addresses to the whitelist with specific amounts"
      },
      "whitelistBalance(address)": {
        "notice": "Returns the remaining balance for a whitelisted account"
      },
      "whitelistClaimed(address)": {
        "notice": "Returns the amount claimed by a whitelisted account"
      }
    },
    "notice": "This contract allows the admins to whitelist an address with a specific amount, which can then be used to claim tokens in other contracts. To consume the whitelist, the token contracts should call the internal functions from WhitelistInternal. This contract can be used as a facet of a diamond which follows the EIP-2535 diamond standard.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}