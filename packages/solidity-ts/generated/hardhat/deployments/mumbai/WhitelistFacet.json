{
  "address": "0xb8EA4A3ebb988AED6ea7413F93329060A3e9582A",
  "abi": [
    {
      "inputs": [],
      "name": "UintUtils__InsufficientHexLength",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Whitelist_ClaimInactive",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Whitelist_ClaimStateAlreadyUpdated",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Whitelist_ExceedsElegibleAmount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Whitelist_InputDataMismatch",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "previousAdminRole",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "newAdminRole",
          "type": "bytes32"
        }
      ],
      "name": "RoleAdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleGranted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleRevoked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalElegibleAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalClaimedAmount",
          "type": "uint256"
        }
      ],
      "name": "WhitelistBalanceChanged",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "claimedWhitelist",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "elegibleWhitelist",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "increaseWhitelistElegible",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "accounts",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "increaseWhitelistElegibleBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isWhitelistClaimActive",
      "outputs": [
        {
          "internalType": "bool",
          "name": "active",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "setWhitelistClaimActive",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "setWhitelistClaimInactive",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "totalAmount",
          "type": "uint256"
        }
      ],
      "name": "setWhitelistElegible",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "accounts",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "totalAmounts",
          "type": "uint256[]"
        }
      ],
      "name": "setWhitelistElegibleBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalClaimedWhitelist",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalElegibleWhitelist",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xec401fd8fe4ec47cf11b5b63a0a79f8ad7784b411fada68b0a7b2c7ff69d02eb",
  "receipt": {
    "to": null,
    "from": "0xaD733B7055eCAebFb3B38626f0148c5d12158F03",
    "contractAddress": "0xb8EA4A3ebb988AED6ea7413F93329060A3e9582A",
    "transactionIndex": 0,
    "gasUsed": "860019",
    "logsBloom": "0x00000000800000000000000000000000000000000000000000000010000000000000000000000020000000000000000000008000000000000000000000000000000000000000000000000000000000800000000200000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100000001000000000000000000000000000000000000001000000000000000000000000100000",
    "blockHash": "0xb5f597614f3bd9c2f3e4664b40859ba4caf25889cc3a67ccfc9a5ff83d2eb2a8",
    "transactionHash": "0xec401fd8fe4ec47cf11b5b63a0a79f8ad7784b411fada68b0a7b2c7ff69d02eb",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 33932154,
        "transactionHash": "0xec401fd8fe4ec47cf11b5b63a0a79f8ad7784b411fada68b0a7b2c7ff69d02eb",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000ad733b7055ecaebfb3b38626f0148c5d12158f03",
          "0x000000000000000000000000f903ba9e006193c1527bfbe65fe2123704ea3f99"
        ],
        "data": "0x000000000000000000000000000000000000000000000000007a374f1708d8430000000000000000000000000000000000000000000000001fed6c118dca8566000000000000000000000000000000000000000000000c8b3ac486101ca12d4c0000000000000000000000000000000000000000000000001f7334c276c1ad23000000000000000000000000000000000000000000000c8b3b3ebd5f33aa058f",
        "logIndex": 0,
        "blockHash": "0xb5f597614f3bd9c2f3e4664b40859ba4caf25889cc3a67ccfc9a5ff83d2eb2a8"
      }
    ],
    "blockNumber": 33932154,
    "cumulativeGasUsed": "860019",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 6,
  "solcInputHash": "e1d11ad5ee5467196d54810266d81cef",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"UintUtils__InsufficientHexLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Whitelist_ClaimInactive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Whitelist_ClaimStateAlreadyUpdated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Whitelist_ExceedsElegibleAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Whitelist_InputDataMismatch\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalElegibleAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalClaimedAmount\",\"type\":\"uint256\"}],\"name\":\"WhitelistBalanceChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimedWhitelist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"elegibleWhitelist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseWhitelistElegible\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"increaseWhitelistElegibleBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWhitelistClaimActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setWhitelistClaimActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setWhitelistClaimInactive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"setWhitelistElegible\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"totalAmounts\",\"type\":\"uint256[]\"}],\"name\":\"setWhitelistElegibleBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimedWhitelist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalElegibleWhitelist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"claimedWhitelist(address)\":{\"params\":{\"account\":\"The address of the account to query\"},\"returns\":{\"_0\":\"The amount claimed by the account\"}},\"elegibleWhitelist(address)\":{\"params\":{\"account\":\"The address of the account to query\"},\"returns\":{\"_0\":\"The elegible amount of the account\"}},\"increaseWhitelistElegible(address,uint256)\":{\"details\":\"This function can only be called by an address with the manager role\",\"params\":{\"account\":\"The address to add to the whitelist\",\"amount\":\"The amount to whitelist for the address\"}},\"increaseWhitelistElegibleBatch(address[],uint256[])\":{\"details\":\"This function can only be called by an address with the manager role\",\"params\":{\"accounts\":\"An array of addresses to add to the whitelist\",\"amounts\":\"An array of amounts to whitelist for each address\"}},\"isWhitelistClaimActive()\":{\"returns\":{\"active\":\"bool indicating if claim is active\"}},\"setWhitelistClaimActive()\":{\"details\":\"This function can only be called by an address with the manager role\"},\"setWhitelistClaimInactive()\":{\"details\":\"This function can only be called by an address with the manager role\"},\"setWhitelistElegible(address,uint256)\":{\"details\":\"This function can only be called by an address with the manager role\",\"params\":{\"account\":\"The address to add to the whitelist\",\"totalAmount\":\"The amount to whitelist for the address\"}},\"setWhitelistElegibleBatch(address[],uint256[])\":{\"details\":\"This function can only be called by an address with the manager role\",\"params\":{\"accounts\":\"An array of addresses to add to the whitelist\",\"totalAmounts\":\"An array of amounts to whitelist for each address\"}},\"totalClaimedWhitelist()\":{\"returns\":{\"_0\":\"The total claimed amount\"}},\"totalElegibleWhitelist()\":{\"returns\":{\"_0\":\"The total elegible amount\"}}},\"title\":\"WhitelistFacet\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"claimedWhitelist(address)\":{\"notice\":\"Returns the amount claimed by a whitelisted account\"},\"elegibleWhitelist(address)\":{\"notice\":\"Returns the remaining elegible amount for a whitelisted account\"},\"increaseWhitelistElegible(address,uint256)\":{\"notice\":\"Increase the whitelist elegible amount for an address\"},\"increaseWhitelistElegibleBatch(address[],uint256[])\":{\"notice\":\"Increase the whitelist elegible amounts for multiple addresses\"},\"isWhitelistClaimActive()\":{\"notice\":\"Returns true if elegible tokens can be claimed, or false otherwise\"},\"setWhitelistClaimActive()\":{\"notice\":\"Updates the claim state to active and enables the claim of tokens\"},\"setWhitelistClaimInactive()\":{\"notice\":\"Updates the claim state to inactive and disables the claim of tokens\"},\"setWhitelistElegible(address,uint256)\":{\"notice\":\"Adds a new address to the whitelist with a specific amount\"},\"setWhitelistElegibleBatch(address[],uint256[])\":{\"notice\":\"Adds multiple addresses to the whitelist with specific amounts\"},\"totalClaimedWhitelist()\":{\"notice\":\"Returns the total claimed amount\"},\"totalElegibleWhitelist()\":{\"notice\":\"Returns the total elegible amount\"}},\"notice\":\"This contract allows the admins to whitelist an address with a specific amount, which can then be used to claim tokens in other contracts. To consume the whitelist, the token contracts should call the internal functions from WhitelistInternal. This contract can be used as a facet of a diamond which follows the EIP-2535 diamond standard.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/arcadiaDiamonds/whitelist/WhitelistFacet.sol\":\"WhitelistFacet\"},\"evmVersion\":\"paris\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x00000000d41867734bbee4c6863d9255b2b06ac1\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":250},\"remappings\":[]},\"sources\":{\"@solidstate/contracts/access/access_control/AccessControlInternal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\\nimport { UintUtils } from '../../utils/UintUtils.sol';\\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\\nimport { AccessControlStorage } from './AccessControlStorage.sol';\\n\\n/**\\n * @title Role-based access control system\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nabstract contract AccessControlInternal is IAccessControlInternal {\\n    using AddressUtils for address;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using UintUtils for uint256;\\n\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /*\\n     * @notice query whether role is assigned to account\\n     * @param role role to query\\n     * @param account account to query\\n     * @return whether role is assigned to account\\n     */\\n    function _hasRole(\\n        bytes32 role,\\n        address account\\n    ) internal view virtual returns (bool) {\\n        return\\n            AccessControlStorage.layout().roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @notice revert if sender does not have given role\\n     * @param role role to query\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, msg.sender);\\n    }\\n\\n    /**\\n     * @notice revert if given account does not have given role\\n     * @param role role to query\\n     * @param account to query\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!_hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        'AccessControl: account ',\\n                        account.toString(),\\n                        ' is missing role ',\\n                        uint256(role).toHexString(32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /*\\n     * @notice query admin role for given role\\n     * @param role role to query\\n     * @return admin role\\n     */\\n    function _getRoleAdmin(\\n        bytes32 role\\n    ) internal view virtual returns (bytes32) {\\n        return AccessControlStorage.layout().roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @notice set role as admin role\\n     * @param role role to set\\n     * @param adminRole admin role to set\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = _getRoleAdmin(role);\\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /*\\n     * @notice assign role to given account\\n     * @param role role to assign\\n     * @param account recipient of role assignment\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        AccessControlStorage.layout().roles[role].members.add(account);\\n        emit RoleGranted(role, account, msg.sender);\\n    }\\n\\n    /*\\n     * @notice unassign role from given account\\n     * @param role role to unassign\\n     * @parm account\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        AccessControlStorage.layout().roles[role].members.remove(account);\\n        emit RoleRevoked(role, account, msg.sender);\\n    }\\n\\n    /**\\n     * @notice relinquish role\\n     * @param role role to relinquish\\n     */\\n    function _renounceRole(bytes32 role) internal virtual {\\n        _revokeRole(role, msg.sender);\\n    }\\n}\\n\",\"keccak256\":\"0x5c32c5b490b9a2dd9daa533a75f940f0b0f69c9033776f5e274cd2446c224513\",\"license\":\"MIT\"},\"@solidstate/contracts/access/access_control/AccessControlStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\\n\\nlibrary AccessControlStorage {\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    struct Layout {\\n        mapping(bytes32 => RoleData) roles;\\n    }\\n\\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.AccessControl');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xae788d37a6e20edf7f94be23d78517324f50bccbf0541e10ce0850d7d5bca062\",\"license\":\"MIT\"},\"@solidstate/contracts/access/access_control/IAccessControlInternal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial AccessControl interface needed by internal functions\\n */\\ninterface IAccessControlInternal {\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n}\\n\",\"keccak256\":\"0xcc4a1d78a60955d673104adaee1211de3b3cfb95668f1fbfc43ed0e7f36ad110\",\"license\":\"MIT\"},\"@solidstate/contracts/data/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n    error EnumerableSet__IndexOutOfBounds();\\n\\n    struct Set {\\n        bytes32[] _values;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function at(\\n        Bytes32Set storage set,\\n        uint256 index\\n    ) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    function at(\\n        AddressSet storage set,\\n        uint256 index\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function at(\\n        UintSet storage set,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function contains(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function contains(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function indexOf(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, value);\\n    }\\n\\n    function indexOf(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function indexOf(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(value));\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function add(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    function add(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function remove(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function toArray(\\n        Bytes32Set storage set\\n    ) internal view returns (bytes32[] memory) {\\n        return set._inner._values;\\n    }\\n\\n    function toArray(\\n        AddressSet storage set\\n    ) internal view returns (address[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        address[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function toArray(\\n        UintSet storage set\\n    ) internal view returns (uint256[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        uint256[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function _at(\\n        Set storage set,\\n        uint256 index\\n    ) private view returns (bytes32) {\\n        if (index >= set._values.length)\\n            revert EnumerableSet__IndexOutOfBounds();\\n        return set._values[index];\\n    }\\n\\n    function _contains(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _indexOf(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (uint256) {\\n        unchecked {\\n            return set._indexes[value] - 1;\\n        }\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _add(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            status = true;\\n        }\\n    }\\n\\n    function _remove(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            unchecked {\\n                bytes32 last = set._values[set._values.length - 1];\\n\\n                // move last value to now-vacant index\\n\\n                set._values[valueIndex - 1] = last;\\n                set._indexes[last] = valueIndex;\\n            }\\n            // clear last index\\n\\n            set._values.pop();\\n            delete set._indexes[value];\\n\\n            status = true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbbaaeb805b3e1e704ceba33c9093285220254b1ff6b4b7f577e515b118e116f6\",\"license\":\"MIT\"},\"@solidstate/contracts/utils/AddressUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { UintUtils } from './UintUtils.sol';\\n\\nlibrary AddressUtils {\\n    using UintUtils for uint256;\\n\\n    error AddressUtils__InsufficientBalance();\\n    error AddressUtils__NotContract();\\n    error AddressUtils__SendValueFailed();\\n\\n    function toString(address account) internal pure returns (string memory) {\\n        return uint256(uint160(account)).toHexString(20);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        if (!success) revert AddressUtils__SendValueFailed();\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        if (value > address(this).balance)\\n            revert AddressUtils__InsufficientBalance();\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    /**\\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\\n     * @param target recipient of call\\n     * @param gasAmount gas allowance for call\\n     * @param value native token value to include in call\\n     * @param maxCopy maximum number of bytes to copy from return data\\n     * @param data encoded call data\\n     * @return success whether call is successful\\n     * @return returnData copied return data\\n     */\\n    function excessivelySafeCall(\\n        address target,\\n        uint256 gasAmount,\\n        uint256 value,\\n        uint16 maxCopy,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        returnData = new bytes(maxCopy);\\n\\n        assembly {\\n            // execute external call via assembly to avoid automatic copying of return data\\n            success := call(\\n                gasAmount,\\n                target,\\n                value,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0\\n            )\\n\\n            // determine whether to limit amount of data to copy\\n            let toCopy := returndatasize()\\n\\n            if gt(toCopy, maxCopy) {\\n                toCopy := maxCopy\\n            }\\n\\n            // store the length of the copied bytes\\n            mstore(returnData, toCopy)\\n\\n            // copy the bytes from returndata[0:toCopy]\\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\\n        }\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        if (!isContract(target)) revert AddressUtils__NotContract();\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7d924db4dbd9210923ab08db77db3c77438014c255fd49fa208ebce283d991bf\",\"license\":\"MIT\"},\"@solidstate/contracts/utils/UintUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title utility functions for uint256 operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary UintUtils {\\n    error UintUtils__InsufficientHexLength();\\n\\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\\n\\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? sub(a, -b) : a + uint256(b);\\n    }\\n\\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? add(a, -b) : a - uint256(b);\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0';\\n        }\\n\\n        uint256 temp = value;\\n        uint256 digits;\\n\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        bytes memory buffer = new bytes(digits);\\n\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0x00';\\n        }\\n\\n        uint256 length = 0;\\n\\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\\n            unchecked {\\n                length++;\\n            }\\n        }\\n\\n        return toHexString(value, length);\\n    }\\n\\n    function toHexString(\\n        uint256 value,\\n        uint256 length\\n    ) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = '0';\\n        buffer[1] = 'x';\\n\\n        unchecked {\\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\\n                value >>= 4;\\n            }\\n        }\\n\\n        if (value != 0) revert UintUtils__InsufficientHexLength();\\n\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x5aaeaea22a0800402c6f2d8ce6185293bc64f74f6c390c1b1c53b624b43972f8\",\"license\":\"MIT\"},\"contracts/arcadiaDiamonds/roles/RolesInternal.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport { AccessControlInternal } from \\\"@solidstate/contracts/access/access_control/AccessControlInternal.sol\\\";\\nimport { AccessControlStorage } from \\\"@solidstate/contracts/access/access_control/AccessControlStorage.sol\\\";\\nimport { RolesStorage } from './RolesStorage.sol';\\n\\ncontract RolesInternal is AccessControlInternal {\\n\\n    modifier onlyDefaultAdmin() {\\n        _checkRole(_defaultAdminRole());\\n        _;\\n    }\\n\\n    modifier onlyManager() {\\n        _checkRole(_managerRole());\\n        _;\\n    }\\n\\n    modifier onlyMinter() {\\n        _checkRole(_minterRole());\\n        _;\\n    }\\n\\n    function _defaultAdminRole() internal pure returns (bytes32) {\\n        return AccessControlStorage.DEFAULT_ADMIN_ROLE;\\n    }\\n\\n    function _managerRole() internal view returns (bytes32) {\\n        return RolesStorage.layout().managerRole;\\n    }\\n\\n    function _minterRole() internal view returns (bytes32) {\\n        return RolesStorage.layout().minterRole;\\n    }\\n\\n    function _initRoles() internal {\\n        RolesStorage.Layout storage rolesSL = RolesStorage.layout();\\n        rolesSL.managerRole = keccak256(\\\"manager.role\\\");\\n        rolesSL.minterRole = keccak256(\\\"minter.role\\\");\\n\\n        _grantRole(_defaultAdminRole(), msg.sender);\\n        _grantRole(_managerRole(), msg.sender);\\n        _grantRole(_minterRole(), msg.sender);\\n    }\\n}\",\"keccak256\":\"0xd3fa8bcc9380c117c2e22aeb6b4489ad01c31433b3c2d412742b681c94cf407d\",\"license\":\"UNLICENSED\"},\"contracts/arcadiaDiamonds/roles/RolesStorage.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nlibrary RolesStorage {\\n\\n    bytes32 constant ROLES_STORAGE_POSITION =\\n        keccak256(\\\"roles.storage.position\\\");\\n\\n    struct Layout {\\n        bytes32 managerRole;\\n        bytes32 minterRole;\\n    }\\n\\n    function layout()\\n        internal\\n        pure\\n        returns (Layout storage es)\\n    {\\n        bytes32 position = ROLES_STORAGE_POSITION;\\n        assembly {\\n            es.slot := position\\n        }\\n    }\\n}\",\"keccak256\":\"0x203cfbe268a1ac5fe32593c66ace04b576dfb2e25173e02654e504cf0de44d71\",\"license\":\"UNLICENSED\"},\"contracts/arcadiaDiamonds/whitelist/WhitelistFacet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport { WhitelistInternal } from './WhitelistInternal.sol';\\n\\n/**\\n * @title WhitelistFacet\\n * @notice This contract allows the admins to whitelist an address with a specific amount,\\n * which can then be used to claim tokens in other contracts.\\n * To consume the whitelist, the token contracts should call the internal functions from WhitelistInternal.\\n * This contract can be used as a facet of a diamond which follows the EIP-2535 diamond standard.\\n */\\ncontract WhitelistFacet is WhitelistInternal {\\n\\n    /**\\n     * @notice Returns the amount claimed by a whitelisted account\\n     * @param account The address of the account to query\\n     * @return The amount claimed by the account\\n     */\\n    function claimedWhitelist(address account) external view returns (uint) {\\n        return _claimedWhitelist(account);\\n    }\\n\\n    /**\\n     * @notice Returns the remaining elegible amount for a whitelisted account\\n     * @param account The address of the account to query\\n     * @return The elegible amount of the account\\n     */\\n    function elegibleWhitelist(address account) external view returns (uint) {\\n        return _elegibleWhitelist(account);\\n    }\\n    \\n    /**\\n     * @notice Returns the total claimed amount\\n     * @return The total claimed amount\\n     */\\n    function totalClaimedWhitelist() external view returns (uint) {\\n        return _totalClaimedWhitelist();\\n    }\\n    \\n    /**\\n     * @notice Returns the total elegible amount\\n     * @return The total elegible amount\\n     */\\n    function totalElegibleWhitelist() external view returns (uint) {\\n        return _totalElegibleWhitelist();\\n    }\\n\\n    /**\\n     * @notice Increase the whitelist elegible amount for an address\\n     * @dev This function can only be called by an address with the manager role\\n     * @param account The address to add to the whitelist\\n     * @param amount The amount to whitelist for the address\\n     */\\n    function increaseWhitelistElegible(address account, uint amount) onlyManager external {\\n        _increaseWhitelistElegible(account, amount);\\n    }\\n\\n    /**\\n     * @notice Increase the whitelist elegible amounts for multiple addresses\\n     * @dev This function can only be called by an address with the manager role\\n     * @param accounts An array of addresses to add to the whitelist\\n     * @param amounts An array of amounts to whitelist for each address\\n     */\\n    function increaseWhitelistElegibleBatch(address[] calldata accounts, uint[] calldata amounts) external onlyManager {\\n        _increaseWhitelistElegibleBatch(accounts, amounts);\\n    }\\n\\n    /**\\n     * @notice Adds a new address to the whitelist with a specific amount\\n     * @dev This function can only be called by an address with the manager role\\n     * @param account The address to add to the whitelist\\n     * @param totalAmount The amount to whitelist for the address\\n     */\\n    function setWhitelistElegible(address account, uint totalAmount) onlyManager external {\\n        _setWhitelistElegible(account, totalAmount);\\n    }\\n\\n    /**\\n     * @notice Adds multiple addresses to the whitelist with specific amounts\\n     * @dev This function can only be called by an address with the manager role\\n     * @param accounts An array of addresses to add to the whitelist\\n     * @param totalAmounts An array of amounts to whitelist for each address\\n     */\\n    function setWhitelistElegibleBatch(address[] calldata accounts, uint[] calldata totalAmounts) external onlyManager {\\n        _setWhitelistElegibleBatch(accounts, totalAmounts);\\n    }\\n\\n    /**\\n     * @notice Updates the claim state to active and enables the claim of tokens\\n     * @dev This function can only be called by an address with the manager role\\n     */\\n    function setWhitelistClaimActive() external onlyManager {\\n        _setWhitelistClaimActive();\\n    }\\n\\n    /**\\n     * @notice Updates the claim state to inactive and disables the claim of tokens\\n     * @dev This function can only be called by an address with the manager role\\n     */\\n    function setWhitelistClaimInactive() external onlyManager {\\n        _setWhitelistClaimInactive();\\n    }\\n\\n    /**\\n     * @notice Returns true if elegible tokens can be claimed, or false otherwise\\n     * @return active bool indicating if claim is active\\n     */\\n    function isWhitelistClaimActive() view external returns (bool active) {\\n        return _isWhitelistClaimActive();\\n    }\\n}\",\"keccak256\":\"0x9ea6c3b1193924e2f07351e3ef8612cd19c233a40e857dd57c902bcf47a51828\",\"license\":\"UNLICENSED\"},\"contracts/arcadiaDiamonds/whitelist/WhitelistInternal.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport { WhitelistStorage } from \\\"./WhitelistStorage.sol\\\";\\nimport { RolesInternal } from \\\"./../roles/RolesInternal.sol\\\";\\n\\ncontract WhitelistInternal is RolesInternal {\\n\\n    error Whitelist_ExceedsElegibleAmount();\\n    error Whitelist_InputDataMismatch();\\n    error Whitelist_ClaimStateAlreadyUpdated();\\n    error Whitelist_ClaimInactive();\\n\\n    event WhitelistBalanceChanged(address account, uint totalElegibleAmount, uint totalClaimedAmount);\\n\\n    function _claimedWhitelist(address account) internal view returns (uint) {\\n        return WhitelistStorage.layout().claimed[account];\\n    }\\n\\n    function _totalClaimedWhitelist() internal view returns (uint) {\\n        return WhitelistStorage.layout().totalClaimed;\\n    }\\n\\n    function _totalElegibleWhitelist() internal view returns (uint) {\\n        return WhitelistStorage.layout().totalElegible;\\n    }\\n\\n    function _elegibleWhitelist(address account) internal view returns (uint) {\\n        return WhitelistStorage.layout().elegible[account];\\n    }\\n\\n    function _consumeWhitelist(address account, uint amount) internal {\\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\\n\\n        if (whitelistSL.claimInactive) \\n            revert Whitelist_ClaimInactive();\\n            \\n        if (whitelistSL.elegible[account] < amount) \\n            revert Whitelist_ExceedsElegibleAmount();\\n\\n        whitelistSL.elegible[account] -= amount;\\n        whitelistSL.claimed[account] += amount;\\n        whitelistSL.totalClaimed += amount;\\n        whitelistSL.totalElegible -= amount;\\n\\n        emit WhitelistBalanceChanged(msg.sender, whitelistSL.elegible[account], whitelistSL.claimed[account]);\\n    }\\n\\n    function _increaseWhitelistElegible(address account, uint amount) internal {\\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\\n        whitelistSL.elegible[account] += amount;\\n        whitelistSL.totalElegible += amount;\\n        \\n        emit WhitelistBalanceChanged(msg.sender, whitelistSL.elegible[account], whitelistSL.claimed[account]);\\n    }\\n\\n    function _increaseWhitelistElegibleBatch(address[] calldata accounts, uint[] calldata amounts) internal {\\n        if (accounts.length != amounts.length) revert Whitelist_InputDataMismatch();\\n\\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\\n\\n        for (uint i = 0; i < accounts.length; i++) {\\n            whitelistSL.elegible[accounts[i]] += amounts[i];\\n            whitelistSL.totalElegible += amounts[i];\\n            emit WhitelistBalanceChanged(msg.sender, whitelistSL.elegible[accounts[i]], whitelistSL.claimed[accounts[i]]);\\n        }\\n    }\\n\\n    function _setWhitelistElegible(address account, uint amount) internal {\\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\\n        whitelistSL.totalElegible += amount - whitelistSL.elegible[account];\\n        whitelistSL.elegible[account] += amount;\\n        emit WhitelistBalanceChanged(msg.sender, whitelistSL.elegible[account], whitelistSL.claimed[account]);\\n    }\\n\\n    function _setWhitelistElegibleBatch(address[] calldata accounts, uint[] calldata amounts) internal {\\n        if (accounts.length != amounts.length) revert Whitelist_InputDataMismatch();\\n\\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\\n\\n        for (uint i = 0; i < accounts.length; i++) {\\n            whitelistSL.totalElegible += amounts[i] - whitelistSL.elegible[accounts[i]];\\n            whitelistSL.elegible[accounts[i]] = amounts[i];\\n            emit WhitelistBalanceChanged(msg.sender, whitelistSL.elegible[accounts[i]], whitelistSL.claimed[accounts[i]]);\\n        }\\n    }\\n\\n    function _isWhitelistClaimActive() view internal returns (bool) {\\n        return !WhitelistStorage.layout().claimInactive;\\n    }\\n\\n    function _setWhitelistClaimActive() internal {\\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\\n\\n        if (!whitelistSL.claimInactive) revert Whitelist_ClaimInactive();\\n        \\n        whitelistSL.claimInactive = false;\\n    }\\n\\n    function _setWhitelistClaimInactive() internal {\\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\\n\\n        if (whitelistSL.claimInactive) revert Whitelist_ClaimStateAlreadyUpdated();\\n        \\n        whitelistSL.claimInactive = true;\\n    }\\n}\",\"keccak256\":\"0xa95506abee2b3d2771409fe46bde335ece932dd12f68efac201107d81b633d21\",\"license\":\"UNLICENSED\"},\"contracts/arcadiaDiamonds/whitelist/WhitelistStorage.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nlibrary WhitelistStorage {\\n\\n    bytes32 constant WHITELIST_STORAGE_POSITION =\\n        keccak256(\\\"whitelist.storage.position\\\");\\n\\n    struct Layout {\\n        mapping(address => uint) claimed;\\n        mapping(address => uint) elegible;\\n        uint totalClaimed;\\n        uint totalElegible;\\n        bool claimInactive;\\n    }\\n\\n    function layout()\\n        internal\\n        pure\\n        returns (Layout storage es)\\n    {\\n        bytes32 position = WHITELIST_STORAGE_POSITION;\\n        assembly {\\n            es.slot := position\\n        }\\n    }\\n}\",\"keccak256\":\"0x8bed7d61825172b06144337fecf4363c753829dbeddfa65a2e612c84d7a2aaa7\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610e99806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c80635efec59a116100715780635efec59a1461010c5780636f8363fc1461011f578063ae97b54a14610127578063d328d3cb1461013a578063f12b812f14610152578063ffa603231461015a57600080fd5b806319509de1146100ae5780631edf71f1146100c95780632f486ff0146100de57806330c4486f146100e65780634c237daf146100f9575b600080fd5b6100b661016d565b6040519081526020015b60405180910390f35b6100dc6100d7366004610bc2565b61019c565b005b6100dc6101c8565b6100dc6100f4366004610bc2565b6101eb565b6100b6610107366004610bec565b61020e565b6100b661011a366004610bec565b61024d565b6100dc610278565b6100dc610135366004610c53565b610299565b6101426102c4565b60405190151581526020016100c0565b6100b66102f2565b6100dc610168366004610c53565b61031c565b60006101977ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358b5490565b905090565b6101ba6101b5600080516020610e248339815191525490565b610341565b6101c4828261034e565b5050565b6101e16101b5600080516020610e248339815191525490565b6101e961042f565b565b6102046101b5600080516020610e248339815191525490565b6101c4828261048e565b6001600160a01b03811660009081527ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358960205260408120545b92915050565b6001600160a01b0381166000908152600080516020610e448339815191526020526040812054610247565b6102916101b5600080516020610e248339815191525490565b6101e9610522565b6102b26101b5600080516020610e248339815191525490565b6102be84848484610585565b50505050565b60006101977ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358c5460ff161590565b60006101977ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358a5490565b6103356101b5600080516020610e248339815191525490565b6102be84848484610760565b61034b813361097a565b50565b6001600160a01b03821660009081527ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb3589602052604081208054600080516020610e44833981519152928492916103a5908490610cd5565b92505081905550818160030160008282546103c09190610cd5565b90915550506001600160a01b038316600090815260018201602090815260408083205484835292819020548151338152928301939093528101919091527fc7ba59c487358e9747ee9c691c213a9b2d30e01bb1b022a3e11d4b1984cd98459060600160405180910390a1505050565b7ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358c54600080516020610e448339815191529060ff1661048157604051633137c0e960e11b815260040160405180910390fd5b600401805460ff19169055565b6001600160a01b03821660009081527ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb35896020526040902054600080516020610e44833981519152906104e09083610ce8565b8160030160008282546104f39190610cd5565b90915550506001600160a01b0383166000908152600182016020526040812080548492906103c0908490610cd5565b7ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358c54600080516020610e448339815191529060ff161561057557604051634151cc7b60e01b815260040160405180910390fd5b600401805460ff19166001179055565b8281146105a5576040516311bb761360e01b815260040160405180910390fd5b600080516020610e4483398151915260005b84811015610758578383828181106105d1576105d1610cfb565b905060200201358260010160008888858181106105f0576105f0610cfb565b90506020020160208101906106059190610bec565b6001600160a01b03166001600160a01b0316815260200190815260200160002060008282546106349190610cd5565b90915550849050838281811061064c5761064c610cfb565b905060200201358260030160008282546106669190610cd5565b909155507fc7ba59c487358e9747ee9c691c213a9b2d30e01bb1b022a3e11d4b1984cd98459050336001840160008989868181106106a6576106a6610cfb565b90506020020160208101906106bb9190610bec565b6001600160a01b03166001600160a01b03168152602001908152602001600020548460000160008a8a878181106106f4576106f4610cfb565b90506020020160208101906107099190610bec565b6001600160a01b0390811682526020808301939093526040918201600020548251959091168552918401929092529082015260600160405180910390a18061075081610d11565b9150506105b7565b505050505050565b828114610780576040516311bb761360e01b815260040160405180910390fd5b600080516020610e4483398151915260005b84811015610758578160010160008787848181106107b2576107b2610cfb565b90506020020160208101906107c79190610bec565b6001600160a01b03166001600160a01b03168152602001908152602001600020548484838181106107fa576107fa610cfb565b9050602002013561080b9190610ce8565b82600301600082825461081e9190610cd5565b90915550849050838281811061083657610836610cfb565b9050602002013582600101600088888581811061085557610855610cfb565b905060200201602081019061086a9190610bec565b6001600160a01b03166001600160a01b03168152602001908152602001600020819055507fc7ba59c487358e9747ee9c691c213a9b2d30e01bb1b022a3e11d4b1984cd9845338360010160008989868181106108c8576108c8610cfb565b90506020020160208101906108dd9190610bec565b6001600160a01b03166001600160a01b03168152602001908152602001600020548460000160008a8a8781811061091657610916610cfb565b905060200201602081019061092b9190610bec565b6001600160a01b0390811682526020808301939093526040918201600020548251959091168552918401929092529082015260600160405180910390a18061097281610d11565b915050610792565b61098482826109e5565b6101c45761099a816001600160a01b0316610a41565b6109a5836020610a53565b6040516020016109b6929190610d4e565b60408051601f198184030181529082905262461bcd60e51b82526109dc91600401610dc3565b60405180910390fd5b6000610a3a827fd3889cc5458b268d0544e5534672df1296288ca3f93cbd39bd6f497a5c622811600086815260209190915260409020906001600160a01b038116600090815260018301602052604081205415155b9392505050565b60606102476001600160a01b03831660145b60606000610a62836002610df6565b610a6d906002610cd5565b67ffffffffffffffff811115610a8557610a85610e0d565b6040519080825280601f01601f191660200182016040528015610aaf576020820181803683370190505b509050600360fc1b81600081518110610aca57610aca610cfb565b60200101906001600160f81b031916908160001a905350600f60fb1b81600181518110610af957610af9610cfb565b60200101906001600160f81b031916908160001a905350600160028402015b6001811115610b86576f181899199a1a9b1b9c1cb0b131b232b360811b85600f1660108110610b4957610b49610cfb565b1a60f81b828281518110610b5f57610b5f610cfb565b60200101906001600160f81b031916908160001a90535060049490941c9360001901610b18565b508315610a3a5760405163c913478560e01b815260040160405180910390fd5b80356001600160a01b0381168114610bbd57600080fd5b919050565b60008060408385031215610bd557600080fd5b610bde83610ba6565b946020939093013593505050565b600060208284031215610bfe57600080fd5b610a3a82610ba6565b60008083601f840112610c1957600080fd5b50813567ffffffffffffffff811115610c3157600080fd5b6020830191508360208260051b8501011115610c4c57600080fd5b9250929050565b60008060008060408587031215610c6957600080fd5b843567ffffffffffffffff80821115610c8157600080fd5b610c8d88838901610c07565b90965094506020870135915080821115610ca657600080fd5b50610cb387828801610c07565b95989497509550505050565b634e487b7160e01b600052601160045260246000fd5b8082018082111561024757610247610cbf565b8181038181111561024757610247610cbf565b634e487b7160e01b600052603260045260246000fd5b600060018201610d2357610d23610cbf565b5060010190565b60005b83811015610d45578181015183820152602001610d2d565b50506000910152565b7f416363657373436f6e74726f6c3a206163636f756e7420000000000000000000815260008351610d86816017850160208801610d2a565b7001034b99036b4b9b9b4b733903937b6329607d1b6017918401918201528351610db7816028840160208801610d2a565b01602801949350505050565b6020815260008251806020840152610de2816040850160208701610d2a565b601f01601f19169190910160400192915050565b808202811582820484141761024757610247610cbf565b634e487b7160e01b600052604160045260246000fdfef6deb63e40d71b08820818e006e23fcceb1fce7a499bc15b71b2526cbf9efa72f38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb3588a264697066735822122041ade4007d17df95ca0862328702dec90e3a02355e124ce9a2ff5b7e9df01e4864736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100a95760003560e01c80635efec59a116100715780635efec59a1461010c5780636f8363fc1461011f578063ae97b54a14610127578063d328d3cb1461013a578063f12b812f14610152578063ffa603231461015a57600080fd5b806319509de1146100ae5780631edf71f1146100c95780632f486ff0146100de57806330c4486f146100e65780634c237daf146100f9575b600080fd5b6100b661016d565b6040519081526020015b60405180910390f35b6100dc6100d7366004610bc2565b61019c565b005b6100dc6101c8565b6100dc6100f4366004610bc2565b6101eb565b6100b6610107366004610bec565b61020e565b6100b661011a366004610bec565b61024d565b6100dc610278565b6100dc610135366004610c53565b610299565b6101426102c4565b60405190151581526020016100c0565b6100b66102f2565b6100dc610168366004610c53565b61031c565b60006101977ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358b5490565b905090565b6101ba6101b5600080516020610e248339815191525490565b610341565b6101c4828261034e565b5050565b6101e16101b5600080516020610e248339815191525490565b6101e961042f565b565b6102046101b5600080516020610e248339815191525490565b6101c4828261048e565b6001600160a01b03811660009081527ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358960205260408120545b92915050565b6001600160a01b0381166000908152600080516020610e448339815191526020526040812054610247565b6102916101b5600080516020610e248339815191525490565b6101e9610522565b6102b26101b5600080516020610e248339815191525490565b6102be84848484610585565b50505050565b60006101977ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358c5460ff161590565b60006101977ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358a5490565b6103356101b5600080516020610e248339815191525490565b6102be84848484610760565b61034b813361097a565b50565b6001600160a01b03821660009081527ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb3589602052604081208054600080516020610e44833981519152928492916103a5908490610cd5565b92505081905550818160030160008282546103c09190610cd5565b90915550506001600160a01b038316600090815260018201602090815260408083205484835292819020548151338152928301939093528101919091527fc7ba59c487358e9747ee9c691c213a9b2d30e01bb1b022a3e11d4b1984cd98459060600160405180910390a1505050565b7ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358c54600080516020610e448339815191529060ff1661048157604051633137c0e960e11b815260040160405180910390fd5b600401805460ff19169055565b6001600160a01b03821660009081527ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb35896020526040902054600080516020610e44833981519152906104e09083610ce8565b8160030160008282546104f39190610cd5565b90915550506001600160a01b0383166000908152600182016020526040812080548492906103c0908490610cd5565b7ff38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb358c54600080516020610e448339815191529060ff161561057557604051634151cc7b60e01b815260040160405180910390fd5b600401805460ff19166001179055565b8281146105a5576040516311bb761360e01b815260040160405180910390fd5b600080516020610e4483398151915260005b84811015610758578383828181106105d1576105d1610cfb565b905060200201358260010160008888858181106105f0576105f0610cfb565b90506020020160208101906106059190610bec565b6001600160a01b03166001600160a01b0316815260200190815260200160002060008282546106349190610cd5565b90915550849050838281811061064c5761064c610cfb565b905060200201358260030160008282546106669190610cd5565b909155507fc7ba59c487358e9747ee9c691c213a9b2d30e01bb1b022a3e11d4b1984cd98459050336001840160008989868181106106a6576106a6610cfb565b90506020020160208101906106bb9190610bec565b6001600160a01b03166001600160a01b03168152602001908152602001600020548460000160008a8a878181106106f4576106f4610cfb565b90506020020160208101906107099190610bec565b6001600160a01b0390811682526020808301939093526040918201600020548251959091168552918401929092529082015260600160405180910390a18061075081610d11565b9150506105b7565b505050505050565b828114610780576040516311bb761360e01b815260040160405180910390fd5b600080516020610e4483398151915260005b84811015610758578160010160008787848181106107b2576107b2610cfb565b90506020020160208101906107c79190610bec565b6001600160a01b03166001600160a01b03168152602001908152602001600020548484838181106107fa576107fa610cfb565b9050602002013561080b9190610ce8565b82600301600082825461081e9190610cd5565b90915550849050838281811061083657610836610cfb565b9050602002013582600101600088888581811061085557610855610cfb565b905060200201602081019061086a9190610bec565b6001600160a01b03166001600160a01b03168152602001908152602001600020819055507fc7ba59c487358e9747ee9c691c213a9b2d30e01bb1b022a3e11d4b1984cd9845338360010160008989868181106108c8576108c8610cfb565b90506020020160208101906108dd9190610bec565b6001600160a01b03166001600160a01b03168152602001908152602001600020548460000160008a8a8781811061091657610916610cfb565b905060200201602081019061092b9190610bec565b6001600160a01b0390811682526020808301939093526040918201600020548251959091168552918401929092529082015260600160405180910390a18061097281610d11565b915050610792565b61098482826109e5565b6101c45761099a816001600160a01b0316610a41565b6109a5836020610a53565b6040516020016109b6929190610d4e565b60408051601f198184030181529082905262461bcd60e51b82526109dc91600401610dc3565b60405180910390fd5b6000610a3a827fd3889cc5458b268d0544e5534672df1296288ca3f93cbd39bd6f497a5c622811600086815260209190915260409020906001600160a01b038116600090815260018301602052604081205415155b9392505050565b60606102476001600160a01b03831660145b60606000610a62836002610df6565b610a6d906002610cd5565b67ffffffffffffffff811115610a8557610a85610e0d565b6040519080825280601f01601f191660200182016040528015610aaf576020820181803683370190505b509050600360fc1b81600081518110610aca57610aca610cfb565b60200101906001600160f81b031916908160001a905350600f60fb1b81600181518110610af957610af9610cfb565b60200101906001600160f81b031916908160001a905350600160028402015b6001811115610b86576f181899199a1a9b1b9c1cb0b131b232b360811b85600f1660108110610b4957610b49610cfb565b1a60f81b828281518110610b5f57610b5f610cfb565b60200101906001600160f81b031916908160001a90535060049490941c9360001901610b18565b508315610a3a5760405163c913478560e01b815260040160405180910390fd5b80356001600160a01b0381168114610bbd57600080fd5b919050565b60008060408385031215610bd557600080fd5b610bde83610ba6565b946020939093013593505050565b600060208284031215610bfe57600080fd5b610a3a82610ba6565b60008083601f840112610c1957600080fd5b50813567ffffffffffffffff811115610c3157600080fd5b6020830191508360208260051b8501011115610c4c57600080fd5b9250929050565b60008060008060408587031215610c6957600080fd5b843567ffffffffffffffff80821115610c8157600080fd5b610c8d88838901610c07565b90965094506020870135915080821115610ca657600080fd5b50610cb387828801610c07565b95989497509550505050565b634e487b7160e01b600052601160045260246000fd5b8082018082111561024757610247610cbf565b8181038181111561024757610247610cbf565b634e487b7160e01b600052603260045260246000fd5b600060018201610d2357610d23610cbf565b5060010190565b60005b83811015610d45578181015183820152602001610d2d565b50506000910152565b7f416363657373436f6e74726f6c3a206163636f756e7420000000000000000000815260008351610d86816017850160208801610d2a565b7001034b99036b4b9b9b4b733903937b6329607d1b6017918401918201528351610db7816028840160208801610d2a565b01602801949350505050565b6020815260008251806020840152610de2816040850160208701610d2a565b601f01601f19169190910160400192915050565b808202811582820484141761024757610247610cbf565b634e487b7160e01b600052604160045260246000fdfef6deb63e40d71b08820818e006e23fcceb1fce7a499bc15b71b2526cbf9efa72f38d3885e664c9638de25f02e645e1955ebebe901d7be2c2037db6a5bcbb3588a264697066735822122041ade4007d17df95ca0862328702dec90e3a02355e124ce9a2ff5b7e9df01e4864736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "claimedWhitelist(address)": {
        "params": {
          "account": "The address of the account to query"
        },
        "returns": {
          "_0": "The amount claimed by the account"
        }
      },
      "elegibleWhitelist(address)": {
        "params": {
          "account": "The address of the account to query"
        },
        "returns": {
          "_0": "The elegible amount of the account"
        }
      },
      "increaseWhitelistElegible(address,uint256)": {
        "details": "This function can only be called by an address with the manager role",
        "params": {
          "account": "The address to add to the whitelist",
          "amount": "The amount to whitelist for the address"
        }
      },
      "increaseWhitelistElegibleBatch(address[],uint256[])": {
        "details": "This function can only be called by an address with the manager role",
        "params": {
          "accounts": "An array of addresses to add to the whitelist",
          "amounts": "An array of amounts to whitelist for each address"
        }
      },
      "isWhitelistClaimActive()": {
        "returns": {
          "active": "bool indicating if claim is active"
        }
      },
      "setWhitelistClaimActive()": {
        "details": "This function can only be called by an address with the manager role"
      },
      "setWhitelistClaimInactive()": {
        "details": "This function can only be called by an address with the manager role"
      },
      "setWhitelistElegible(address,uint256)": {
        "details": "This function can only be called by an address with the manager role",
        "params": {
          "account": "The address to add to the whitelist",
          "totalAmount": "The amount to whitelist for the address"
        }
      },
      "setWhitelistElegibleBatch(address[],uint256[])": {
        "details": "This function can only be called by an address with the manager role",
        "params": {
          "accounts": "An array of addresses to add to the whitelist",
          "totalAmounts": "An array of amounts to whitelist for each address"
        }
      },
      "totalClaimedWhitelist()": {
        "returns": {
          "_0": "The total claimed amount"
        }
      },
      "totalElegibleWhitelist()": {
        "returns": {
          "_0": "The total elegible amount"
        }
      }
    },
    "title": "WhitelistFacet",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "claimedWhitelist(address)": {
        "notice": "Returns the amount claimed by a whitelisted account"
      },
      "elegibleWhitelist(address)": {
        "notice": "Returns the remaining elegible amount for a whitelisted account"
      },
      "increaseWhitelistElegible(address,uint256)": {
        "notice": "Increase the whitelist elegible amount for an address"
      },
      "increaseWhitelistElegibleBatch(address[],uint256[])": {
        "notice": "Increase the whitelist elegible amounts for multiple addresses"
      },
      "isWhitelistClaimActive()": {
        "notice": "Returns true if elegible tokens can be claimed, or false otherwise"
      },
      "setWhitelistClaimActive()": {
        "notice": "Updates the claim state to active and enables the claim of tokens"
      },
      "setWhitelistClaimInactive()": {
        "notice": "Updates the claim state to inactive and disables the claim of tokens"
      },
      "setWhitelistElegible(address,uint256)": {
        "notice": "Adds a new address to the whitelist with a specific amount"
      },
      "setWhitelistElegibleBatch(address[],uint256[])": {
        "notice": "Adds multiple addresses to the whitelist with specific amounts"
      },
      "totalClaimedWhitelist()": {
        "notice": "Returns the total claimed amount"
      },
      "totalElegibleWhitelist()": {
        "notice": "Returns the total elegible amount"
      }
    },
    "notice": "This contract allows the admins to whitelist an address with a specific amount, which can then be used to claim tokens in other contracts. To consume the whitelist, the token contracts should call the internal functions from WhitelistInternal. This contract can be used as a facet of a diamond which follows the EIP-2535 diamond standard.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}