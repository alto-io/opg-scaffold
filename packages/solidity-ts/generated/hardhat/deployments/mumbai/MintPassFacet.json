{
  "address": "0x0E3511464BF922756651C82a2c1053A303e72DE7",
  "abi": [
    {
      "inputs": [],
      "name": "MintPass_ClaimInactive",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Roles_MissingAdminRole",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Roles_MissingAutomationRole",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Roles_MissingManagerRole",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "MintPassConsumed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "previousAdminRole",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "newAdminRole",
          "type": "bytes32"
        }
      ],
      "name": "RoleAdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleGranted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleRevoked",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "claimedMintPass",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "elegibleMintPass",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isMintPassClaimActive",
      "outputs": [
        {
          "internalType": "bool",
          "name": "active",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "isTokenClaimed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "mintPassContractAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "active",
          "type": "bool"
        }
      ],
      "name": "setClaimActiveMintPass",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "passContractAddress",
          "type": "address"
        }
      ],
      "name": "setMintPassContractAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalClaimedMintPass",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x70096e660e150fa7eaa181647d1ae3ec9e6d0a09368b06852311d4fb38b0ae20",
  "receipt": {
    "to": null,
    "from": "0xaD733B7055eCAebFb3B38626f0148c5d12158F03",
    "contractAddress": "0x0E3511464BF922756651C82a2c1053A303e72DE7",
    "transactionIndex": 2,
    "gasUsed": "411540",
    "logsBloom": "0x00000000800000000000000000000000000000000000000000000010000000000000000000000020000000000000000000008000000000000000000000000000000000000000000000000000000000800000000200000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100000001000000000000000000000000000000000000001000000000000000000000000100000",
    "blockHash": "0x7c1225dcfd51f6244c25d8bb073f3e8f0a271ed57d99ff85ef1692f86e84b796",
    "transactionHash": "0x70096e660e150fa7eaa181647d1ae3ec9e6d0a09368b06852311d4fb38b0ae20",
    "logs": [
      {
        "transactionIndex": 2,
        "blockNumber": 36115444,
        "transactionHash": "0x70096e660e150fa7eaa181647d1ae3ec9e6d0a09368b06852311d4fb38b0ae20",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000ad733b7055ecaebfb3b38626f0148c5d12158f03",
          "0x000000000000000000000000f903ba9e006193c1527bfbe65fe2123704ea3f99"
        ],
        "data": "0x000000000000000000000000000000000000000000000000003a7bbcec110e5400000000000000000000000000000000000000000000000066b59522ef22e770000000000000000000000000000000000000000000000ea138613f7049636145000000000000000000000000000000000000000000000000667b19660311d91c000000000000000000000000000000000000000000000ea1389bbb2d35746f99",
        "logIndex": 4,
        "blockHash": "0x7c1225dcfd51f6244c25d8bb073f3e8f0a271ed57d99ff85ef1692f86e84b796"
      }
    ],
    "blockNumber": 36115444,
    "cumulativeGasUsed": "453540",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "945fce157fb48017de603e7f5a084bc6",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MintPass_ClaimInactive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Roles_MissingAdminRole\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Roles_MissingAutomationRole\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Roles_MissingManagerRole\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"MintPassConsumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimedMintPass\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"elegibleMintPass\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMintPassClaimActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isTokenClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPassContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"setClaimActiveMintPass\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"passContractAddress\",\"type\":\"address\"}],\"name\":\"setMintPassContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimedMintPass\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"claimedMintPass(address)\":{\"returns\":{\"_0\":\"The amount of mint passes redeemed by the account\"}},\"elegibleMintPass(address)\":{\"returns\":{\"_0\":\"The amount of mint passes owned by the account that are not redeemed\"}},\"isMintPassClaimActive()\":{\"returns\":{\"active\":\"bool indicating if claim is active\"}},\"setClaimActiveMintPass(bool)\":{\"details\":\"This function can only be called by an address with the manager role\"},\"totalClaimedMintPass()\":{\"returns\":{\"_0\":\"The total claimed amount using the mint pass\"}}},\"title\":\"WhitelistFacet\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"isMintPassClaimActive()\":{\"notice\":\"Returns true if the mint pass claim is active, or false otherwise\"},\"isTokenClaimed(uint256)\":{\"notice\":\"Returns true if a token pass was used to mint\"},\"mintPassContractAddress()\":{\"notice\":\"Returns the ERC721 contract address that holds the mint passes tokens\"},\"setClaimActiveMintPass(bool)\":{\"notice\":\"Sets the claim state to active/inactive\"},\"setMintPassContractAddress(address)\":{\"notice\":\"Sets the ERC721 contract address that holds the mint passes tokens\"}},\"notice\":\"This contract allows the admins to whitelist an address with a specific amount, which can then be used to claim tokens in other contracts. To consume the whitelist, the token contracts should call the internal functions from WhitelistInternal. This contract can be used as a facet of a diamond which follows the EIP-2535 diamond standard.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/arcadiaDiamonds/mintPass/MintPassFacet.sol\":\"MintPassFacet\"},\"evmVersion\":\"paris\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x00000000d41867734bbee4c6863d9255b2b06ac1\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":250},\"remappings\":[]},\"sources\":{\"@solidstate/contracts/access/access_control/AccessControlInternal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\\nimport { UintUtils } from '../../utils/UintUtils.sol';\\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\\nimport { AccessControlStorage } from './AccessControlStorage.sol';\\n\\n/**\\n * @title Role-based access control system\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nabstract contract AccessControlInternal is IAccessControlInternal {\\n    using AddressUtils for address;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using UintUtils for uint256;\\n\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /*\\n     * @notice query whether role is assigned to account\\n     * @param role role to query\\n     * @param account account to query\\n     * @return whether role is assigned to account\\n     */\\n    function _hasRole(\\n        bytes32 role,\\n        address account\\n    ) internal view virtual returns (bool) {\\n        return\\n            AccessControlStorage.layout().roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @notice revert if sender does not have given role\\n     * @param role role to query\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, msg.sender);\\n    }\\n\\n    /**\\n     * @notice revert if given account does not have given role\\n     * @param role role to query\\n     * @param account to query\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!_hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        'AccessControl: account ',\\n                        account.toString(),\\n                        ' is missing role ',\\n                        uint256(role).toHexString(32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /*\\n     * @notice query admin role for given role\\n     * @param role role to query\\n     * @return admin role\\n     */\\n    function _getRoleAdmin(\\n        bytes32 role\\n    ) internal view virtual returns (bytes32) {\\n        return AccessControlStorage.layout().roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @notice set role as admin role\\n     * @param role role to set\\n     * @param adminRole admin role to set\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = _getRoleAdmin(role);\\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /*\\n     * @notice assign role to given account\\n     * @param role role to assign\\n     * @param account recipient of role assignment\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        AccessControlStorage.layout().roles[role].members.add(account);\\n        emit RoleGranted(role, account, msg.sender);\\n    }\\n\\n    /*\\n     * @notice unassign role from given account\\n     * @param role role to unassign\\n     * @parm account\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        AccessControlStorage.layout().roles[role].members.remove(account);\\n        emit RoleRevoked(role, account, msg.sender);\\n    }\\n\\n    /**\\n     * @notice relinquish role\\n     * @param role role to relinquish\\n     */\\n    function _renounceRole(bytes32 role) internal virtual {\\n        _revokeRole(role, msg.sender);\\n    }\\n}\\n\",\"keccak256\":\"0x5c32c5b490b9a2dd9daa533a75f940f0b0f69c9033776f5e274cd2446c224513\",\"license\":\"MIT\"},\"@solidstate/contracts/access/access_control/AccessControlStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\\n\\nlibrary AccessControlStorage {\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    struct Layout {\\n        mapping(bytes32 => RoleData) roles;\\n    }\\n\\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.AccessControl');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xae788d37a6e20edf7f94be23d78517324f50bccbf0541e10ce0850d7d5bca062\",\"license\":\"MIT\"},\"@solidstate/contracts/access/access_control/IAccessControlInternal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial AccessControl interface needed by internal functions\\n */\\ninterface IAccessControlInternal {\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n}\\n\",\"keccak256\":\"0xcc4a1d78a60955d673104adaee1211de3b3cfb95668f1fbfc43ed0e7f36ad110\",\"license\":\"MIT\"},\"@solidstate/contracts/data/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n    error EnumerableSet__IndexOutOfBounds();\\n\\n    struct Set {\\n        bytes32[] _values;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function at(\\n        Bytes32Set storage set,\\n        uint256 index\\n    ) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    function at(\\n        AddressSet storage set,\\n        uint256 index\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function at(\\n        UintSet storage set,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function contains(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function contains(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function indexOf(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, value);\\n    }\\n\\n    function indexOf(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function indexOf(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(value));\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function add(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    function add(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function remove(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function toArray(\\n        Bytes32Set storage set\\n    ) internal view returns (bytes32[] memory) {\\n        return set._inner._values;\\n    }\\n\\n    function toArray(\\n        AddressSet storage set\\n    ) internal view returns (address[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        address[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function toArray(\\n        UintSet storage set\\n    ) internal view returns (uint256[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        uint256[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function _at(\\n        Set storage set,\\n        uint256 index\\n    ) private view returns (bytes32) {\\n        if (index >= set._values.length)\\n            revert EnumerableSet__IndexOutOfBounds();\\n        return set._values[index];\\n    }\\n\\n    function _contains(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _indexOf(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (uint256) {\\n        unchecked {\\n            return set._indexes[value] - 1;\\n        }\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _add(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            status = true;\\n        }\\n    }\\n\\n    function _remove(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            unchecked {\\n                bytes32 last = set._values[set._values.length - 1];\\n\\n                // move last value to now-vacant index\\n\\n                set._values[valueIndex - 1] = last;\\n                set._indexes[last] = valueIndex;\\n            }\\n            // clear last index\\n\\n            set._values.pop();\\n            delete set._indexes[value];\\n\\n            status = true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbbaaeb805b3e1e704ceba33c9093285220254b1ff6b4b7f577e515b118e116f6\",\"license\":\"MIT\"},\"@solidstate/contracts/utils/AddressUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { UintUtils } from './UintUtils.sol';\\n\\nlibrary AddressUtils {\\n    using UintUtils for uint256;\\n\\n    error AddressUtils__InsufficientBalance();\\n    error AddressUtils__NotContract();\\n    error AddressUtils__SendValueFailed();\\n\\n    function toString(address account) internal pure returns (string memory) {\\n        return uint256(uint160(account)).toHexString(20);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        if (!success) revert AddressUtils__SendValueFailed();\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        if (value > address(this).balance)\\n            revert AddressUtils__InsufficientBalance();\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    /**\\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\\n     * @param target recipient of call\\n     * @param gasAmount gas allowance for call\\n     * @param value native token value to include in call\\n     * @param maxCopy maximum number of bytes to copy from return data\\n     * @param data encoded call data\\n     * @return success whether call is successful\\n     * @return returnData copied return data\\n     */\\n    function excessivelySafeCall(\\n        address target,\\n        uint256 gasAmount,\\n        uint256 value,\\n        uint16 maxCopy,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        returnData = new bytes(maxCopy);\\n\\n        assembly {\\n            // execute external call via assembly to avoid automatic copying of return data\\n            success := call(\\n                gasAmount,\\n                target,\\n                value,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0\\n            )\\n\\n            // determine whether to limit amount of data to copy\\n            let toCopy := returndatasize()\\n\\n            if gt(toCopy, maxCopy) {\\n                toCopy := maxCopy\\n            }\\n\\n            // store the length of the copied bytes\\n            mstore(returnData, toCopy)\\n\\n            // copy the bytes from returndata[0:toCopy]\\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\\n        }\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        if (!isContract(target)) revert AddressUtils__NotContract();\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7d924db4dbd9210923ab08db77db3c77438014c255fd49fa208ebce283d991bf\",\"license\":\"MIT\"},\"@solidstate/contracts/utils/UintUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title utility functions for uint256 operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary UintUtils {\\n    error UintUtils__InsufficientHexLength();\\n\\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\\n\\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? sub(a, -b) : a + uint256(b);\\n    }\\n\\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? add(a, -b) : a - uint256(b);\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0';\\n        }\\n\\n        uint256 temp = value;\\n        uint256 digits;\\n\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        bytes memory buffer = new bytes(digits);\\n\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0x00';\\n        }\\n\\n        uint256 length = 0;\\n\\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\\n            unchecked {\\n                length++;\\n            }\\n        }\\n\\n        return toHexString(value, length);\\n    }\\n\\n    function toHexString(\\n        uint256 value,\\n        uint256 length\\n    ) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = '0';\\n        buffer[1] = 'x';\\n\\n        unchecked {\\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\\n                value >>= 4;\\n            }\\n        }\\n\\n        if (value != 0) revert UintUtils__InsufficientHexLength();\\n\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x5aaeaea22a0800402c6f2d8ce6185293bc64f74f6c390c1b1c53b624b43972f8\",\"license\":\"MIT\"},\"contracts/arcadiaDiamonds/mintPass/IERC721A.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.19;\\n\\ninterface IERC721A {\\n    struct TokenOwnership {\\n        address addr;\\n        uint64 startTimestamp;\\n        bool burned;\\n        uint24 extraData;\\n    }\\n\\n    struct MintStageInfo {\\n        uint80 price;\\n        uint32 walletLimit;\\n        bytes32 merkleRoot;\\n        uint24 maxStageSupply;\\n        uint64 startTimeUnixSeconds;\\n        uint64 endTimeUnixSeconds;\\n    }\\n\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    event ConsecutiveTransfer(uint256 fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    event PermanentBaseURI(string baseURI);\\n    event SetActiveStage(uint256 activeStage);\\n    event SetBaseURI(string baseURI);\\n    event SetCosigner(address cosigner);\\n    event SetCrossmintAddress(address crossmintAddress);\\n    event SetGlobalWalletLimit(uint256 globalWalletLimit);\\n    event SetMaxMintableSupply(uint256 maxMintableSupply);\\n    event SetMintable(bool mintable);\\n    event SetTimestampExpirySeconds(uint64 expiry);\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event UpdateStage(\\n        uint256 stage,\\n        uint80 price,\\n        uint32 walletLimit,\\n        bytes32 merkleRoot,\\n        uint24 maxStageSupply,\\n        uint64 startTimeUnixSeconds,\\n        uint64 endTimeUnixSeconds\\n    );\\n    event Withdraw(uint256 value);\\n\\n    function approve(address to, uint256 tokenId) external payable;\\n    function assertValidCosign(address minter, uint32 qty, uint64 timestamp, bytes calldata signature) external view;\\n    function balanceOf(address owner) external view returns (uint256);\\n    function crossmint(uint32 qty, address to, bytes32[] calldata proof, uint64 timestamp, bytes calldata signature) external payable;\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n    function explicitOwnershipsOf(uint256[] calldata tokenIds) external view returns (TokenOwnership[] memory);\\n    function getActiveStageFromTimestamp(uint64 timestamp) external view returns (uint256);\\n    function getApproved(uint256 tokenId) external view returns (address);\\n    function getCosignDigest(address minter, uint32 qty, uint64 timestamp) external view returns (bytes32);\\n    function getCosignNonce(address minter) external view returns (uint256);\\n    function getCosigner() external view returns (address);\\n    function getCrossmintAddress() external view returns (address);\\n    function getGlobalWalletLimit() external view returns (uint256);\\n    function getMaxMintableSupply() external view returns (uint256);\\n    function getMintable() external view returns (bool);\\n    function getNumberStages() external view returns (uint256);\\n    function getStageInfo(uint256 index)\\n        external\\n        view\\n        returns (\\n            MintStageInfo memory,\\n            uint32,\\n            uint256\\n        );\\n    function getTimestampExpirySeconds() external view returns (uint64);\\n    function getTokenURISuffix() external view returns (string memory);\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n    function mint(address minter, uint32 qty, uint64 timestamp) external payable;\\n    function name() external view returns (string memory);\\n    function owner() external view returns (address);\\n    function ownerMint(uint32 qty, address to) external;\\n        function ownerOf(uint256 tokenId) external view returns (address);\\n    function permanentBaseURI() external view returns (string memory);\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external payable;\\n    function setApprovalForAll(address operator, bool approved) external;\\n    function setActiveStage(uint256 stage) external;\\n    function setBaseURI(string calldata baseURI) external;\\n    function setCosigner(address cosigner) external;\\n    function setCrossmintAddress(address crossmintAddress) external;\\n    function setGlobalWalletLimit(uint256 globalWalletLimit) external;\\n    function setMaxMintableSupply(uint256 maxMintableSupply) external;\\n    function setMintable(bool mintable) external;\\n    function setTimestampExpirySeconds(uint64 expiry) external;\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n    function symbol() external view returns (string memory);\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n    function tokensOfOwnerIn(address owner, uint256 indexStart, uint256 indexStop) external view returns (uint256[] memory);\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n    function totalSupply() external view returns (uint256);\\n    function transferFrom(address from, address to, uint256 tokenId) external payable;\\n    function updateStage(\\n        uint256 stage,\\n        uint80 price,\\n        uint32 walletLimit,\\n        bytes32 merkleRoot,\\n        uint24 maxStageSupply,\\n        uint64 startTimeUnixSeconds,\\n        uint64 endTimeUnixSeconds\\n    ) external;\\n    function withdraw(uint256 value) external;\\n}\\n\",\"keccak256\":\"0xc14af6aa39c49cf91526bc25e8481ce99794757cab4e62b2e688f82df2bd33a2\",\"license\":\"GPL-2.0\"},\"contracts/arcadiaDiamonds/mintPass/MintPassFacet.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0\\npragma solidity 0.8.19;\\n\\nimport { MintPassInternal } from './MintPassInternal.sol';\\nimport { MintPassStorage } from \\\"./MintPassStorage.sol\\\";\\nimport { RolesInternal } from \\\"./../roles/RolesInternal.sol\\\";\\n\\n/**\\n * @title WhitelistFacet\\n * @notice This contract allows the admins to whitelist an address with a specific amount,\\n * which can then be used to claim tokens in other contracts.\\n * To consume the whitelist, the token contracts should call the internal functions from WhitelistInternal.\\n * This contract can be used as a facet of a diamond which follows the EIP-2535 diamond standard.\\n */\\ncontract MintPassFacet is MintPassInternal, RolesInternal {\\n    \\n    /**\\n     * @return The total claimed amount using the mint pass\\n     */\\n    function totalClaimedMintPass() external view returns (uint) {\\n        return _totalClaimedMintPass();\\n    }\\n\\n    /**\\n     * @return The amount of mint passes redeemed by the account\\n     */\\n    function claimedMintPass(address account) external view returns (uint) {\\n        return _claimedMintPass(account);\\n    }\\n\\n    /**\\n     * @return The amount of mint passes owned by the account that are not redeemed\\n     */\\n    function elegibleMintPass(address account) external view returns (uint) {\\n        return _elegibleMintPass(account);\\n    }\\n    \\n    /**\\n     * @notice Sets the claim state to active/inactive\\n     * @dev This function can only be called by an address with the manager role\\n     */\\n    function setClaimActiveMintPass(bool active) external onlyManager {\\n        _setClaimActiveMintPass(active);\\n    }\\n\\n    /**\\n     * @notice Returns true if the mint pass claim is active, or false otherwise\\n     * @return active bool indicating if claim is active\\n     */\\n    function isMintPassClaimActive() view external returns (bool active) {\\n        return _isMintPassClaimActive();\\n    }\\n\\n    /**\\n     * @notice Sets the ERC721 contract address that holds the mint passes tokens\\n     */\\n    function setMintPassContractAddress(address passContractAddress) external onlyManager {\\n        _setMintPassContractAddress(passContractAddress);\\n    }\\n\\n    /**\\n     * @notice Returns the ERC721 contract address that holds the mint passes tokens\\n     */\\n    function mintPassContractAddress() external view returns (address) {\\n        return _mintPassContractAddress();\\n    }\\n\\n    /**\\n     * @notice Returns true if a token pass was used to mint\\n     */\\n    function isTokenClaimed(uint tokenId) external view returns (bool) {\\n        return _isTokenClaimed(tokenId);\\n    }\\n}\",\"keccak256\":\"0xfffa60ac73260a0adc6656c05d678e4c2bbeeabee0ea871171cc97289ad0e6e4\",\"license\":\"GPL-2.0\"},\"contracts/arcadiaDiamonds/mintPass/MintPassInternal.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0\\npragma solidity 0.8.19;\\n\\nimport { MintPassStorage } from \\\"./MintPassStorage.sol\\\";\\nimport { IERC721A } from \\\"./IERC721A.sol\\\";\\n\\ncontract MintPassInternal {\\n\\n    error MintPass_ClaimInactive();\\n\\n    event MintPassConsumed(address indexed account, uint tokenId);\\n\\n    function _totalClaimedMintPass() internal view returns (uint) {\\n        return MintPassStorage.layout().totalClaimed;\\n    }\\n\\n    function _claimedMintPass(address account) internal view returns (uint) {\\n        return MintPassStorage.layout().claimedAmount[account];\\n    }\\n\\n    function _elegibleMintPass(address account) internal view returns (uint elegibleAmount) {\\n        MintPassStorage.Layout storage mintPassSL = MintPassStorage.layout();\\n\\n        IERC721A passContract = IERC721A(mintPassSL.passContractAddress);\\n\\n        uint[] memory tokensOfOwner = passContract.tokensOfOwner(account);\\n        for (uint i = 0; i < tokensOfOwner.length; i++) {\\n            if (!mintPassSL.isTokenClaimed[tokensOfOwner[i]]) {\\n                elegibleAmount++;\\n            }\\n        }\\n    }\\n\\n    function _consumeMintPass(address account) internal returns (bool consumed) {\\n        MintPassStorage.Layout storage mintPassSL = MintPassStorage.layout();\\n\\n        IERC721A passContract = IERC721A(mintPassSL.passContractAddress);\\n\\n        if (!MintPassStorage.layout().claimActive)\\n            revert MintPass_ClaimInactive();\\n\\n        uint[] memory tokensOfOwner = passContract.tokensOfOwner(account);\\n\\n        for (uint i = 0; i < tokensOfOwner.length; i++) {\\n            uint tokenId = tokensOfOwner[i];\\n            if (!mintPassSL.isTokenClaimed[tokenId]) {\\n                mintPassSL.claimedAmount[account]++;\\n                mintPassSL.totalClaimed++;\\n                mintPassSL.isTokenClaimed[tokenId] = true;\\n                consumed = true;\\n\\n                emit MintPassConsumed(account, 1);\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _isMintPassClaimActive() view internal returns (bool) {\\n        return MintPassStorage.layout().claimActive;\\n    }\\n\\n    function _setClaimActiveMintPass(bool active) internal {\\n        MintPassStorage.layout().claimActive = active;\\n    }\\n\\n    function _setMintPassContractAddress(address passContractAddress) internal {\\n        MintPassStorage.layout().passContractAddress = passContractAddress;\\n    }\\n\\n    function _mintPassContractAddress() internal view returns (address) {\\n        return MintPassStorage.layout().passContractAddress;\\n    }\\n\\n    function _isTokenClaimed(uint tokenId) internal view returns (bool) {\\n        return MintPassStorage.layout().isTokenClaimed[tokenId];\\n    }\\n}\",\"keccak256\":\"0x7c93bbbf713181d75f4f38f0fb3021f17246fa4360d9dd523e3b7c77e463589c\",\"license\":\"GPL-2.0\"},\"contracts/arcadiaDiamonds/mintPass/MintPassStorage.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0\\npragma solidity 0.8.19;\\n\\nlibrary MintPassStorage {\\n\\n    bytes32 constant MINT_PASS_STORAGE_POSITION =\\n        keccak256(\\\"mintPass.storage.position\\\");\\n    \\n    struct Layout {\\n        mapping(uint => bool) isTokenClaimed;\\n        mapping(address => uint) claimedAmount;\\n        uint totalClaimed;\\n        uint maxSupply;\\n        bool claimActive;\\n        address passContractAddress;\\n    }\\n\\n    function layout()\\n        internal\\n        pure\\n        returns (Layout storage es)\\n    {\\n        bytes32 position = MINT_PASS_STORAGE_POSITION;\\n        assembly {\\n            es.slot := position\\n        }\\n    }\\n}\",\"keccak256\":\"0x5e2193e63b2e2570d29f026a2e12bf5999bb438eb28dbef44a103015bfb165bc\",\"license\":\"GPL-2.0\"},\"contracts/arcadiaDiamonds/roles/RolesInternal.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0\\npragma solidity 0.8.19;\\n\\nimport { AccessControlInternal } from \\\"@solidstate/contracts/access/access_control/AccessControlInternal.sol\\\";\\nimport { AccessControlStorage } from \\\"@solidstate/contracts/access/access_control/AccessControlStorage.sol\\\";\\nimport { RolesStorage } from './RolesStorage.sol';\\n\\ncontract RolesInternal is AccessControlInternal {\\n\\n    error Roles_MissingAdminRole();\\n    error Roles_MissingManagerRole();\\n    error Roles_MissingAutomationRole();\\n\\n    modifier onlyDefaultAdmin() {\\n        if (!_hasRole(_defaultAdminRole(), msg.sender))\\n            revert Roles_MissingAdminRole();\\n        _;\\n    }\\n\\n    modifier onlyManager() {\\n        if (!_hasRole(_managerRole(), msg.sender))\\n            revert Roles_MissingManagerRole();\\n        _;\\n    }\\n\\n    modifier onlyAutomation() {\\n        if (!_hasRole(_managerRole(), msg.sender) && !_hasRole(_automationRole(), msg.sender))\\n            revert Roles_MissingAutomationRole();\\n        _;\\n    }\\n\\n    function _defaultAdminRole() internal pure returns (bytes32) {\\n        return AccessControlStorage.DEFAULT_ADMIN_ROLE;\\n    }\\n\\n    function _managerRole() internal view returns (bytes32) {\\n        return RolesStorage.layout().managerRole;\\n    }\\n\\n    function _automationRole() internal view returns (bytes32) {\\n        return RolesStorage.layout().automationRole;\\n    }\\n\\n    function _initRoles() internal {\\n        RolesStorage.Layout storage rolesSL = RolesStorage.layout();\\n        rolesSL.managerRole = keccak256(\\\"manager.role\\\");\\n        rolesSL.automationRole = keccak256(\\\"automation.role\\\");\\n\\n        _grantRole(_defaultAdminRole(), msg.sender);\\n        _grantRole(_managerRole(), msg.sender);\\n    }\\n}\",\"keccak256\":\"0x3bbcaec7bceb8497e1e96785c524e1cf67b54ba34713086686887d13502b5264\",\"license\":\"GPL-2.0\"},\"contracts/arcadiaDiamonds/roles/RolesStorage.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0\\npragma solidity 0.8.19;\\n\\nlibrary RolesStorage {\\n\\n    bytes32 constant ROLES_STORAGE_POSITION =\\n        keccak256(\\\"roles.storage.position\\\");\\n\\n    struct Layout {\\n        bytes32 managerRole;\\n        bytes32 automationRole;\\n    }\\n\\n    function layout()\\n        internal\\n        pure\\n        returns (Layout storage es)\\n    {\\n        bytes32 position = ROLES_STORAGE_POSITION;\\n        assembly {\\n            es.slot := position\\n        }\\n    }\\n}\",\"keccak256\":\"0x6eb213b99e10477f695528196487fafafaeceb2b11c6f9f43f3ddb9e83f9e8d3\",\"license\":\"GPL-2.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061067c806100206000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c80636cedd32b1161005b5780636cedd32b146100e85780637f90c968146100fb5780639a5736651461010e578063bbafe1621461012157600080fd5b806309ebb2fe1461008d5780630eb346a9146100a857806349301a9c146100bd5780634f0133b4146100d5575b600080fd5b610095610169565b6040519081526020015b60405180910390f35b6100bb6100b63660046104d1565b610198565b005b6100c5610235565b604051901515815260200161009f565b6100956100e33660046104d1565b610262565b6100c56100f63660046104fa565b610273565b6100bb610109366004610513565b6102a9565b61009561011c3660046104d1565b610321565b7fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a216b5461010090046001600160a01b03166040516001600160a01b03909116815260200161009f565b60006101937fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a21695490565b905090565b6101c96101c37ff6deb63e40d71b08820818e006e23fcceb1fce7a499bc15b71b2526cbf9efa725490565b3361035e565b6101e65760405163d0befa1d60e01b815260040160405180910390fd5b7fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a216b805474ffffffffffffffffffffffffffffffffffffffff0019166101006001600160a01b0384160217905550565b60006101937fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a216b5460ff1690565b600061026d826103ba565b92915050565b60008181527fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a2167602052604081205460ff1661026d565b6102d46101c37ff6deb63e40d71b08820818e006e23fcceb1fce7a499bc15b71b2526cbf9efa725490565b6102f15760405163d0befa1d60e01b815260040160405180910390fd5b7fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a216b805460ff191682151517905550565b6001600160a01b03811660009081527fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a2168602052604081205461026d565b60006103b3827fd3889cc5458b268d0544e5534672df1296288ca3f93cbd39bd6f497a5c622811600086815260209190915260409020906001600160a01b038116600090815260018301602052604081205415155b9392505050565b6000807fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a2167600481810154604051632118854760e21b81526001600160a01b0387811693820193909352929350610100900416906000908290638462151c90602401600060405180830381865afa158015610438573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610460919081019061054b565b905060005b81518110156104c85783600001600083838151811061048657610486610609565b60209081029190910181015182528101919091526040016000205460ff166104b657846104b28161061f565b9550505b806104c08161061f565b915050610465565b50505050919050565b6000602082840312156104e357600080fd5b81356001600160a01b03811681146103b357600080fd5b60006020828403121561050c57600080fd5b5035919050565b60006020828403121561052557600080fd5b813580151581146103b357600080fd5b634e487b7160e01b600052604160045260246000fd5b6000602080838503121561055e57600080fd5b825167ffffffffffffffff8082111561057657600080fd5b818501915085601f83011261058a57600080fd5b81518181111561059c5761059c610535565b8060051b604051601f19603f830116810181811085821117156105c1576105c1610535565b6040529182528482019250838101850191888311156105df57600080fd5b938501935b828510156105fd578451845293850193928501926105e4565b98975050505050505050565b634e487b7160e01b600052603260045260246000fd5b60006001820161063f57634e487b7160e01b600052601160045260246000fd5b506001019056fea26469706673582212203e02dace5e92a7f0515bc52aad3a546edb8976f4a3b96b9641d6597d9c42888564736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100885760003560e01c80636cedd32b1161005b5780636cedd32b146100e85780637f90c968146100fb5780639a5736651461010e578063bbafe1621461012157600080fd5b806309ebb2fe1461008d5780630eb346a9146100a857806349301a9c146100bd5780634f0133b4146100d5575b600080fd5b610095610169565b6040519081526020015b60405180910390f35b6100bb6100b63660046104d1565b610198565b005b6100c5610235565b604051901515815260200161009f565b6100956100e33660046104d1565b610262565b6100c56100f63660046104fa565b610273565b6100bb610109366004610513565b6102a9565b61009561011c3660046104d1565b610321565b7fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a216b5461010090046001600160a01b03166040516001600160a01b03909116815260200161009f565b60006101937fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a21695490565b905090565b6101c96101c37ff6deb63e40d71b08820818e006e23fcceb1fce7a499bc15b71b2526cbf9efa725490565b3361035e565b6101e65760405163d0befa1d60e01b815260040160405180910390fd5b7fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a216b805474ffffffffffffffffffffffffffffffffffffffff0019166101006001600160a01b0384160217905550565b60006101937fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a216b5460ff1690565b600061026d826103ba565b92915050565b60008181527fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a2167602052604081205460ff1661026d565b6102d46101c37ff6deb63e40d71b08820818e006e23fcceb1fce7a499bc15b71b2526cbf9efa725490565b6102f15760405163d0befa1d60e01b815260040160405180910390fd5b7fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a216b805460ff191682151517905550565b6001600160a01b03811660009081527fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a2168602052604081205461026d565b60006103b3827fd3889cc5458b268d0544e5534672df1296288ca3f93cbd39bd6f497a5c622811600086815260209190915260409020906001600160a01b038116600090815260018301602052604081205415155b9392505050565b6000807fa3ab50e899f598cf35254e9a97be2f97034673b13bdb3ad1ddfaf5a13d0a2167600481810154604051632118854760e21b81526001600160a01b0387811693820193909352929350610100900416906000908290638462151c90602401600060405180830381865afa158015610438573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610460919081019061054b565b905060005b81518110156104c85783600001600083838151811061048657610486610609565b60209081029190910181015182528101919091526040016000205460ff166104b657846104b28161061f565b9550505b806104c08161061f565b915050610465565b50505050919050565b6000602082840312156104e357600080fd5b81356001600160a01b03811681146103b357600080fd5b60006020828403121561050c57600080fd5b5035919050565b60006020828403121561052557600080fd5b813580151581146103b357600080fd5b634e487b7160e01b600052604160045260246000fd5b6000602080838503121561055e57600080fd5b825167ffffffffffffffff8082111561057657600080fd5b818501915085601f83011261058a57600080fd5b81518181111561059c5761059c610535565b8060051b604051601f19603f830116810181811085821117156105c1576105c1610535565b6040529182528482019250838101850191888311156105df57600080fd5b938501935b828510156105fd578451845293850193928501926105e4565b98975050505050505050565b634e487b7160e01b600052603260045260246000fd5b60006001820161063f57634e487b7160e01b600052601160045260246000fd5b506001019056fea26469706673582212203e02dace5e92a7f0515bc52aad3a546edb8976f4a3b96b9641d6597d9c42888564736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "claimedMintPass(address)": {
        "returns": {
          "_0": "The amount of mint passes redeemed by the account"
        }
      },
      "elegibleMintPass(address)": {
        "returns": {
          "_0": "The amount of mint passes owned by the account that are not redeemed"
        }
      },
      "isMintPassClaimActive()": {
        "returns": {
          "active": "bool indicating if claim is active"
        }
      },
      "setClaimActiveMintPass(bool)": {
        "details": "This function can only be called by an address with the manager role"
      },
      "totalClaimedMintPass()": {
        "returns": {
          "_0": "The total claimed amount using the mint pass"
        }
      }
    },
    "title": "WhitelistFacet",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "isMintPassClaimActive()": {
        "notice": "Returns true if the mint pass claim is active, or false otherwise"
      },
      "isTokenClaimed(uint256)": {
        "notice": "Returns true if a token pass was used to mint"
      },
      "mintPassContractAddress()": {
        "notice": "Returns the ERC721 contract address that holds the mint passes tokens"
      },
      "setClaimActiveMintPass(bool)": {
        "notice": "Sets the claim state to active/inactive"
      },
      "setMintPassContractAddress(address)": {
        "notice": "Sets the ERC721 contract address that holds the mint passes tokens"
      }
    },
    "notice": "This contract allows the admins to whitelist an address with a specific amount, which can then be used to claim tokens in other contracts. To consume the whitelist, the token contracts should call the internal functions from WhitelistInternal. This contract can be used as a facet of a diamond which follows the EIP-2535 diamond standard.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}