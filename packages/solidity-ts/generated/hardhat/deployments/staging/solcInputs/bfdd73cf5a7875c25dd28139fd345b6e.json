{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { UintUtils } from '../../utils/UintUtils.sol';\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\nimport { AccessControlStorage } from './AccessControlStorage.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControlInternal is IAccessControlInternal {\n    using AddressUtils for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using UintUtils for uint256;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function _hasRole(\n        bytes32 role,\n        address account\n    ) internal view virtual returns (bool) {\n        return\n            AccessControlStorage.layout().roles[role].members.contains(account);\n    }\n\n    /**\n     * @notice revert if sender does not have given role\n     * @param role role to query\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, msg.sender);\n    }\n\n    /**\n     * @notice revert if given account does not have given role\n     * @param role role to query\n     * @param account to query\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!_hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        'AccessControl: account ',\n                        account.toString(),\n                        ' is missing role ',\n                        uint256(role).toHexString(32)\n                    )\n                )\n            );\n        }\n    }\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function _getRoleAdmin(\n        bytes32 role\n    ) internal view virtual returns (bytes32) {\n        return AccessControlStorage.layout().roles[role].adminRole;\n    }\n\n    /**\n     * @notice set role as admin role\n     * @param role role to set\n     * @param adminRole admin role to set\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = _getRoleAdmin(role);\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.remove(account);\n        emit RoleRevoked(role, account, msg.sender);\n    }\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function _renounceRole(bytes32 role) internal virtual {\n        _revokeRole(role, msg.sender);\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\n\nlibrary AccessControlStorage {\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) roles;\n    }\n\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.AccessControl');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial AccessControl interface needed by internal functions\n */\ninterface IAccessControlInternal {\n    event RoleAdminChanged(\n        bytes32 indexed role,\n        bytes32 indexed previousAdminRole,\n        bytes32 indexed newAdminRole\n    );\n\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n}\n"
    },
    "@solidstate/contracts/data/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Map implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableMap {\n    error EnumerableMap__IndexOutOfBounds();\n    error EnumerableMap__NonExistentKey();\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        MapEntry[] _entries;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct AddressToAddressMap {\n        Map _inner;\n    }\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    function at(\n        AddressToAddressMap storage map,\n        uint256 index\n    ) internal view returns (address, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n\n        return (\n            address(uint160(uint256(key))),\n            address(uint160(uint256(value)))\n        );\n    }\n\n    function at(\n        UintToAddressMap storage map,\n        uint256 index\n    ) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    function contains(\n        AddressToAddressMap storage map,\n        address key\n    ) internal view returns (bool) {\n        return _contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    function contains(\n        UintToAddressMap storage map,\n        uint256 key\n    ) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    function length(\n        AddressToAddressMap storage map\n    ) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    function length(\n        UintToAddressMap storage map\n    ) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    function get(\n        AddressToAddressMap storage map,\n        address key\n    ) internal view returns (address) {\n        return\n            address(\n                uint160(\n                    uint256(_get(map._inner, bytes32(uint256(uint160(key)))))\n                )\n            );\n    }\n\n    function get(\n        UintToAddressMap storage map,\n        uint256 key\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    function set(\n        AddressToAddressMap storage map,\n        address key,\n        address value\n    ) internal returns (bool) {\n        return\n            _set(\n                map._inner,\n                bytes32(uint256(uint160(key))),\n                bytes32(uint256(uint160(value)))\n            );\n    }\n\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        AddressToAddressMap storage map,\n        address key\n    ) internal returns (bool) {\n        return _remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    function remove(\n        UintToAddressMap storage map,\n        uint256 key\n    ) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    function toArray(\n        AddressToAddressMap storage map\n    )\n        internal\n        view\n        returns (address[] memory keysOut, address[] memory valuesOut)\n    {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new address[](len);\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._key))\n                );\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function toArray(\n        UintToAddressMap storage map\n    )\n        internal\n        view\n        returns (uint256[] memory keysOut, address[] memory valuesOut)\n    {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new uint256[](len);\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = uint256(map._inner._entries[i]._key);\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function keys(\n        AddressToAddressMap storage map\n    ) internal view returns (address[] memory keysOut) {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._key))\n                );\n            }\n        }\n    }\n\n    function keys(\n        UintToAddressMap storage map\n    ) internal view returns (uint256[] memory keysOut) {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new uint256[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = uint256(map._inner._entries[i]._key);\n            }\n        }\n    }\n\n    function values(\n        AddressToAddressMap storage map\n    ) internal view returns (address[] memory valuesOut) {\n        uint256 len = map._inner._entries.length;\n\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function values(\n        UintToAddressMap storage map\n    ) internal view returns (address[] memory valuesOut) {\n        uint256 len = map._inner._entries.length;\n\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function _at(\n        Map storage map,\n        uint256 index\n    ) private view returns (bytes32, bytes32) {\n        if (index >= map._entries.length)\n            revert EnumerableMap__IndexOutOfBounds();\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    function _contains(\n        Map storage map,\n        bytes32 key\n    ) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) revert EnumerableMap__NonExistentKey();\n        unchecked {\n            return map._entries[keyIndex - 1]._value;\n        }\n    }\n\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) {\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            unchecked {\n                map._entries[keyIndex - 1]._value = value;\n            }\n            return false;\n        }\n    }\n\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) {\n            unchecked {\n                MapEntry storage last = map._entries[map._entries.length - 1];\n\n                // move last entry to now-vacant index\n                map._entries[keyIndex - 1] = last;\n                map._indexes[last._key] = keyIndex;\n            }\n\n            // clear last index\n            map._entries.pop();\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/data/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    error EnumerableSet__IndexOutOfBounds();\n\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(\n        Bytes32Set storage set,\n        uint256 index\n    ) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    function at(\n        AddressSet storage set,\n        uint256 index\n    ) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(\n        UintSet storage set,\n        uint256 index\n    ) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    function contains(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function contains(\n        AddressSet storage set,\n        address value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function indexOf(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, value);\n    }\n\n    function indexOf(\n        AddressSet storage set,\n        address value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function indexOf(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(value));\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function add(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function remove(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        UintSet storage set,\n        uint256 value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function toArray(\n        Bytes32Set storage set\n    ) internal view returns (bytes32[] memory) {\n        return set._inner._values;\n    }\n\n    function toArray(\n        AddressSet storage set\n    ) internal view returns (address[] memory) {\n        bytes32[] storage values = set._inner._values;\n        address[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function toArray(\n        UintSet storage set\n    ) internal view returns (uint256[] memory) {\n        bytes32[] storage values = set._inner._values;\n        uint256[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function _at(\n        Set storage set,\n        uint256 index\n    ) private view returns (bytes32) {\n        if (index >= set._values.length)\n            revert EnumerableSet__IndexOutOfBounds();\n        return set._values[index];\n    }\n\n    function _contains(\n        Set storage set,\n        bytes32 value\n    ) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _indexOf(\n        Set storage set,\n        bytes32 value\n    ) private view returns (uint256) {\n        unchecked {\n            return set._indexes[value] - 1;\n        }\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            status = true;\n        }\n    }\n\n    function _remove(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            unchecked {\n                bytes32 last = set._values[set._values.length - 1];\n\n                // move last value to now-vacant index\n\n                set._values[valueIndex - 1] = last;\n                set._indexes[last] = valueIndex;\n            }\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            status = true;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\nimport { IERC1155Internal } from './IERC1155Internal.sol';\n\n/**\n * @title ERC1155 interface\n * @dev see https://github.com/ethereum/EIPs/issues/1155\n */\ninterface IERC1155 is IERC1155Internal, IERC165 {\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external view returns (uint256);\n\n    /**\n     * @notice query the balances of given tokens held by given addresses\n     * @param accounts addresss to query\n     * @param ids tokens to query\n     * @return token balances\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool);\n\n    /**\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\n     * @param operator address whose approval status to update\n     * @param status whether operator should be considered approved\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to transfer\n     * @param data data payload\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC1155 interface needed by internal functions\n */\ninterface IERC1155Internal {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 is IERC165Internal {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n */\ninterface IERC165Internal {\n\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\nimport { IERC721Internal } from './IERC721Internal.sol';\n\n/**\n * @title ERC721 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721 is IERC721Internal, IERC165 {\n    /**\n     * @notice query the balance of given address\n     * @return balance quantity of tokens held\n     */\n    function balanceOf(address account) external view returns (uint256 balance);\n\n    /**\n     * @notice query the owner of given token\n     * @param tokenId token to query\n     * @return owner token owner\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, without checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice grant approval to given account to spend token\n     * @param operator address to be approved\n     * @param tokenId token to approve\n     */\n    function approve(address operator, uint256 tokenId) external payable;\n\n    /**\n     * @notice get approval status for given token\n     * @param tokenId token to query\n     * @return operator address approved to spend token\n     */\n    function getApproved(\n        uint256 tokenId\n    ) external view returns (address operator);\n\n    /**\n     * @notice grant approval to or revoke approval from given account to spend all tokens held by sender\n     * @param operator address to be approved\n     * @param status approval status\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return status whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool status);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC721 interface needed by internal functions\n */\ninterface IERC721Internal {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed operator,\n        uint256 indexed tokenId\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\nimport { IERC165Base } from './IERC165Base.sol';\nimport { ERC165BaseInternal } from './ERC165BaseInternal.sol';\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165Base is IERC165Base, ERC165BaseInternal {\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n        return _supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165BaseInternal is IERC165BaseInternal {\n    /**\n     * @notice indicates whether an interface is already supported based on the interfaceId\n     * @param interfaceId id of interface to check\n     * @return bool indicating whether interface is supported\n     */\n    function _supportsInterface(\n        bytes4 interfaceId\n    ) internal view returns (bool) {\n        return ERC165BaseStorage.layout().supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @notice sets status of interface support\n     * @param interfaceId id of interface to set status for\n     * @param status boolean indicating whether interface will be set as supported\n     */\n    function _setSupportsInterface(bytes4 interfaceId, bool status) internal {\n        if (interfaceId == 0xffffffff) revert ERC165Base__InvalidInterfaceId();\n        ERC165BaseStorage.layout().supportedInterfaces[interfaceId] = status;\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC165BaseStorage {\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC165Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/IERC165Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\n\ninterface IERC165Base is IERC165, IERC165BaseInternal {}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/IERC165BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165Internal } from '../../../interfaces/IERC165Internal.sol';\n\ninterface IERC165BaseInternal is IERC165Internal {\n    error ERC165Base__InvalidInterfaceId();\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/ERC721Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721 } from '../../../interfaces/IERC721.sol';\nimport { IERC721Base } from './IERC721Base.sol';\nimport { ERC721BaseInternal } from './ERC721BaseInternal.sol';\n\n/**\n * @title Base ERC721 implementation, excluding optional extensions\n */\nabstract contract ERC721Base is IERC721Base, ERC721BaseInternal {\n    /**\n     * @inheritdoc IERC721\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balanceOf(account);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function ownerOf(uint256 tokenId) external view returns (address) {\n        return _ownerOf(tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function getApproved(uint256 tokenId) external view returns (address) {\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool) {\n        return _isApprovedForAll(account, operator);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable {\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable {\n        _safeTransferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external payable {\n        _safeTransferFrom(from, to, tokenId, data);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function approve(address operator, uint256 tokenId) external payable {\n        _approve(operator, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function setApprovalForAll(address operator, bool status) external {\n        _setApprovalForAll(operator, status);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/ERC721BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721Receiver } from '../../../interfaces/IERC721Receiver.sol';\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { IERC721BaseInternal } from './IERC721BaseInternal.sol';\nimport { ERC721BaseStorage } from './ERC721BaseStorage.sol';\n\n/**\n * @title Base ERC721 internal functions\n */\nabstract contract ERC721BaseInternal is IERC721BaseInternal {\n    using AddressUtils for address;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    function _balanceOf(\n        address account\n    ) internal view virtual returns (uint256) {\n        if (account == address(0)) revert ERC721Base__BalanceQueryZeroAddress();\n        return ERC721BaseStorage.layout().holderTokens[account].length();\n    }\n\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        address owner = ERC721BaseStorage.layout().tokenOwners.get(tokenId);\n        if (owner == address(0)) revert ERC721Base__InvalidOwner();\n        return owner;\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return ERC721BaseStorage.layout().tokenOwners.contains(tokenId);\n    }\n\n    function _getApproved(\n        uint256 tokenId\n    ) internal view virtual returns (address) {\n        if (!_exists(tokenId)) revert ERC721Base__NonExistentToken();\n\n        return ERC721BaseStorage.layout().tokenApprovals[tokenId];\n    }\n\n    function _isApprovedForAll(\n        address account,\n        address operator\n    ) internal view virtual returns (bool) {\n        return ERC721BaseStorage.layout().operatorApprovals[account][operator];\n    }\n\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view virtual returns (bool) {\n        if (!_exists(tokenId)) revert ERC721Base__NonExistentToken();\n\n        address owner = _ownerOf(tokenId);\n\n        return (spender == owner ||\n            _getApproved(tokenId) == spender ||\n            _isApprovedForAll(owner, spender));\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        if (to == address(0)) revert ERC721Base__MintToZeroAddress();\n        if (_exists(tokenId)) revert ERC721Base__TokenAlreadyMinted();\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\n\n        l.holderTokens[to].add(tokenId);\n        l.tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, '');\n    }\n\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        if (!_checkOnERC721Received(address(0), to, tokenId, data))\n            revert ERC721Base__ERC721ReceiverNotImplemented();\n    }\n\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = _ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\n\n        l.holderTokens[owner].remove(tokenId);\n        l.tokenOwners.remove(tokenId);\n\n        l.tokenApprovals[tokenId] = address(0);\n\n        emit Approval(owner, address(0), tokenId);\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        address owner = _ownerOf(tokenId);\n\n        if (owner != from) revert ERC721Base__NotTokenOwner();\n        if (to == address(0)) revert ERC721Base__TransferToZeroAddress();\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\n\n        l.holderTokens[from].remove(tokenId);\n        l.holderTokens[to].add(tokenId);\n        l.tokenOwners.set(tokenId, to);\n        l.tokenApprovals[tokenId] = address(0);\n\n        emit Approval(owner, address(0), tokenId);\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\n        if (!_isApprovedOrOwner(msg.sender, tokenId))\n            revert ERC721Base__NotOwnerOrApproved();\n        _transfer(from, to, tokenId);\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        if (!_checkOnERC721Received(from, to, tokenId, data))\n            revert ERC721Base__ERC721ReceiverNotImplemented();\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        _safeTransferFrom(from, to, tokenId, '');\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\n        if (!_isApprovedOrOwner(msg.sender, tokenId))\n            revert ERC721Base__NotOwnerOrApproved();\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    function _approve(address operator, uint256 tokenId) internal virtual {\n        _handleApproveMessageValue(operator, tokenId, msg.value);\n\n        address owner = _ownerOf(tokenId);\n\n        if (operator == owner) revert ERC721Base__SelfApproval();\n        if (msg.sender != owner && !_isApprovedForAll(owner, msg.sender))\n            revert ERC721Base__NotOwnerOrApproved();\n\n        ERC721BaseStorage.layout().tokenApprovals[tokenId] = operator;\n        emit Approval(owner, operator, tokenId);\n    }\n\n    function _setApprovalForAll(\n        address operator,\n        bool status\n    ) internal virtual {\n        if (operator == msg.sender) revert ERC721Base__SelfApproval();\n        ERC721BaseStorage.layout().operatorApprovals[msg.sender][\n            operator\n        ] = status;\n        emit ApprovalForAll(msg.sender, operator, status);\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual returns (bool) {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes memory returnData = to.functionCall(\n            abi.encodeWithSelector(\n                IERC721Receiver(to).onERC721Received.selector,\n                msg.sender,\n                from,\n                tokenId,\n                data\n            ),\n            'ERC721: transfer to non ERC721Receiver implementer'\n        );\n\n        bytes4 returnValue = abi.decode(returnData, (bytes4));\n        return returnValue == type(IERC721Receiver).interfaceId;\n    }\n\n    /**\n     * @notice ERC721 hook, called before externally called approvals for processing of included message value\n     * @param operator beneficiary of approval\n     * @param tokenId id of transferred token\n     * @param value message value\n     */\n    function _handleApproveMessageValue(\n        address operator,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual {}\n\n    /**\n     * @notice ERC721 hook, called before externally called transfers for processing of included message value\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId id of transferred token\n     * @param value message value\n     */\n    function _handleTransferMessageValue(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual {}\n\n    /**\n     * @notice ERC721 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId id of transferred token\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/ERC721BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\n\nlibrary ERC721BaseStorage {\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC721Base');\n\n    struct Layout {\n        EnumerableMap.UintToAddressMap tokenOwners;\n        mapping(address => EnumerableSet.UintSet) holderTokens;\n        mapping(uint256 => address) tokenApprovals;\n        mapping(address => mapping(address => bool)) operatorApprovals;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/IERC721Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721 } from '../../../interfaces/IERC721.sol';\nimport { IERC721BaseInternal } from './IERC721BaseInternal.sol';\n\n/**\n * @title ERC721 base interface\n */\ninterface IERC721Base is IERC721BaseInternal, IERC721 {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/IERC721BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721Internal } from '../../../interfaces/IERC721Internal.sol';\n\n/**\n * @title ERC721 base interface\n */\ninterface IERC721BaseInternal is IERC721Internal {\n    error ERC721Base__NotOwnerOrApproved();\n    error ERC721Base__SelfApproval();\n    error ERC721Base__BalanceQueryZeroAddress();\n    error ERC721Base__ERC721ReceiverNotImplemented();\n    error ERC721Base__InvalidOwner();\n    error ERC721Base__MintToZeroAddress();\n    error ERC721Base__NonExistentToken();\n    error ERC721Base__NotTokenOwner();\n    error ERC721Base__TokenAlreadyMinted();\n    error ERC721Base__TransferToZeroAddress();\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\nimport { IERC721Enumerable } from './IERC721Enumerable.sol';\nimport { ERC721EnumerableInternal } from './ERC721EnumerableInternal.sol';\n\nabstract contract ERC721Enumerable is\n    IERC721Enumerable,\n    ERC721EnumerableInternal\n{\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply();\n    }\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) public view returns (uint256) {\n        return _tokenOfOwnerByIndex(owner, index);\n    }\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        return _tokenByIndex(index);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/ERC721EnumerableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\n\nabstract contract ERC721EnumerableInternal {\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @notice TODO\n     */\n    function _totalSupply() internal view returns (uint256) {\n        return ERC721BaseStorage.layout().tokenOwners.length();\n    }\n\n    /**\n     * @notice TODO\n     */\n    function _tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) internal view returns (uint256) {\n        return ERC721BaseStorage.layout().holderTokens[owner].at(index);\n    }\n\n    /**\n     * @notice TODO\n     */\n    function _tokenByIndex(\n        uint256 index\n    ) internal view returns (uint256 tokenId) {\n        (tokenId, ) = ERC721BaseStorage.layout().tokenOwners.at(index);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC721Enumerable {\n    /**\n     * @notice get total token supply\n     * @return total supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice get token of given owner at given internal storage index\n     * @param owner token holder to query\n     * @param index position in owner's token list to query\n     * @return tokenId id of retrieved token\n     */\n    function tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) external view returns (uint256 tokenId);\n\n    /**\n     * @notice get token at given internal storage index\n     * @param index position in global token list to query\n     * @return tokenId id of retrieved token\n     */\n    function tokenByIndex(\n        uint256 index\n    ) external view returns (uint256 tokenId);\n}\n"
    },
    "@solidstate/contracts/token/ERC721/ISolidStateERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721Base } from './base/IERC721Base.sol';\nimport { IERC721Enumerable } from './enumerable/IERC721Enumerable.sol';\nimport { IERC721Metadata } from './metadata/IERC721Metadata.sol';\n\ninterface ISolidStateERC721 is IERC721Base, IERC721Enumerable, IERC721Metadata {\n    error SolidStateERC721__PayableApproveNotSupported();\n    error SolidStateERC721__PayableTransferNotSupported();\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ERC721MetadataInternal } from './ERC721MetadataInternal.sol';\nimport { IERC721Metadata } from './IERC721Metadata.sol';\n\n/**\n * @title ERC721 metadata extensions\n */\nabstract contract ERC721Metadata is IERC721Metadata, ERC721MetadataInternal {\n    /**\n     * @notice inheritdoc IERC721Metadata\n     */\n    function name() external view virtual returns (string memory) {\n        return _name();\n    }\n\n    /**\n     * @notice inheritdoc IERC721Metadata\n     */\n    function symbol() external view virtual returns (string memory) {\n        return _symbol();\n    }\n\n    /**\n     * @notice inheritdoc IERC721Metadata\n     */\n    function tokenURI(\n        uint256 tokenId\n    ) external view virtual returns (string memory) {\n        return _tokenURI(tokenId);\n    }\n\n    /**\n     * @inheritdoc ERC721MetadataInternal\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from '../../../utils/UintUtils.sol';\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\nimport { ERC721BaseInternal } from '../base/ERC721Base.sol';\nimport { IERC721MetadataInternal } from './IERC721MetadataInternal.sol';\nimport { ERC721MetadataStorage } from './ERC721MetadataStorage.sol';\nimport { ERC721MetadataInternal } from './ERC721MetadataInternal.sol';\n\n/**\n * @title ERC721Metadata internal functions\n */\nabstract contract ERC721MetadataInternal is\n    IERC721MetadataInternal,\n    ERC721BaseInternal\n{\n    using UintUtils for uint256;\n\n    /**\n     * @notice get token name\n     * @return token name\n     */\n    function _name() internal view virtual returns (string memory) {\n        return ERC721MetadataStorage.layout().name;\n    }\n\n    /**\n     * @notice get token symbol\n     * @return token symbol\n     */\n    function _symbol() internal view virtual returns (string memory) {\n        return ERC721MetadataStorage.layout().symbol;\n    }\n\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function _tokenURI(\n        uint256 tokenId\n    ) internal view virtual returns (string memory) {\n        if (!_exists(tokenId)) revert ERC721Metadata__NonExistentToken();\n\n        ERC721MetadataStorage.Layout storage l = ERC721MetadataStorage.layout();\n\n        string memory tokenIdURI = l.tokenURIs[tokenId];\n        string memory baseURI = l.baseURI;\n\n        if (bytes(baseURI).length == 0) {\n            return tokenIdURI;\n        } else if (bytes(tokenIdURI).length > 0) {\n            return string(abi.encodePacked(baseURI, tokenIdURI));\n        } else {\n            return string(abi.encodePacked(baseURI, tokenId.toString()));\n        }\n    }\n\n    /**\n     * @notice ERC721 hook: clear per-token URI data on burn\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (to == address(0)) {\n            delete ERC721MetadataStorage.layout().tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC721MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC721Metadata');\n\n    struct Layout {\n        string name;\n        string symbol;\n        string baseURI;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721MetadataInternal } from './IERC721MetadataInternal.sol';\n\n/**\n * @title ERC721Metadata interface\n */\ninterface IERC721Metadata is IERC721MetadataInternal {\n    /**\n     * @notice get token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice get token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/IERC721MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721BaseInternal } from '../base/IERC721BaseInternal.sol';\n\n/**\n * @title ERC721Metadata internal interface\n */\ninterface IERC721MetadataInternal is IERC721BaseInternal {\n    error ERC721Metadata__NonExistentToken();\n}\n"
    },
    "@solidstate/contracts/token/ERC721/SolidStateERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ERC165Base } from '../../introspection/ERC165/base/ERC165Base.sol';\nimport { ERC721Base, ERC721BaseInternal } from './base/ERC721Base.sol';\nimport { ERC721Enumerable } from './enumerable/ERC721Enumerable.sol';\nimport { ERC721Metadata } from './metadata/ERC721Metadata.sol';\nimport { ISolidStateERC721 } from './ISolidStateERC721.sol';\n\n/**\n * @title SolidState ERC721 implementation, including recommended extensions\n */\nabstract contract SolidStateERC721 is\n    ISolidStateERC721,\n    ERC721Base,\n    ERC721Enumerable,\n    ERC721Metadata,\n    ERC165Base\n{\n    /**\n     * @notice ERC721 hook: revert if value is included in external approve function call\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _handleApproveMessageValue(\n        address operator,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual override {\n        if (value > 0) revert SolidStateERC721__PayableApproveNotSupported();\n        super._handleApproveMessageValue(operator, tokenId, value);\n    }\n\n    /**\n     * @notice ERC721 hook: revert if value is included in external transfer function call\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _handleTransferMessageValue(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual override {\n        if (value > 0) revert SolidStateERC721__PayableTransferNotSupported();\n        super._handleTransferMessageValue(from, to, tokenId, value);\n    }\n\n    /**\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721BaseInternal, ERC721Metadata) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/ArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ArrayUtils {\n    /**\n     * @notice get minimum value in given array\n     * @param array array to search\n     * @return minimum value\n     */\n    function min(bytes32[] memory array) internal pure returns (bytes32) {\n        bytes32 minValue = bytes32(type(uint256).max);\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] < minValue) {\n                    minValue = array[i];\n                }\n            }\n        }\n\n        return minValue;\n    }\n\n    /**\n     * @notice get minimum value in given array\n     * @param array array to search\n     * @return minimum value\n     */\n    function min(address[] memory array) internal pure returns (address) {\n        address minValue = address(type(uint160).max);\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] < minValue) {\n                    minValue = array[i];\n                }\n            }\n        }\n\n        return minValue;\n    }\n\n    /**\n     * @notice get minimum value in given array\n     * @param array array to search\n     * @return minimum value\n     */\n    function min(uint256[] memory array) internal pure returns (uint256) {\n        uint256 minValue = type(uint256).max;\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] < minValue) {\n                    minValue = array[i];\n                }\n            }\n        }\n\n        return minValue;\n    }\n\n    /**\n     * @notice get maximum value in given array\n     * @param array array to search\n     * @return maximum value\n     */\n    function max(bytes32[] memory array) internal pure returns (bytes32) {\n        bytes32 maxValue = bytes32(0);\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] > maxValue) {\n                    maxValue = array[i];\n                }\n            }\n        }\n\n        return maxValue;\n    }\n\n    /**\n     * @notice get maximum value in given array\n     * @param array array to search\n     * @return maximum value\n     */\n    function max(address[] memory array) internal pure returns (address) {\n        address maxValue = address(0);\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] > maxValue) {\n                    maxValue = array[i];\n                }\n            }\n        }\n\n        return maxValue;\n    }\n\n    /**\n     * @notice get maximum value in given array\n     * @param array array to search\n     * @return maximum value\n     */\n    function max(uint256[] memory array) internal pure returns (uint256) {\n        uint256 maxValue = 0;\n\n        unchecked {\n            for (uint256 i; i < array.length; i++) {\n                if (array[i] > maxValue) {\n                    maxValue = array[i];\n                }\n            }\n        }\n\n        return maxValue;\n    }\n}\n"
    },
    "@solidstate/contracts/utils/IMulticall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Interface for the Multicall utility contract\n */\ninterface IMulticall {\n    /**\n     * @notice batch function calls to the contract and return the results of each\n     * @param data array of function call data payloads\n     * @return results array of function call results\n     */\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n}\n"
    },
    "@solidstate/contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IMulticall } from './IMulticall.sol';\n\n/**\n * @title Utility contract for supporting processing of multiple function calls in a single transaction\n */\nabstract contract Multicall is IMulticall {\n    /**\n     * @inheritdoc IMulticall\n     */\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n\n        unchecked {\n            for (uint256 i; i < data.length; i++) {\n                (bool success, bytes memory returndata) = address(this)\n                    .delegatecall(data[i]);\n\n                if (success) {\n                    results[i] = returndata;\n                } else {\n                    assembly {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        }\n\n        return results;\n    }\n}\n"
    },
    "@solidstate/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ReentrancyGuardStorage } from './ReentrancyGuardStorage.sol';\n\n/**\n * @title Utility contract for preventing reentrancy attacks\n */\nabstract contract ReentrancyGuard {\n    error ReentrancyGuard__ReentrantCall();\n\n    modifier nonReentrant() {\n        ReentrancyGuardStorage.Layout storage l = ReentrancyGuardStorage\n            .layout();\n        if (l.status == 2) revert ReentrancyGuard__ReentrantCall();\n        l.status = 2;\n        _;\n        l.status = 1;\n    }\n}\n"
    },
    "@solidstate/contracts/utils/ReentrancyGuardStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ReentrancyGuardStorage {\n    struct Layout {\n        uint256 status;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ReentrancyGuard');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/arcadiaDiamonds/arcadians/ArcadiansFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { ERC721BaseInternal } from \"@solidstate/contracts/token/ERC721/base/ERC721BaseInternal.sol\";\nimport { ERC721Metadata } from \"@solidstate/contracts/token/ERC721/metadata/ERC721Metadata.sol\";\nimport { ISolidStateERC721 } from \"@solidstate/contracts/token/ERC721/ISolidStateERC721.sol\";\nimport { SolidStateERC721 } from \"@solidstate/contracts/token/ERC721/SolidStateERC721.sol\";\nimport { ERC721Base } from \"@solidstate/contracts/token/ERC721/base/ERC721Base.sol\";\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\nimport { IERC721Metadata } from \"@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol\";\nimport { ArcadiansInternal } from \"./ArcadiansInternal.sol\";\nimport { ArcadiansStorage } from \"./ArcadiansStorage.sol\";\nimport { EnumerableMap } from '@solidstate/contracts/data/EnumerableMap.sol';\nimport { Multicall } from \"@solidstate/contracts/utils/Multicall.sol\";\nimport { InventoryStorage } from \"../inventory/InventoryStorage.sol\";\nimport { WhitelistStorage } from \"../whitelist/WhitelistStorage.sol\";\n\n/**\n * @title ArcadiansFacet\n * @notice This contract is an ERC721 responsible for minting and claiming Arcadian tokens.\n * @dev ReentrancyGuard and Multicall contracts are used for security and gas efficiency.\n */\ncontract ArcadiansFacet is SolidStateERC721, ArcadiansInternal, Multicall {\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    WhitelistStorage.PoolId constant GuaranteedPool = WhitelistStorage.PoolId.Guaranteed;\n    WhitelistStorage.PoolId constant RestrictedPool = WhitelistStorage.PoolId.Restricted;\n\n    /**\n     * @notice Returns the URI for a given arcadian\n     * @param tokenId ID of the token to query\n     * @return The URI for the given token ID\n     */\n    function tokenURI(\n        uint tokenId\n    ) external view override (ERC721Metadata, IERC721Metadata) returns (string memory) {\n        return _tokenURI(tokenId);\n    }\n\n    function _mint() internal returns (uint tokenId) {\n        ArcadiansStorage.Layout storage arcadiansSL = ArcadiansStorage.layout();\n\n        tokenId = nextArcadianId();\n\n        if (tokenId > arcadiansSL.arcadiansMaxSupply)\n            revert Arcadians_MaximumArcadiansSupplyReached();\n\n        uint nonGuaranteedMintedAmount = _claimedWhitelist(RestrictedPool, msg.sender) + _claimedMintPass(msg.sender) + arcadiansSL.userPublicMints[msg.sender];\n\n        if (_isWhitelistClaimActive(GuaranteedPool) && _elegibleWhitelist(GuaranteedPool, msg.sender) > 0) {\n            // OG mint flow\n            _consumeWhitelist(GuaranteedPool, msg.sender, 1);\n        } else if (nonGuaranteedMintedAmount < arcadiansSL.maxMintPerUser) {\n\n            if (_isMintPassClaimActive() && _elegibleMintPass(msg.sender) > 0) {\n                // Magic Eden mint flow\n                _consumeMintPass(msg.sender);\n            } else if (_isWhitelistClaimActive(RestrictedPool) && _elegibleWhitelist(RestrictedPool, msg.sender) > 0) { \n                // Whitelist mint flow\n                _consumeWhitelist(RestrictedPool, msg.sender, 1);\n\n            } else if (arcadiansSL.isPublicMintOpen) {\n                if (msg.value != arcadiansSL.mintPrice)\n                    revert Arcadians_InvalidPayAmount();\n                arcadiansSL.userPublicMints[msg.sender]++;\n            } else {\n                revert Arcadians_NotElegibleToMint();\n            }\n        } else {\n            revert Arcadians_NotElegibleToMint();\n        }\n\n        _safeMint(msg.sender, tokenId);\n    }\n\n    /**\n     * @notice Returns the amount of arcadians that can be minted by an account\n     * @param account account to query\n     * @return balance amount of arcadians that can be minted\n     */\n    function availableMints(address account) external view returns (uint balance) {\n        ArcadiansStorage.Layout storage arcadiansSL = ArcadiansStorage.layout();\n\n        uint totalSupply = totalSupply();\n        uint arcadiansMaxSupply = arcadiansSL.arcadiansMaxSupply;\n        if (totalSupply >= arcadiansMaxSupply) {\n            return 0;\n        }\n\n        uint mintPerUserMax = arcadiansSL.maxMintPerUser;\n        uint nonGuaranteedAvailableMints;\n        if (_isWhitelistClaimActive(RestrictedPool)) {\n            nonGuaranteedAvailableMints += _elegibleWhitelist(RestrictedPool, account);\n        } \n        if (_isMintPassClaimActive()) {\n            nonGuaranteedAvailableMints += _elegibleMintPass(account);\n        }\n        if (arcadiansSL.isPublicMintOpen) {\n            nonGuaranteedAvailableMints += mintPerUserMax - arcadiansSL.userPublicMints[account];\n        }\n        uint nonGuaranteedMintedAmount = _claimedWhitelist(RestrictedPool, account) + _claimedMintPass(account) + arcadiansSL.userPublicMints[account];\n\n        if (nonGuaranteedMintedAmount >= mintPerUserMax) {\n            nonGuaranteedAvailableMints = 0;\n        } else  {\n            uint ceil = mintPerUserMax - nonGuaranteedMintedAmount;\n            nonGuaranteedAvailableMints = nonGuaranteedAvailableMints > ceil ? ceil : nonGuaranteedAvailableMints;\n        }\n\n        uint guaranteedAvailableMints;\n        if (_isWhitelistClaimActive(GuaranteedPool)) {\n            guaranteedAvailableMints += _elegibleWhitelist(GuaranteedPool, account);\n        }\n\n        uint availableAmount = guaranteedAvailableMints + nonGuaranteedAvailableMints;\n\n        if (totalSupply + availableAmount > arcadiansMaxSupply) {\n            return arcadiansMaxSupply - totalSupply;\n        }\n\n        return availableAmount;\n    }\n\n    /**\n     * @notice Returns the total amount of arcadians minted\n     * @return uint total amount of arcadians minted\n     */\n    function totalMinted() external view returns (uint) {\n        return _totalSupply();\n    }\n\n   /**\n     * @notice Mint a token and equip it with the given items\n     * @param itemsToEquip array of items to equip in the correspondent slot\n     */\n    function mintAndEquip(\n        InventoryStorage.Item[] calldata itemsToEquip\n    )\n        external payable nonReentrant\n    {\n        uint tokenId = _mint();\n        _equip(tokenId, itemsToEquip, true);\n    }\n\n    /**\n     * @notice This function sets the public mint as open/closed\n     */\n    function setPublicMintOpen(bool isOpen) external onlyManager {\n        ArcadiansStorage.Layout storage arcadiansSL = ArcadiansStorage.layout();\n        arcadiansSL.isPublicMintOpen = isOpen;\n    }\n    /**\n     * @notice Returns true if the public mint is open, false otherwise\n     */\n    function publicMintOpen() external view returns (bool) {\n        return ArcadiansStorage.layout().isPublicMintOpen;\n    }\n\n    /**\n     * @notice This function updates the price to mint an arcadian\n     * @param newMintPrice The new mint price to be set\n     */\n    function setMintPrice(uint newMintPrice) external onlyManager {\n        _setMintPrice(newMintPrice);\n    }\n\n    /**\n     * @notice This function gets the current price to mint an arcadian\n     * @return The current mint price\n     */\n    function mintPrice() external view returns (uint) {\n        return _mintPrice();\n    }\n\n    /**\n     * @notice This function sets the new maximum number of arcadians that a user can mint\n     * @param newMaxMintPerUser The new maximum number of arcadians that a user can mint\n     */\n    function setMaxMintPerUser(uint newMaxMintPerUser) external onlyManager {\n        _setMaxMintPerUser(newMaxMintPerUser);\n    }\n\n    /**\n     * @dev This function gets the current maximum number of arcadians that a user can mint\n     * @return The current maximum number of arcadians that a user can mint\n     */\n    function maxMintPerUser() external view returns (uint) {\n        return _maxMintPerUser();\n    }\n\n    /**\n     * @dev This function returns the maximum supply of arcadians\n     * @return The current maximum supply of arcadians\n     */\n    function maxSupply() external view returns (uint) {\n        return ArcadiansStorage.layout().arcadiansMaxSupply;\n    }\n\n    /**\n     * @notice Sets the max arcadians supply\n     * @param maxArcadiansSupply The max supply of arcadians that can be minted\n     */\n    function setMaxSupply(uint maxArcadiansSupply) external onlyManager {\n        _setMaxSupply(maxArcadiansSupply);\n    }\n\n    /**\n     * @notice Set the base URI for all Arcadians metadata\n     * @notice Only the manager role can call this function\n     * @param newBaseURI The new base URI for all token metadata\n     */\n    function setBaseURI(string memory newBaseURI) external onlyManager {\n        _setBaseURI(newBaseURI);\n    }\n\n    /**\n     * @dev This function returns the base URI\n     * @return The base URI\n     */\n    function baseURI() external view returns (string memory) {\n        return _baseURI();\n    }\n\n    function nextArcadianId() internal view returns (uint arcadianId) {\n        arcadianId = _totalSupply() + 1;\n    }\n}"
    },
    "contracts/arcadiaDiamonds/arcadians/ArcadiansInit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { ArcadiansInternal } from \"./ArcadiansInternal.sol\";\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\nimport { ERC165BaseInternal } from '@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol';\n\ncontract ArcadiansInit is RolesInternal, ArcadiansInternal, ERC165BaseInternal {\n    function init(\n        string calldata baseUri, \n        uint maxMintPerUser, \n        uint mintPrice, \n        address mintPassAddress, \n        uint arcadiansMaxSupply\n    ) external {\n\n        _setSupportsInterface(type(IERC721).interfaceId, true);\n\n        // Roles facet\n        _initRoles();\n\n        // Arcadians facet\n        _setBaseURI(baseUri);\n        _setMaxMintPerUser(maxMintPerUser);\n        _setMintPrice(mintPrice);\n        _setMaxSupply(arcadiansMaxSupply);\n\n        // Mint pass\n        _setMintPassContractAddress(mintPassAddress);\n    }\n}\n"
    },
    "contracts/arcadiaDiamonds/arcadians/ArcadiansInternal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { ERC721MetadataStorage } from \"@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol\";\nimport { UintUtils } from '@solidstate/contracts/utils/UintUtils.sol';\nimport { ArcadiansStorage } from \"./ArcadiansStorage.sol\";\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { WhitelistInternal } from \"../whitelist/WhitelistInternal.sol\";\nimport { WhitelistStorage } from \"../whitelist/WhitelistStorage.sol\";\nimport { InventoryInternal } from \"../inventory/InventoryInternal.sol\";\nimport { MintPassInternal } from \"../mintPass/MintPassInternal.sol\";\n\ncontract ArcadiansInternal is RolesInternal, WhitelistInternal, InventoryInternal, MintPassInternal {\n\n    error Arcadians_InvalidPayAmount();\n    error Arcadians_MaximumArcadiansSupplyReached();\n    error Arcadians_NotElegibleToMint();\n\n    event MaxMintPerUserChanged(address indexed by, uint oldMaxMintPerUser, uint newMaxMintPerUser);\n    event MintPriceChanged(address indexed by, uint oldMintPrice, uint newMintPrice);\n    event BaseURIChanged(address indexed by, string oldBaseURI, string newBaseURI);\n\n    using UintUtils for uint;\n\n    function _setBaseURI(string memory newBaseURI) internal {\n        ERC721MetadataStorage.Layout storage ERC721SL = ERC721MetadataStorage.layout();\n        emit BaseURIChanged(msg.sender, ERC721SL.baseURI, newBaseURI);\n        ERC721SL.baseURI = newBaseURI;\n    }\n\n    function _baseURI() internal view returns (string memory) {\n        return ERC721MetadataStorage.layout().baseURI;\n    }\n\n    function _mintPrice() internal view returns (uint) {\n        return ArcadiansStorage.layout().mintPrice;\n    }\n\n    function _setMintPrice(uint newMintPrice) internal {\n        ArcadiansStorage.Layout storage arcadiansSL = ArcadiansStorage.layout();\n        emit MintPriceChanged(msg.sender, arcadiansSL.mintPrice, newMintPrice);\n        arcadiansSL.mintPrice = newMintPrice;\n    }\n\n    function _setMaxMintPerUser(uint newMaxMintPerUser) internal {\n        ArcadiansStorage.Layout storage arcadiansSL = ArcadiansStorage.layout();\n        emit MaxMintPerUserChanged(msg.sender, arcadiansSL.maxMintPerUser, newMaxMintPerUser);\n        arcadiansSL.maxMintPerUser = newMaxMintPerUser;\n    }\n\n    function _maxMintPerUser() internal view returns (uint) {\n        return ArcadiansStorage.layout().maxMintPerUser;\n    }\n\n    function _setMaxSupply(uint arcadiansMaxSupply) internal {\n        ArcadiansStorage.Layout storage arcadiansSL = ArcadiansStorage.layout();\n        \n        arcadiansSL.arcadiansMaxSupply = arcadiansMaxSupply;\n    }\n}"
    },
    "contracts/arcadiaDiamonds/arcadians/ArcadiansStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nlibrary ArcadiansStorage {\n\n    bytes32 constant ARCADIANS_STORAGE_POSITION =\n        keccak256(\"equippable.storage.position\");\n\n    struct Layout {\n        uint maxMintPerUser;\n        uint mintPrice;\n        bool isPublicMintOpen;\n        // account => amount minted with public mint\n        mapping(address => uint) userPublicMints;\n        uint arcadiansMaxSupply;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = ARCADIANS_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/inventory/InventoryInternal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { ReentrancyGuard } from \"@solidstate/contracts/utils/ReentrancyGuard.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { AddressUtils } from \"@solidstate/contracts/utils/AddressUtils.sol\";\nimport { ArrayUtils } from \"@solidstate/contracts/utils/ArrayUtils.sol\";\nimport { EnumerableSet } from \"@solidstate/contracts/data/EnumerableSet.sol\";\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { InventoryStorage } from \"./InventoryStorage.sol\";\nimport { IERC1155 } from \"@solidstate/contracts/interfaces/IERC1155.sol\";\n\ncontract InventoryInternal is\n    ReentrancyGuard,\n    RolesInternal\n{\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using AddressUtils for address;\n\n    error Inventory_InvalidERC1155Contract();\n    error Inventory_UnequippingPermanentSlot();\n    error Inventory_InvalidSlotId();\n    error Inventory_ItemDoesNotHaveSlotAssigned();\n    error Inventory_InsufficientItemBalance();\n    error Inventory_UnequippingEmptySlot();\n    error Inventory_UnequippingBaseSlot();\n    error Inventory_NotArcadianOwner();\n    error Inventory_ArcadianNotUnique();\n    error Inventory_NotAllBaseSlotsEquipped();\n    error Inventory_InputDataMismatch();\n    error Inventory_ItemAlreadyEquippedInSlot();\n    error Inventory_CouponNeededToModifyBaseSlots();\n    error Inventory_NonBaseSlot();\n\n    event ItemsAllowedInSlotUpdated(\n        address indexed by,\n        InventoryStorage.Item[] items\n    );\n\n    event ItemsEquipped(\n        address indexed by,\n        uint indexed arcadianId,\n        uint8[] slots\n    );\n\n    event ItemsUnequipped(\n        address indexed by,\n        uint indexed arcadianId,\n        uint8[] slotsIds\n    );\n\n    event SlotCreated(\n        address indexed by,\n        uint8 indexed slotId,\n        bool permanent,\n        bool isBase\n    );\n\n    event BaseModifierCouponAdded(\n        address indexed by,\n        address indexed to,\n        uint8[] slotsIds,\n        uint[] amounts\n    );\n\n    event BaseModifierCouponConsumed(\n        address indexed account,\n        uint indexed arcadianId,\n        uint8[] slotsIds\n    );\n\n    // Helper structs only used in view functions to ease data reading from web3\n    struct ItemInSlot {\n        uint8 slotId;\n        address erc1155Contract;\n        uint itemId;\n    }\n    struct BaseModifierCoupon {\n        uint8 slotId;\n        uint amount;\n    }\n\n    modifier onlyValidSlot(uint8 slotId) {\n        if (slotId == 0 || slotId > InventoryStorage.layout().numSlots) revert Inventory_InvalidSlotId();\n        _;\n    }\n\n    modifier onlyArcadianOwner(uint arcadianId) {\n        IERC721 arcadiansContract = IERC721(address(this));\n        if (msg.sender != arcadiansContract.ownerOf(arcadianId)) revert Inventory_NotArcadianOwner();\n        _;\n    }\n\n    function _numSlots() internal view returns (uint) {\n        return InventoryStorage.layout().numSlots;\n    }\n\n    function _equip(\n        uint arcadianId,\n        InventoryStorage.Item[] calldata items,\n        bool freeBaseModifier\n    ) internal onlyArcadianOwner(arcadianId) {\n\n        if (items.length == 0) \n            return;\n\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        uint8 numBaseSlotsModified;\n        uint8[] memory slotsIds = new uint8[](items.length);\n        for (uint i = 0; i < items.length; i++) {\n            uint8 slotId = inventorySL.itemSlot[items[i].erc1155Contract][items[i].id];\n            slotsIds[i] = slotId;\n\n            InventoryStorage.Item storage existingItem = inventorySL.equippedItems[arcadianId][slotId];\n            if (existingItem.erc1155Contract == items[i].erc1155Contract && existingItem.id == items[i].id) {\n                continue;\n            }\n\n            _equipSingleSlot(arcadianId, items[i], freeBaseModifier);\n            if (inventorySL.slots[slotId].isBase) {\n                numBaseSlotsModified++;\n            }\n        }\n\n        if (!_baseAndPermanentSlotsEquipped(arcadianId)) \n            revert Inventory_NotAllBaseSlotsEquipped();\n\n        if (numBaseSlotsModified > 0) {\n            if (!_hashBaseItemsUnchecked(arcadianId))\n                revert Inventory_ArcadianNotUnique();\n\n            if (!freeBaseModifier) {\n                uint8[] memory baseSlotsModified = new uint8[](numBaseSlotsModified);\n                uint counter;\n                for (uint i = 0; i < items.length; i++) {\n                    uint8 slotId = inventorySL.itemSlot[items[i].erc1155Contract][items[i].id];\n                    if (inventorySL.slots[slotId].isBase) {\n                        baseSlotsModified[counter] = slotId;\n                        counter++;\n                    }\n                }\n                emit BaseModifierCouponConsumed(msg.sender, arcadianId, baseSlotsModified);\n            }\n        }\n\n        emit ItemsEquipped(msg.sender, arcadianId, slotsIds);\n    }\n\n    function _equipSingleSlot(\n        uint arcadianId,\n        InventoryStorage.Item calldata item,\n        bool freeBaseModifier\n    ) internal returns (uint8 slotId) {\n\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        slotId = inventorySL.itemSlot[item.erc1155Contract][item.id];\n        \n        if (slotId == 0 || slotId > InventoryStorage.layout().numSlots) \n            revert Inventory_ItemDoesNotHaveSlotAssigned();\n        \n        if (!freeBaseModifier && inventorySL.slots[slotId].isBase) {\n            if (inventorySL.baseModifierCoupon[msg.sender][slotId] == 0)\n                revert Inventory_CouponNeededToModifyBaseSlots();\n\n            inventorySL.baseModifierCoupon[msg.sender][slotId]--;\n        }\n\n        InventoryStorage.Item storage existingItem = inventorySL.equippedItems[arcadianId][slotId];\n        if (inventorySL.slots[slotId].permanent && existingItem.erc1155Contract != address(0)) \n            revert Inventory_UnequippingPermanentSlot();\n\n        if (inventorySL.equippedItems[arcadianId][slotId].erc1155Contract != address(0))\n            _unequipUnchecked(arcadianId, slotId);\n\n        bool requiresTransfer = inventorySL.requiresTransfer[item.erc1155Contract][item.id];\n        if (requiresTransfer) {\n            IERC1155 erc1155Contract = IERC1155(item.erc1155Contract);\n            if (erc1155Contract.balanceOf(msg.sender, item.id) < 1)\n                revert Inventory_InsufficientItemBalance();\n\n            erc1155Contract.safeTransferFrom(\n                msg.sender,\n                address(this),\n                item.id,\n                1,\n                ''\n            );\n        }\n\n        inventorySL.equippedItems[arcadianId][slotId] = item;\n    }\n\n    function _baseAndPermanentSlotsEquipped(uint arcadianId) internal view returns (bool) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        uint8 numSlots = inventorySL.numSlots;\n        for (uint8 i = 0; i < numSlots; i++) {\n            uint8 slotId = i + 1;\n            InventoryStorage.Slot storage slot = inventorySL.slots[slotId];\n            if (!slot.isBase && !slot.permanent)\n                continue;\n            if (inventorySL.equippedItems[arcadianId][slotId].erc1155Contract == address(0)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _unequipUnchecked(\n        uint arcadianId,\n        uint8 slotId\n    ) internal {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        InventoryStorage.Item storage existingItem = inventorySL.equippedItems[arcadianId][slotId];\n\n        bool requiresTransfer = inventorySL.requiresTransfer[existingItem.erc1155Contract][existingItem.id];\n        if (requiresTransfer) {\n            IERC1155 erc1155Contract = IERC1155(existingItem.erc1155Contract);\n            erc1155Contract.safeTransferFrom(\n                address(this),\n                msg.sender,\n                existingItem.id,\n                1,\n                ''\n            );\n        }\n        delete inventorySL.equippedItems[arcadianId][slotId];\n    }\n\n    function _unequip(\n        uint arcadianId,\n        uint8[] calldata slotsIds\n    ) internal onlyArcadianOwner(arcadianId) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        if (slotsIds.length == 0) \n            return;\n\n        for (uint i = 0; i < slotsIds.length; i++) {\n            if (inventorySL.slots[slotsIds[i]].permanent) \n                revert Inventory_UnequippingPermanentSlot();\n\n            if (inventorySL.equippedItems[arcadianId][slotsIds[i]].erc1155Contract == address(0)) \n                revert Inventory_UnequippingEmptySlot();\n            \n            if (inventorySL.slots[slotsIds[i]].isBase)\n                revert Inventory_UnequippingBaseSlot();\n\n            _unequipUnchecked(arcadianId, slotsIds[i]);\n        }\n\n        _hashBaseItemsUnchecked(arcadianId);\n\n        emit ItemsUnequipped(\n            msg.sender,\n            arcadianId,\n            slotsIds\n        );\n    }\n\n    function _equipped(\n        uint arcadianId,\n        uint8 slotId\n    ) internal view returns (ItemInSlot memory) {\n        InventoryStorage.Item storage item = InventoryStorage.layout().equippedItems[arcadianId][slotId];\n        return ItemInSlot(slotId, item.erc1155Contract, item.id);\n    }\n\n    function _equippedBatch(\n        uint arcadianId,\n        uint8[] calldata slotsIds\n    ) internal view returns (ItemInSlot[] memory equippedSlots) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        equippedSlots = new ItemInSlot[](slotsIds.length);\n        for (uint i = 0; i < slotsIds.length; i++) {\n            InventoryStorage.Item storage equippedItem = inventorySL.equippedItems[arcadianId][slotsIds[i]];\n            equippedSlots[i] = ItemInSlot(slotsIds[i], equippedItem.erc1155Contract, equippedItem.id);\n        }\n    }\n\n    function _equippedAll(\n        uint arcadianId\n    ) internal view returns (ItemInSlot[] memory equippedSlots) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        uint8 numSlots = inventorySL.numSlots;\n        equippedSlots = new ItemInSlot[](numSlots);\n        for (uint8 i = 0; i < numSlots; i++) {\n            uint8 slotId = i + 1;\n            InventoryStorage.Item storage equippedItem = inventorySL.equippedItems[arcadianId][slotId];\n            equippedSlots[i] = ItemInSlot(slotId, equippedItem.erc1155Contract, equippedItem.id);\n        }\n    }\n\n    function _isArcadianUnique(\n        uint arcadianId,\n        InventoryStorage.Item[] calldata items\n    ) internal view returns (bool) {\n\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        bytes memory encodedItems;\n        uint numBaseSlots = inventorySL.baseSlotsIds.length;\n\n        for (uint8 i = 0; i < numBaseSlots; i++) {\n            uint8 slotId = inventorySL.baseSlotsIds[i];\n\n            InventoryStorage.Item memory item;\n            for (uint j = 0; j < items.length; j++) {\n                if (_allowedSlot(items[j]) == slotId) {\n                    item = items[j];\n                    break;\n                }\n            }\n            if (item.erc1155Contract == address(0)) {\n                if (inventorySL.equippedItems[arcadianId][slotId].erc1155Contract != address(0)) {\n                    item = inventorySL.equippedItems[arcadianId][slotId];\n                } else {\n                    revert Inventory_NotAllBaseSlotsEquipped();\n                }\n            }\n            \n            encodedItems = abi.encodePacked(encodedItems, slotId, item.erc1155Contract, item.id);\n        }\n\n        return inventorySL.arcadianToBaseItemHash[arcadianId] == keccak256(encodedItems) || !inventorySL.baseItemsHashes.contains(keccak256(encodedItems));\n    }\n\n    function _hashBaseItemsUnchecked(\n        uint arcadianId\n    ) internal returns (bool isUnique) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        bytes memory encodedItems;\n        uint numBaseSlots = inventorySL.baseSlotsIds.length;\n\n        for (uint8 i = 0; i < numBaseSlots; i++) {\n            uint8 slotId = inventorySL.baseSlotsIds[i];\n            \n            InventoryStorage.Item storage equippedItem = inventorySL.equippedItems[arcadianId][slotId];\n            encodedItems = abi.encodePacked(encodedItems, slotId, equippedItem.erc1155Contract, equippedItem.id);\n        }\n\n        bytes32 baseItemsHash = keccak256(encodedItems);\n\n        isUnique = inventorySL.arcadianToBaseItemHash[arcadianId] == baseItemsHash || !inventorySL.baseItemsHashes.contains(baseItemsHash);\n        inventorySL.baseItemsHashes.remove(inventorySL.arcadianToBaseItemHash[arcadianId]);\n        inventorySL.baseItemsHashes.add(baseItemsHash);\n        inventorySL.arcadianToBaseItemHash[arcadianId] = baseItemsHash;\n    }\n\n    function _createSlot(\n        bool permanent,\n        bool isBase,\n        InventoryStorage.Item[] calldata allowedItems\n    ) internal {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        // slots are 1-index\n        inventorySL.numSlots += 1;\n        uint8 newSlotId = inventorySL.numSlots;\n        inventorySL.slots[newSlotId].permanent = permanent;\n        inventorySL.slots[newSlotId].isBase = isBase;\n        inventorySL.slots[newSlotId].id = newSlotId;\n\n        _setSlotBase(newSlotId, isBase);\n\n        if (allowedItems.length > 0) {\n            _allowItemsInSlot(newSlotId, allowedItems);\n        }\n\n        emit SlotCreated(msg.sender, newSlotId, permanent, isBase);\n    }\n\n    function _setSlotBase(\n        uint8 slotId,\n        bool isBase\n    ) internal onlyValidSlot(slotId) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        uint8[] storage baseSlotsIds = inventorySL.baseSlotsIds;\n        uint numBaseSlots = baseSlotsIds.length;\n\n        if (isBase) {\n            bool alreadyInBaseList;\n            for (uint i = 0; i < numBaseSlots; i++) {\n                if (baseSlotsIds[i] == slotId) {\n                    alreadyInBaseList = true;\n                    break;\n                }\n            }\n            if (!alreadyInBaseList) {\n                baseSlotsIds.push(slotId);\n            }\n        } else {\n            for (uint i = 0; i < numBaseSlots; i++) {\n                if (baseSlotsIds[i] == slotId) {\n                    baseSlotsIds[i] = baseSlotsIds[numBaseSlots - 1];\n                    baseSlotsIds.pop();\n                    break;\n                }\n            }\n        }\n\n        inventorySL.slots[slotId].isBase = isBase;\n    }\n\n    function _setSlotPermanent(\n        uint8 slotId,\n        bool permanent\n    ) internal onlyValidSlot(slotId) {\n        InventoryStorage.layout().slots[slotId].permanent = permanent;\n    }\n\n    function _addBaseModifierCoupons(\n        address account,\n        uint8[] calldata slotsIds,\n        uint[] calldata amounts\n    ) internal {\n        if (slotsIds.length != amounts.length)\n            revert Inventory_InputDataMismatch();\n\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        uint8 numSlots = inventorySL.numSlots;\n\n        for (uint i = 0; i < slotsIds.length; i++) {\n            if (slotsIds[i] == 0 && slotsIds[i] > numSlots) \n                revert Inventory_InvalidSlotId();\n            if (!inventorySL.slots[slotsIds[i]].isBase) {\n                revert Inventory_NonBaseSlot();\n            }\n            InventoryStorage.layout().baseModifierCoupon[account][slotsIds[i]] += amounts[i];\n        }\n\n        emit BaseModifierCouponAdded(msg.sender, account, slotsIds, amounts);\n    }\n\n    function _getbaseModifierCoupon(address account, uint8 slotId) internal view onlyValidSlot(slotId) returns (uint) {\n        if (!InventoryStorage.layout().slots[slotId].isBase) {\n            revert Inventory_NonBaseSlot();\n        }\n        return InventoryStorage.layout().baseModifierCoupon[account][slotId];\n    }\n\n    function _getBaseModifierCouponAll(address account) internal view returns (BaseModifierCoupon[] memory) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        uint numBaseSlots = inventorySL.baseSlotsIds.length;\n\n        BaseModifierCoupon[] memory coupons = new BaseModifierCoupon[](numBaseSlots);\n        uint counter;\n        for (uint8 i = 0; i < numBaseSlots; i++) {\n            uint8 slotId = uint8(inventorySL.baseSlotsIds[i]);\n\n            coupons[counter].slotId = slotId;\n            coupons[counter].amount = inventorySL.baseModifierCoupon[account][slotId];\n            counter++;\n        }\n        return coupons;\n    }\n\n    function _getBaseSlotsIds() internal view returns (uint8[] memory) {\n        return InventoryStorage.layout().baseSlotsIds;\n    }\n\n    function _setItemsTransferRequired(\n        InventoryStorage.Item[] calldata items,\n        bool[] calldata requiresTransfer\n    ) internal {\n        if (items.length != requiresTransfer.length)\n            revert Inventory_InputDataMismatch();\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        for (uint i = 0; i < items.length; i++) {\n            inventorySL.requiresTransfer[items[i].erc1155Contract][items[i].id] = requiresTransfer[i];\n        }\n    }\n    \n    function _allowItemsInSlot(\n        uint8 slotId,\n        InventoryStorage.Item[] calldata items\n    ) internal virtual onlyValidSlot(slotId) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        for (uint i = 0; i < items.length; i++) {\n            if (!items[i].erc1155Contract.isContract()) \n                revert Inventory_InvalidERC1155Contract();\n\n            inventorySL.itemSlot[items[i].erc1155Contract][items[i].id] = slotId;\n        }\n\n        emit ItemsAllowedInSlotUpdated(msg.sender, items);\n    }\n\n    function _disallowItems(\n        InventoryStorage.Item[] calldata items\n    ) internal virtual {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        for (uint i = 0; i < items.length; i++) {\n            delete inventorySL.itemSlot[items[i].erc1155Contract][items[i].id];\n        }\n\n        emit ItemsAllowedInSlotUpdated(msg.sender, items);\n    }\n\n    function _allowedSlot(InventoryStorage.Item calldata item) internal view returns (uint) {\n        return InventoryStorage.layout().itemSlot[item.erc1155Contract][item.id];\n    }\n\n    function _slot(uint8 slotId) internal view returns (InventoryStorage.Slot storage slot) {\n        return InventoryStorage.layout().slots[slotId];\n    }\n\n    function _slotsAll() internal view returns (InventoryStorage.Slot[] memory slotsAll) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        \n        uint8 numSlots = inventorySL.numSlots;\n        slotsAll = new InventoryStorage.Slot[](numSlots);\n\n        for (uint8 i = 0; i < numSlots; i++) {\n            uint8 slotId = i + 1;\n            slotsAll[i] = inventorySL.slots[slotId];\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/inventory/InventoryStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport {ReentrancyGuard} from \"@solidstate/contracts/utils/ReentrancyGuard.sol\";\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { EnumerableSet } from \"@solidstate/contracts/data/EnumerableSet.sol\";\n\n/**\nLibInventory defines the storage structure used by the Inventory contract as a facet for an EIP-2535 Diamond\nproxy.\n */\nlibrary InventoryStorage {\n    bytes32 constant INVENTORY_STORAGE_POSITION =\n        keccak256(\"inventory.storage.position\");\n\n    // Holds the information needed to identify an ERC1155 item\n    struct Item {\n        address erc1155Contract;\n        uint id;\n    }\n\n    // Holds the general information about a slot\n    struct Slot {\n        uint8 id;\n        bool permanent;\n        bool isBase;\n    }\n\n    struct Layout {\n        uint8 numSlots;\n\n        // Slot id => Slot\n        mapping(uint8 => Slot) slots;\n\n        // arcadian id => slot id => Items equipped\n        mapping(uint => mapping(uint8 => Item)) equippedItems;\n\n        // item address => item id => allowed slot id\n        mapping(address => mapping(uint => uint8)) itemSlot;\n        \n        // item address => item id => equip items requires transfer\n        mapping(address => mapping(uint => bool)) requiresTransfer;\n\n        // List of all the existent hashes\n        EnumerableSet.Bytes32Set baseItemsHashes;\n        // arcadian id => base items hash\n        mapping(uint => bytes32) arcadianToBaseItemHash;\n\n        // account => slotId => number of coupons to modify the base traits\n        mapping(address => mapping(uint => uint)) baseModifierCoupon;\n\n        // List of all the base slots ids\n        uint8[] baseSlotsIds;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage istore)\n    {\n        bytes32 position = INVENTORY_STORAGE_POSITION;\n        assembly {\n            istore.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/mintPass/IERC721A.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity ^0.8.19;\n\ninterface IERC721A {\n    struct TokenOwnership {\n        address addr;\n        uint64 startTimestamp;\n        bool burned;\n        uint24 extraData;\n    }\n\n    struct MintStageInfo {\n        uint80 price;\n        uint32 walletLimit;\n        bytes32 merkleRoot;\n        uint24 maxStageSupply;\n        uint64 startTimeUnixSeconds;\n        uint64 endTimeUnixSeconds;\n    }\n\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event ConsecutiveTransfer(uint256 fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event PermanentBaseURI(string baseURI);\n    event SetActiveStage(uint256 activeStage);\n    event SetBaseURI(string baseURI);\n    event SetCosigner(address cosigner);\n    event SetCrossmintAddress(address crossmintAddress);\n    event SetGlobalWalletLimit(uint256 globalWalletLimit);\n    event SetMaxMintableSupply(uint256 maxMintableSupply);\n    event SetMintable(bool mintable);\n    event SetTimestampExpirySeconds(uint64 expiry);\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event UpdateStage(\n        uint256 stage,\n        uint80 price,\n        uint32 walletLimit,\n        bytes32 merkleRoot,\n        uint24 maxStageSupply,\n        uint64 startTimeUnixSeconds,\n        uint64 endTimeUnixSeconds\n    );\n    event Withdraw(uint256 value);\n\n    function approve(address to, uint256 tokenId) external payable;\n    function assertValidCosign(address minter, uint32 qty, uint64 timestamp, bytes calldata signature) external view;\n    function balanceOf(address owner) external view returns (uint256);\n    function crossmint(uint32 qty, address to, bytes32[] calldata proof, uint64 timestamp, bytes calldata signature) external payable;\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\n    function explicitOwnershipsOf(uint256[] calldata tokenIds) external view returns (TokenOwnership[] memory);\n    function getActiveStageFromTimestamp(uint64 timestamp) external view returns (uint256);\n    function getApproved(uint256 tokenId) external view returns (address);\n    function getCosignDigest(address minter, uint32 qty, uint64 timestamp) external view returns (bytes32);\n    function getCosignNonce(address minter) external view returns (uint256);\n    function getCosigner() external view returns (address);\n    function getCrossmintAddress() external view returns (address);\n    function getGlobalWalletLimit() external view returns (uint256);\n    function getMaxMintableSupply() external view returns (uint256);\n    function getMintable() external view returns (bool);\n    function getNumberStages() external view returns (uint256);\n    function getStageInfo(uint256 index)\n        external\n        view\n        returns (\n            MintStageInfo memory,\n            uint32,\n            uint256\n        );\n    function getTimestampExpirySeconds() external view returns (uint64);\n    function getTokenURISuffix() external view returns (string memory);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n    function mint(address minter, uint32 qty, uint64 timestamp) external payable;\n    function name() external view returns (string memory);\n    function owner() external view returns (address);\n    function ownerMint(uint32 qty, address to) external;\n        function ownerOf(uint256 tokenId) external view returns (address);\n    function permanentBaseURI() external view returns (string memory);\n    function safeTransferFrom(address from, address to, uint256 tokenId) external payable;\n    function setApprovalForAll(address operator, bool approved) external;\n    function setActiveStage(uint256 stage) external;\n    function setBaseURI(string calldata baseURI) external;\n    function setCosigner(address cosigner) external;\n    function setCrossmintAddress(address crossmintAddress) external;\n    function setGlobalWalletLimit(uint256 globalWalletLimit) external;\n    function setMaxMintableSupply(uint256 maxMintableSupply) external;\n    function setMintable(bool mintable) external;\n    function setTimestampExpirySeconds(uint64 expiry) external;\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    function symbol() external view returns (string memory);\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\n    function tokensOfOwnerIn(address owner, uint256 indexStart, uint256 indexStop) external view returns (uint256[] memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n    function totalSupply() external view returns (uint256);\n    function transferFrom(address from, address to, uint256 tokenId) external payable;\n    function updateStage(\n        uint256 stage,\n        uint80 price,\n        uint32 walletLimit,\n        bytes32 merkleRoot,\n        uint24 maxStageSupply,\n        uint64 startTimeUnixSeconds,\n        uint64 endTimeUnixSeconds\n    ) external;\n    function withdraw(uint256 value) external;\n}\n"
    },
    "contracts/arcadiaDiamonds/mintPass/MintPassInternal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { MintPassStorage } from \"./MintPassStorage.sol\";\nimport { IERC721A } from \"./IERC721A.sol\";\n\ncontract MintPassInternal {\n\n    error MintPass_ClaimInactive();\n\n    event MintPassConsumed(address indexed account, uint tokenId);\n\n    function _totalClaimedMintPass() internal view returns (uint) {\n        return MintPassStorage.layout().totalClaimed;\n    }\n\n    function _claimedMintPass(address account) internal view returns (uint) {\n        return MintPassStorage.layout().claimedAmount[account];\n    }\n\n    function _elegibleMintPass(address account) internal view returns (uint elegibleAmount) {\n        MintPassStorage.Layout storage mintPassSL = MintPassStorage.layout();\n\n        IERC721A passContract = IERC721A(mintPassSL.passContractAddress);\n\n        uint[] memory tokensOfOwner = passContract.tokensOfOwner(account);\n        for (uint i = 0; i < tokensOfOwner.length; i++) {\n            if (!mintPassSL.isTokenClaimed[tokensOfOwner[i]]) {\n                elegibleAmount++;\n            }\n        }\n    }\n\n    function _consumeMintPass(address account) internal returns (bool consumed) {\n        MintPassStorage.Layout storage mintPassSL = MintPassStorage.layout();\n\n        IERC721A passContract = IERC721A(mintPassSL.passContractAddress);\n\n        if (!MintPassStorage.layout().claimActive)\n            revert MintPass_ClaimInactive();\n\n        uint[] memory tokensOfOwner = passContract.tokensOfOwner(account);\n\n        for (uint i = 0; i < tokensOfOwner.length; i++) {\n            uint tokenId = tokensOfOwner[i];\n            if (!mintPassSL.isTokenClaimed[tokenId]) {\n                mintPassSL.claimedAmount[account]++;\n                mintPassSL.totalClaimed++;\n                mintPassSL.isTokenClaimed[tokenId] = true;\n                consumed = true;\n\n                emit MintPassConsumed(account, 1);\n                break;\n            }\n        }\n    }\n\n    function _isMintPassClaimActive() view internal returns (bool) {\n        return MintPassStorage.layout().claimActive;\n    }\n\n    function _setClaimActiveMintPass(bool active) internal {\n        MintPassStorage.layout().claimActive = active;\n    }\n\n    function _setMintPassContractAddress(address passContractAddress) internal {\n        MintPassStorage.layout().passContractAddress = passContractAddress;\n    }\n\n    function _mintPassContractAddress() internal view returns (address) {\n        return MintPassStorage.layout().passContractAddress;\n    }\n\n    function _isTokenClaimed(uint tokenId) internal view returns (bool) {\n        return MintPassStorage.layout().isTokenClaimed[tokenId];\n    }\n}"
    },
    "contracts/arcadiaDiamonds/mintPass/MintPassStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nlibrary MintPassStorage {\n\n    bytes32 constant MINT_PASS_STORAGE_POSITION =\n        keccak256(\"mintPass.storage.position\");\n    \n    struct Layout {\n        mapping(uint => bool) isTokenClaimed;\n        mapping(address => uint) claimedAmount;\n        uint totalClaimed;\n        uint maxSupply;\n        bool claimActive;\n        address passContractAddress;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = MINT_PASS_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/roles/RolesInternal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { AccessControlInternal } from \"@solidstate/contracts/access/access_control/AccessControlInternal.sol\";\nimport { AccessControlStorage } from \"@solidstate/contracts/access/access_control/AccessControlStorage.sol\";\nimport { RolesStorage } from './RolesStorage.sol';\n\ncontract RolesInternal is AccessControlInternal {\n\n    error Roles_MissingAdminRole();\n    error Roles_MissingManagerRole();\n    error Roles_MissingAutomationRole();\n\n    modifier onlyDefaultAdmin() {\n        if (!_hasRole(_defaultAdminRole(), msg.sender))\n            revert Roles_MissingAdminRole();\n        _;\n    }\n\n    modifier onlyManager() {\n        if (!_hasRole(_managerRole(), msg.sender))\n            revert Roles_MissingManagerRole();\n        _;\n    }\n\n    modifier onlyAutomation() {\n        if (!_hasRole(_managerRole(), msg.sender) && !_hasRole(_automationRole(), msg.sender))\n            revert Roles_MissingAutomationRole();\n        _;\n    }\n\n    function _defaultAdminRole() internal pure returns (bytes32) {\n        return AccessControlStorage.DEFAULT_ADMIN_ROLE;\n    }\n\n    function _managerRole() internal view returns (bytes32) {\n        return RolesStorage.layout().managerRole;\n    }\n\n    function _automationRole() internal view returns (bytes32) {\n        return RolesStorage.layout().automationRole;\n    }\n\n    function _initRoles() internal {\n        RolesStorage.Layout storage rolesSL = RolesStorage.layout();\n        rolesSL.managerRole = keccak256(\"manager.role\");\n        rolesSL.automationRole = keccak256(\"automation.role\");\n\n        _grantRole(_defaultAdminRole(), msg.sender);\n        _grantRole(_managerRole(), msg.sender);\n    }\n}"
    },
    "contracts/arcadiaDiamonds/roles/RolesStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nlibrary RolesStorage {\n\n    bytes32 constant ROLES_STORAGE_POSITION =\n        keccak256(\"roles.storage.position\");\n\n    struct Layout {\n        bytes32 managerRole;\n        bytes32 automationRole;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = ROLES_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/whitelist/WhitelistInternal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nimport { WhitelistStorage } from \"./WhitelistStorage.sol\";\nimport { RolesInternal } from \"./../roles/RolesInternal.sol\";\ncontract WhitelistInternal is RolesInternal {\n\n    error Whitelist_ExceedsElegibleAmount();\n    error Whitelist_InputDataMismatch();\n    error Whitelist_ClaimStateAlreadyUpdated();\n    error Whitelist_ClaimInactive();\n\n    event WhitelistBalanceChanged(address indexed account, WhitelistStorage.PoolId poolId, uint totalElegibleAmount, uint totalClaimedAmount);\n\n    function _totalClaimedWhitelist(WhitelistStorage.PoolId poolId) internal view returns (uint) {\n        return WhitelistStorage.layout().pools[poolId].totalClaimed;\n    }\n\n    function _totalElegibleWhitelist(WhitelistStorage.PoolId poolId) internal view returns (uint) {\n        return WhitelistStorage.layout().pools[poolId].totalElegible;\n    }\n\n    function _claimedWhitelist(WhitelistStorage.PoolId poolId, address account) internal view returns (uint) {\n        return WhitelistStorage.layout().pools[poolId].claimed[account];\n    }\n\n    function _elegibleWhitelist(WhitelistStorage.PoolId poolId, address account) internal view returns (uint) {\n        return WhitelistStorage.layout().pools[poolId].elegible[account];\n    }\n\n    function _consumeWhitelist(WhitelistStorage.PoolId poolId, address account, uint amount) internal {\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        WhitelistStorage.Pool storage pool = whitelistSL.pools[poolId];\n\n        if (!pool.claimActive)\n            revert Whitelist_ClaimInactive();\n\n        if (pool.elegible[account] < amount) \n            revert Whitelist_ExceedsElegibleAmount();\n\n        pool.elegible[account] -= amount;\n        pool.claimed[account] += amount;\n        pool.totalClaimed += amount;\n        pool.totalElegible -= amount;\n\n        emit WhitelistBalanceChanged(account, poolId, pool.elegible[account], pool.claimed[account]);\n    }\n\n    function _increaseWhitelistElegible(WhitelistStorage.PoolId poolId, address account, uint amount) internal {\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        WhitelistStorage.Pool storage pool = whitelistSL.pools[poolId];\n        pool.elegible[account] += amount;\n        pool.totalElegible += amount;\n        \n        emit WhitelistBalanceChanged(account, poolId, pool.elegible[account], pool.claimed[account]);\n    }\n\n    function _increaseWhitelistElegibleBatch(WhitelistStorage.PoolId poolId, address[] calldata accounts, uint[] calldata amounts) internal {\n        if (accounts.length != amounts.length) revert Whitelist_InputDataMismatch();\n\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        WhitelistStorage.Pool storage pool = whitelistSL.pools[poolId];\n\n        for (uint i = 0; i < accounts.length; i++) {\n            pool.elegible[accounts[i]] += amounts[i];\n            pool.totalElegible += amounts[i];\n            emit WhitelistBalanceChanged(accounts[i], poolId, pool.elegible[accounts[i]], pool.claimed[accounts[i]]);\n        }\n    }\n\n    function _setWhitelistElegible(WhitelistStorage.PoolId poolId, address account, uint amount) internal {\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        WhitelistStorage.Pool storage pool = whitelistSL.pools[poolId];\n\n        pool.totalElegible += amount - pool.elegible[account];\n        pool.elegible[account] += amount;\n        emit WhitelistBalanceChanged(account, poolId, pool.elegible[account], pool.claimed[account]);\n    }\n\n    function _setWhitelistElegibleBatch(WhitelistStorage.PoolId poolId, address[] calldata accounts, uint[] calldata amounts) internal {\n        if (accounts.length != amounts.length) revert Whitelist_InputDataMismatch();\n\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        WhitelistStorage.Pool storage pool = whitelistSL.pools[poolId];\n\n        for (uint i = 0; i < accounts.length; i++) {\n            pool.totalElegible += amounts[i] - pool.elegible[accounts[i]];\n            pool.elegible[accounts[i]] = amounts[i];\n            emit WhitelistBalanceChanged(accounts[i], poolId, pool.elegible[accounts[i]], pool.claimed[accounts[i]]);\n        }\n    }\n\n    function _isWhitelistClaimActive(WhitelistStorage.PoolId poolId) view internal returns (bool) {\n        return WhitelistStorage.layout().pools[poolId].claimActive;\n    }\n\n    function _setWhitelistClaimActive(WhitelistStorage.PoolId poolId, bool active) internal {\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        WhitelistStorage.Pool storage pool = whitelistSL.pools[poolId];\n        \n        pool.claimActive = active;\n    }\n}"
    },
    "contracts/arcadiaDiamonds/whitelist/WhitelistStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0\npragma solidity 0.8.19;\n\nlibrary WhitelistStorage {\n\n    bytes32 constant WHITELIST_STORAGE_POSITION =\n        keccak256(\"whitelist.storage.position\");\n\n    enum PoolId { Guaranteed, Restricted }\n    \n    struct Pool {\n        mapping(address => uint) claimed;\n        mapping(address => uint) elegible;\n        uint totalClaimed;\n        uint totalElegible;\n        bool claimActive;\n    }\n\n    struct Layout {\n        // pool id => tokens pool\n        mapping(PoolId => Pool) pools;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = WHITELIST_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 250
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}