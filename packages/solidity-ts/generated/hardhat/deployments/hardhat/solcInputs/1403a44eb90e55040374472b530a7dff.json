{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { UintUtils } from '../../utils/UintUtils.sol';\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\nimport { AccessControlStorage } from './AccessControlStorage.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControlInternal is IAccessControlInternal {\n    using AddressUtils for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using UintUtils for uint256;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function _hasRole(\n        bytes32 role,\n        address account\n    ) internal view virtual returns (bool) {\n        return\n            AccessControlStorage.layout().roles[role].members.contains(account);\n    }\n\n    /**\n     * @notice revert if sender does not have given role\n     * @param role role to query\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, msg.sender);\n    }\n\n    /**\n     * @notice revert if given account does not have given role\n     * @param role role to query\n     * @param account to query\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!_hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        'AccessControl: account ',\n                        account.toString(),\n                        ' is missing role ',\n                        uint256(role).toHexString(32)\n                    )\n                )\n            );\n        }\n    }\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function _getRoleAdmin(\n        bytes32 role\n    ) internal view virtual returns (bytes32) {\n        return AccessControlStorage.layout().roles[role].adminRole;\n    }\n\n    /**\n     * @notice set role as admin role\n     * @param role role to set\n     * @param adminRole admin role to set\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = _getRoleAdmin(role);\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.remove(account);\n        emit RoleRevoked(role, account, msg.sender);\n    }\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function _renounceRole(bytes32 role) internal virtual {\n        _revokeRole(role, msg.sender);\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\n\nlibrary AccessControlStorage {\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) roles;\n    }\n\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.AccessControl');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial AccessControl interface needed by internal functions\n */\ninterface IAccessControlInternal {\n    event RoleAdminChanged(\n        bytes32 indexed role,\n        bytes32 indexed previousAdminRole,\n        bytes32 indexed newAdminRole\n    );\n\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n}\n"
    },
    "@solidstate/contracts/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Merkle tree verification utility\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary MerkleProof {\n    /**\n     * @notice verify whether given leaf is contained within Merkle tree defined by given root\n     * @param proof proof that Merkle tree contains given leaf\n     * @param root Merkle tree root\n     * @param leaf element whose presence in Merkle tree to prove\n     * @return whether leaf is proven to be contained within Merkle tree defined by root\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        unchecked {\n            bytes32 computedHash = leaf;\n\n            for (uint256 i = 0; i < proof.length; i++) {\n                bytes32 proofElement = proof[i];\n\n                if (computedHash <= proofElement) {\n                    computedHash = keccak256(\n                        abi.encodePacked(computedHash, proofElement)\n                    );\n                } else {\n                    computedHash = keccak256(\n                        abi.encodePacked(proofElement, computedHash)\n                    );\n                }\n            }\n\n            return computedHash == root;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/data/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Map implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableMap {\n    error EnumerableMap__IndexOutOfBounds();\n    error EnumerableMap__NonExistentKey();\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        MapEntry[] _entries;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct AddressToAddressMap {\n        Map _inner;\n    }\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    function at(\n        AddressToAddressMap storage map,\n        uint256 index\n    ) internal view returns (address, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n\n        return (\n            address(uint160(uint256(key))),\n            address(uint160(uint256(value)))\n        );\n    }\n\n    function at(\n        UintToAddressMap storage map,\n        uint256 index\n    ) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    function contains(\n        AddressToAddressMap storage map,\n        address key\n    ) internal view returns (bool) {\n        return _contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    function contains(\n        UintToAddressMap storage map,\n        uint256 key\n    ) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    function length(\n        AddressToAddressMap storage map\n    ) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    function length(\n        UintToAddressMap storage map\n    ) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    function get(\n        AddressToAddressMap storage map,\n        address key\n    ) internal view returns (address) {\n        return\n            address(\n                uint160(\n                    uint256(_get(map._inner, bytes32(uint256(uint160(key)))))\n                )\n            );\n    }\n\n    function get(\n        UintToAddressMap storage map,\n        uint256 key\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    function set(\n        AddressToAddressMap storage map,\n        address key,\n        address value\n    ) internal returns (bool) {\n        return\n            _set(\n                map._inner,\n                bytes32(uint256(uint160(key))),\n                bytes32(uint256(uint160(value)))\n            );\n    }\n\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        AddressToAddressMap storage map,\n        address key\n    ) internal returns (bool) {\n        return _remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    function remove(\n        UintToAddressMap storage map,\n        uint256 key\n    ) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    function toArray(\n        AddressToAddressMap storage map\n    )\n        internal\n        view\n        returns (address[] memory keysOut, address[] memory valuesOut)\n    {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new address[](len);\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._key))\n                );\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function toArray(\n        UintToAddressMap storage map\n    )\n        internal\n        view\n        returns (uint256[] memory keysOut, address[] memory valuesOut)\n    {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new uint256[](len);\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = uint256(map._inner._entries[i]._key);\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function keys(\n        AddressToAddressMap storage map\n    ) internal view returns (address[] memory keysOut) {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._key))\n                );\n            }\n        }\n    }\n\n    function keys(\n        UintToAddressMap storage map\n    ) internal view returns (uint256[] memory keysOut) {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new uint256[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = uint256(map._inner._entries[i]._key);\n            }\n        }\n    }\n\n    function values(\n        AddressToAddressMap storage map\n    ) internal view returns (address[] memory valuesOut) {\n        uint256 len = map._inner._entries.length;\n\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function values(\n        UintToAddressMap storage map\n    ) internal view returns (address[] memory valuesOut) {\n        uint256 len = map._inner._entries.length;\n\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function _at(\n        Map storage map,\n        uint256 index\n    ) private view returns (bytes32, bytes32) {\n        if (index >= map._entries.length)\n            revert EnumerableMap__IndexOutOfBounds();\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    function _contains(\n        Map storage map,\n        bytes32 key\n    ) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) revert EnumerableMap__NonExistentKey();\n        unchecked {\n            return map._entries[keyIndex - 1]._value;\n        }\n    }\n\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) {\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            unchecked {\n                map._entries[keyIndex - 1]._value = value;\n            }\n            return false;\n        }\n    }\n\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) {\n            unchecked {\n                MapEntry storage last = map._entries[map._entries.length - 1];\n\n                // move last entry to now-vacant index\n                map._entries[keyIndex - 1] = last;\n                map._indexes[last._key] = keyIndex;\n            }\n\n            // clear last index\n            map._entries.pop();\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/data/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    error EnumerableSet__IndexOutOfBounds();\n\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(\n        Bytes32Set storage set,\n        uint256 index\n    ) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    function at(\n        AddressSet storage set,\n        uint256 index\n    ) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(\n        UintSet storage set,\n        uint256 index\n    ) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    function contains(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function contains(\n        AddressSet storage set,\n        address value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function indexOf(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, value);\n    }\n\n    function indexOf(\n        AddressSet storage set,\n        address value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function indexOf(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(value));\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function add(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function remove(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        UintSet storage set,\n        uint256 value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function toArray(\n        Bytes32Set storage set\n    ) internal view returns (bytes32[] memory) {\n        return set._inner._values;\n    }\n\n    function toArray(\n        AddressSet storage set\n    ) internal view returns (address[] memory) {\n        bytes32[] storage values = set._inner._values;\n        address[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function toArray(\n        UintSet storage set\n    ) internal view returns (uint256[] memory) {\n        bytes32[] storage values = set._inner._values;\n        uint256[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function _at(\n        Set storage set,\n        uint256 index\n    ) private view returns (bytes32) {\n        if (index >= set._values.length)\n            revert EnumerableSet__IndexOutOfBounds();\n        return set._values[index];\n    }\n\n    function _contains(\n        Set storage set,\n        bytes32 value\n    ) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _indexOf(\n        Set storage set,\n        bytes32 value\n    ) private view returns (uint256) {\n        unchecked {\n            return set._indexes[value] - 1;\n        }\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            status = true;\n        }\n    }\n\n    function _remove(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            unchecked {\n                bytes32 last = set._values[set._values.length - 1];\n\n                // move last value to now-vacant index\n\n                set._values[valueIndex - 1] = last;\n                set._indexes[last] = valueIndex;\n            }\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            status = true;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\nimport { IERC1155Internal } from './IERC1155Internal.sol';\n\n/**\n * @title ERC1155 interface\n * @dev see https://github.com/ethereum/EIPs/issues/1155\n */\ninterface IERC1155 is IERC1155Internal, IERC165 {\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external view returns (uint256);\n\n    /**\n     * @notice query the balances of given tokens held by given addresses\n     * @param accounts addresss to query\n     * @param ids tokens to query\n     * @return token balances\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool);\n\n    /**\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\n     * @param operator address whose approval status to update\n     * @param status whether operator should be considered approved\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to transfer\n     * @param data data payload\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC1155 interface needed by internal functions\n */\ninterface IERC1155Internal {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\n\n/**\n * @title ERC1155 transfer receiver interface\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @notice validate receipt of ERC1155 transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param id token ID received\n     * @param value quantity of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @notice validate receipt of ERC1155 batch transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param ids token IDs received\n     * @param values quantities of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 is IERC165Internal {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n */\ninterface IERC165Internal {\n\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\nimport { IERC721Internal } from './IERC721Internal.sol';\n\n/**\n * @title ERC721 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721 is IERC721Internal, IERC165 {\n    /**\n     * @notice query the balance of given address\n     * @return balance quantity of tokens held\n     */\n    function balanceOf(address account) external view returns (uint256 balance);\n\n    /**\n     * @notice query the owner of given token\n     * @param tokenId token to query\n     * @return owner token owner\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, without checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice grant approval to given account to spend token\n     * @param operator address to be approved\n     * @param tokenId token to approve\n     */\n    function approve(address operator, uint256 tokenId) external payable;\n\n    /**\n     * @notice get approval status for given token\n     * @param tokenId token to query\n     * @return operator address approved to spend token\n     */\n    function getApproved(\n        uint256 tokenId\n    ) external view returns (address operator);\n\n    /**\n     * @notice grant approval to or revoke approval from given account to spend all tokens held by sender\n     * @param operator address to be approved\n     * @param status approval status\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return status whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool status);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC721 interface needed by internal functions\n */\ninterface IERC721Internal {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed operator,\n        uint256 indexed tokenId\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\nimport { IERC165Base } from './IERC165Base.sol';\nimport { ERC165BaseInternal } from './ERC165BaseInternal.sol';\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165Base is IERC165Base, ERC165BaseInternal {\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n        return _supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165BaseInternal is IERC165BaseInternal {\n    /**\n     * @notice indicates whether an interface is already supported based on the interfaceId\n     * @param interfaceId id of interface to check\n     * @return bool indicating whether interface is supported\n     */\n    function _supportsInterface(\n        bytes4 interfaceId\n    ) internal view returns (bool) {\n        return ERC165BaseStorage.layout().supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @notice sets status of interface support\n     * @param interfaceId id of interface to set status for\n     * @param status boolean indicating whether interface will be set as supported\n     */\n    function _setSupportsInterface(bytes4 interfaceId, bool status) internal {\n        if (interfaceId == 0xffffffff) revert ERC165Base__InvalidInterfaceId();\n        ERC165BaseStorage.layout().supportedInterfaces[interfaceId] = status;\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC165BaseStorage {\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC165Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/IERC165Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\n\ninterface IERC165Base is IERC165, IERC165BaseInternal {}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/IERC165BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165Internal } from '../../../interfaces/IERC165Internal.sol';\n\ninterface IERC165BaseInternal is IERC165Internal {\n    error ERC165Base__InvalidInterfaceId();\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155Receiver } from '../../../interfaces/IERC1155Receiver.sol';\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { IERC1155BaseInternal } from './IERC1155BaseInternal.sol';\nimport { ERC1155BaseStorage } from './ERC1155BaseStorage.sol';\n\n/**\n * @title Base ERC1155 internal functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155BaseInternal is IERC1155BaseInternal {\n    using AddressUtils for address;\n\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function _balanceOf(\n        address account,\n        uint256 id\n    ) internal view virtual returns (uint256) {\n        if (account == address(0))\n            revert ERC1155Base__BalanceQueryZeroAddress();\n        return ERC1155BaseStorage.layout().balances[id][account];\n    }\n\n    /**\n     * @notice mint given quantity of tokens for given address\n     * @dev ERC1155Receiver implementation is not checked\n     * @param account beneficiary of minting\n     * @param id token ID\n     * @param amount quantity of tokens to mint\n     * @param data data payload\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__MintToZeroAddress();\n\n        _beforeTokenTransfer(\n            msg.sender,\n            address(0),\n            account,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        ERC1155BaseStorage.layout().balances[id][account] += amount;\n\n        emit TransferSingle(msg.sender, address(0), account, id, amount);\n    }\n\n    /**\n     * @notice mint given quantity of tokens for given address\n     * @param account beneficiary of minting\n     * @param id token ID\n     * @param amount quantity of tokens to mint\n     * @param data data payload\n     */\n    function _safeMint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _mint(account, id, amount, data);\n\n        _doSafeTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            account,\n            id,\n            amount,\n            data\n        );\n    }\n\n    /**\n     * @notice mint batch of tokens for given address\n     * @dev ERC1155Receiver implementation is not checked\n     * @param account beneficiary of minting\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to mint\n     * @param data data payload\n     */\n    function _mintBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__MintToZeroAddress();\n        if (ids.length != amounts.length)\n            revert ERC1155Base__ArrayLengthMismatch();\n\n        _beforeTokenTransfer(\n            msg.sender,\n            address(0),\n            account,\n            ids,\n            amounts,\n            data\n        );\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        for (uint256 i; i < ids.length; ) {\n            balances[ids[i]][account] += amounts[i];\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), account, ids, amounts);\n    }\n\n    /**\n     * @notice mint batch of tokens for given address\n     * @param account beneficiary of minting\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to mint\n     * @param data data payload\n     */\n    function _safeMintBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _mintBatch(account, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            account,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @notice burn given quantity of tokens held by given address\n     * @param account holder of tokens to burn\n     * @param id token ID\n     * @param amount quantity of tokens to burn\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__BurnFromZeroAddress();\n\n        _beforeTokenTransfer(\n            msg.sender,\n            account,\n            address(0),\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            ''\n        );\n\n        mapping(address => uint256) storage balances = ERC1155BaseStorage\n            .layout()\n            .balances[id];\n\n        unchecked {\n            if (amount > balances[account])\n                revert ERC1155Base__BurnExceedsBalance();\n            balances[account] -= amount;\n        }\n\n        emit TransferSingle(msg.sender, account, address(0), id, amount);\n    }\n\n    /**\n     * @notice burn given batch of tokens held by given address\n     * @param account holder of tokens to burn\n     * @param ids token IDs\n     * @param amounts quantities of tokens to burn\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__BurnFromZeroAddress();\n        if (ids.length != amounts.length)\n            revert ERC1155Base__ArrayLengthMismatch();\n\n        _beforeTokenTransfer(msg.sender, account, address(0), ids, amounts, '');\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        unchecked {\n            for (uint256 i; i < ids.length; i++) {\n                uint256 id = ids[i];\n                if (amounts[i] > balances[id][account])\n                    revert ERC1155Base__BurnExceedsBalance();\n                balances[id][account] -= amounts[i];\n            }\n        }\n\n        emit TransferBatch(msg.sender, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @notice transfer tokens between given addresses\n     * @dev ERC1155Receiver implementation is not checked\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _transfer(\n        address operator,\n        address sender,\n        address recipient,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        if (recipient == address(0))\n            revert ERC1155Base__TransferToZeroAddress();\n\n        _beforeTokenTransfer(\n            operator,\n            sender,\n            recipient,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        unchecked {\n            uint256 senderBalance = balances[id][sender];\n            if (amount > senderBalance)\n                revert ERC1155Base__TransferExceedsBalance();\n            balances[id][sender] = senderBalance - amount;\n        }\n\n        balances[id][recipient] += amount;\n\n        emit TransferSingle(operator, sender, recipient, id, amount);\n    }\n\n    /**\n     * @notice transfer tokens between given addresses\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _safeTransfer(\n        address operator,\n        address sender,\n        address recipient,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _transfer(operator, sender, recipient, id, amount, data);\n\n        _doSafeTransferAcceptanceCheck(\n            operator,\n            sender,\n            recipient,\n            id,\n            amount,\n            data\n        );\n    }\n\n    /**\n     * @notice transfer batch of tokens between given addresses\n     * @dev ERC1155Receiver implementation is not checked\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _transferBatch(\n        address operator,\n        address sender,\n        address recipient,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (recipient == address(0))\n            revert ERC1155Base__TransferToZeroAddress();\n        if (ids.length != amounts.length)\n            revert ERC1155Base__ArrayLengthMismatch();\n\n        _beforeTokenTransfer(operator, sender, recipient, ids, amounts, data);\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        for (uint256 i; i < ids.length; ) {\n            uint256 token = ids[i];\n            uint256 amount = amounts[i];\n\n            unchecked {\n                uint256 senderBalance = balances[token][sender];\n\n                if (amount > senderBalance)\n                    revert ERC1155Base__TransferExceedsBalance();\n\n                balances[token][sender] = senderBalance - amount;\n\n                i++;\n            }\n\n            // balance increase cannot be unchecked because ERC1155Base neither tracks nor validates a totalSupply\n            balances[token][recipient] += amount;\n        }\n\n        emit TransferBatch(operator, sender, recipient, ids, amounts);\n    }\n\n    /**\n     * @notice transfer batch of tokens between given addresses\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _safeTransferBatch(\n        address operator,\n        address sender,\n        address recipient,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _transferBatch(operator, sender, recipient, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            operator,\n            sender,\n            recipient,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @notice wrap given element in array of length 1\n     * @param element element to wrap\n     * @return singleton array\n     */\n    function _asSingletonArray(\n        uint256 element\n    ) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n        return array;\n    }\n\n    /**\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155Received(\n                    operator,\n                    from,\n                    id,\n                    amount,\n                    data\n                )\n            returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector)\n                    revert ERC1155Base__ERC1155ReceiverRejected();\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert ERC1155Base__ERC1155ReceiverNotImplemented();\n            }\n        }\n    }\n\n    /**\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155BatchReceived(\n                    operator,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                )\n            returns (bytes4 response) {\n                if (\n                    response != IERC1155Receiver.onERC1155BatchReceived.selector\n                ) revert ERC1155Base__ERC1155ReceiverRejected();\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert ERC1155Base__ERC1155ReceiverNotImplemented();\n            }\n        }\n    }\n\n    /**\n     * @notice ERC1155 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @dev called for both single and batch transfers\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC1155BaseStorage {\n    struct Layout {\n        mapping(uint256 => mapping(address => uint256)) balances;\n        mapping(address => mapping(address => bool)) operatorApprovals;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/IERC1155BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155Internal } from '../../../interfaces/IERC1155Internal.sol';\n\n/**\n * @title ERC1155 base interface\n */\ninterface IERC1155BaseInternal is IERC1155Internal {\n    error ERC1155Base__ArrayLengthMismatch();\n    error ERC1155Base__BalanceQueryZeroAddress();\n    error ERC1155Base__NotOwnerOrApproved();\n    error ERC1155Base__SelfApproval();\n    error ERC1155Base__BurnExceedsBalance();\n    error ERC1155Base__BurnFromZeroAddress();\n    error ERC1155Base__ERC1155ReceiverRejected();\n    error ERC1155Base__ERC1155ReceiverNotImplemented();\n    error ERC1155Base__MintToZeroAddress();\n    error ERC1155Base__TransferExceedsBalance();\n    error ERC1155Base__TransferToZeroAddress();\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC1155BaseInternal, ERC1155BaseStorage } from '../base/ERC1155BaseInternal.sol';\nimport { ERC1155EnumerableStorage } from './ERC1155EnumerableStorage.sol';\n\n/**\n * @title ERC1155Enumerable internal functions\n */\nabstract contract ERC1155EnumerableInternal is ERC1155BaseInternal {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @notice query total minted supply of given token\n     * @param id token id to query\n     * @return token supply\n     */\n    function _totalSupply(uint256 id) internal view virtual returns (uint256) {\n        return ERC1155EnumerableStorage.layout().totalSupply[id];\n    }\n\n    /**\n     * @notice query total number of holders for given token\n     * @param id token id to query\n     * @return quantity of holders\n     */\n    function _totalHolders(uint256 id) internal view virtual returns (uint256) {\n        return ERC1155EnumerableStorage.layout().accountsByToken[id].length();\n    }\n\n    /**\n     * @notice query holders of given token\n     * @param id token id to query\n     * @return list of holder addresses\n     */\n    function _accountsByToken(\n        uint256 id\n    ) internal view virtual returns (address[] memory) {\n        EnumerableSet.AddressSet storage accounts = ERC1155EnumerableStorage\n            .layout()\n            .accountsByToken[id];\n\n        address[] memory addresses = new address[](accounts.length());\n\n        unchecked {\n            for (uint256 i; i < accounts.length(); i++) {\n                addresses[i] = accounts.at(i);\n            }\n        }\n\n        return addresses;\n    }\n\n    /**\n     * @notice query tokens held by given address\n     * @param account address to query\n     * @return list of token ids\n     */\n    function _tokensByAccount(\n        address account\n    ) internal view virtual returns (uint256[] memory) {\n        EnumerableSet.UintSet storage tokens = ERC1155EnumerableStorage\n            .layout()\n            .tokensByAccount[account];\n\n        uint256[] memory ids = new uint256[](tokens.length());\n\n        unchecked {\n            for (uint256 i; i < tokens.length(); i++) {\n                ids[i] = tokens.at(i);\n            }\n        }\n\n        return ids;\n    }\n\n    /**\n     * @notice ERC1155 hook: update aggregate values\n     * @inheritdoc ERC1155BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from != to) {\n            ERC1155EnumerableStorage.Layout storage l = ERC1155EnumerableStorage\n                .layout();\n            mapping(uint256 => EnumerableSet.AddressSet)\n                storage tokenAccounts = l.accountsByToken;\n            EnumerableSet.UintSet storage fromTokens = l.tokensByAccount[from];\n            EnumerableSet.UintSet storage toTokens = l.tokensByAccount[to];\n\n            for (uint256 i; i < ids.length; ) {\n                uint256 amount = amounts[i];\n\n                if (amount > 0) {\n                    uint256 id = ids[i];\n\n                    if (from == address(0)) {\n                        l.totalSupply[id] += amount;\n                    } else if (_balanceOf(from, id) == amount) {\n                        tokenAccounts[id].remove(from);\n                        fromTokens.remove(id);\n                    }\n\n                    if (to == address(0)) {\n                        l.totalSupply[id] -= amount;\n                    } else if (_balanceOf(to, id) == 0) {\n                        tokenAccounts[id].add(to);\n                        toTokens.add(id);\n                    }\n                }\n\n                unchecked {\n                    i++;\n                }\n            }\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\n\nlibrary ERC1155EnumerableStorage {\n    struct Layout {\n        mapping(uint256 => uint256) totalSupply;\n        mapping(uint256 => EnumerableSet.AddressSet) accountsByToken;\n        mapping(address => EnumerableSet.UintSet) tokensByAccount;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Enumerable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\nimport { ERC1155MetadataStorage } from './ERC1155MetadataStorage.sol';\n\n/**\n * @title ERC1155Metadata internal functions\n */\nabstract contract ERC1155MetadataInternal is IERC1155MetadataInternal {\n    /**\n     * @notice set base metadata URI\n     * @dev base URI is a non-standard feature adapted from the ERC721 specification\n     * @param baseURI base URI\n     */\n    function _setBaseURI(string memory baseURI) internal {\n        ERC1155MetadataStorage.layout().baseURI = baseURI;\n    }\n\n    /**\n     * @notice set per-token metadata URI\n     * @param tokenId token whose metadata URI to set\n     * @param tokenURI per-token URI\n     */\n    function _setTokenURI(uint256 tokenId, string memory tokenURI) internal {\n        ERC1155MetadataStorage.layout().tokenURIs[tokenId] = tokenURI;\n        emit URI(tokenURI, tokenId);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title ERC1155 metadata extensions\n */\nlibrary ERC1155MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Metadata');\n\n    struct Layout {\n        string baseURI;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC1155Metadata interface needed by internal functions\n */\ninterface IERC1155MetadataInternal {\n    event URI(string value, uint256 indexed tokenId);\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/ERC721Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721 } from '../../../interfaces/IERC721.sol';\nimport { IERC721Base } from './IERC721Base.sol';\nimport { ERC721BaseInternal } from './ERC721BaseInternal.sol';\n\n/**\n * @title Base ERC721 implementation, excluding optional extensions\n */\nabstract contract ERC721Base is IERC721Base, ERC721BaseInternal {\n    /**\n     * @inheritdoc IERC721\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balanceOf(account);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function ownerOf(uint256 tokenId) external view returns (address) {\n        return _ownerOf(tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function getApproved(uint256 tokenId) external view returns (address) {\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool) {\n        return _isApprovedForAll(account, operator);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable {\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable {\n        _safeTransferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external payable {\n        _safeTransferFrom(from, to, tokenId, data);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function approve(address operator, uint256 tokenId) external payable {\n        _approve(operator, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function setApprovalForAll(address operator, bool status) external {\n        _setApprovalForAll(operator, status);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/ERC721BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721Receiver } from '../../../interfaces/IERC721Receiver.sol';\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { IERC721BaseInternal } from './IERC721BaseInternal.sol';\nimport { ERC721BaseStorage } from './ERC721BaseStorage.sol';\n\n/**\n * @title Base ERC721 internal functions\n */\nabstract contract ERC721BaseInternal is IERC721BaseInternal {\n    using AddressUtils for address;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    function _balanceOf(\n        address account\n    ) internal view virtual returns (uint256) {\n        if (account == address(0)) revert ERC721Base__BalanceQueryZeroAddress();\n        return ERC721BaseStorage.layout().holderTokens[account].length();\n    }\n\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        address owner = ERC721BaseStorage.layout().tokenOwners.get(tokenId);\n        if (owner == address(0)) revert ERC721Base__InvalidOwner();\n        return owner;\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return ERC721BaseStorage.layout().tokenOwners.contains(tokenId);\n    }\n\n    function _getApproved(\n        uint256 tokenId\n    ) internal view virtual returns (address) {\n        if (!_exists(tokenId)) revert ERC721Base__NonExistentToken();\n\n        return ERC721BaseStorage.layout().tokenApprovals[tokenId];\n    }\n\n    function _isApprovedForAll(\n        address account,\n        address operator\n    ) internal view virtual returns (bool) {\n        return ERC721BaseStorage.layout().operatorApprovals[account][operator];\n    }\n\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view virtual returns (bool) {\n        if (!_exists(tokenId)) revert ERC721Base__NonExistentToken();\n\n        address owner = _ownerOf(tokenId);\n\n        return (spender == owner ||\n            _getApproved(tokenId) == spender ||\n            _isApprovedForAll(owner, spender));\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        if (to == address(0)) revert ERC721Base__MintToZeroAddress();\n        if (_exists(tokenId)) revert ERC721Base__TokenAlreadyMinted();\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\n\n        l.holderTokens[to].add(tokenId);\n        l.tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, '');\n    }\n\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        if (!_checkOnERC721Received(address(0), to, tokenId, data))\n            revert ERC721Base__ERC721ReceiverNotImplemented();\n    }\n\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = _ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\n\n        l.holderTokens[owner].remove(tokenId);\n        l.tokenOwners.remove(tokenId);\n\n        l.tokenApprovals[tokenId] = address(0);\n\n        emit Approval(owner, address(0), tokenId);\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        address owner = _ownerOf(tokenId);\n\n        if (owner != from) revert ERC721Base__NotTokenOwner();\n        if (to == address(0)) revert ERC721Base__TransferToZeroAddress();\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\n\n        l.holderTokens[from].remove(tokenId);\n        l.holderTokens[to].add(tokenId);\n        l.tokenOwners.set(tokenId, to);\n        l.tokenApprovals[tokenId] = address(0);\n\n        emit Approval(owner, address(0), tokenId);\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\n        if (!_isApprovedOrOwner(msg.sender, tokenId))\n            revert ERC721Base__NotOwnerOrApproved();\n        _transfer(from, to, tokenId);\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        if (!_checkOnERC721Received(from, to, tokenId, data))\n            revert ERC721Base__ERC721ReceiverNotImplemented();\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        _safeTransferFrom(from, to, tokenId, '');\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\n        if (!_isApprovedOrOwner(msg.sender, tokenId))\n            revert ERC721Base__NotOwnerOrApproved();\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    function _approve(address operator, uint256 tokenId) internal virtual {\n        _handleApproveMessageValue(operator, tokenId, msg.value);\n\n        address owner = _ownerOf(tokenId);\n\n        if (operator == owner) revert ERC721Base__SelfApproval();\n        if (msg.sender != owner && !_isApprovedForAll(owner, msg.sender))\n            revert ERC721Base__NotOwnerOrApproved();\n\n        ERC721BaseStorage.layout().tokenApprovals[tokenId] = operator;\n        emit Approval(owner, operator, tokenId);\n    }\n\n    function _setApprovalForAll(\n        address operator,\n        bool status\n    ) internal virtual {\n        if (operator == msg.sender) revert ERC721Base__SelfApproval();\n        ERC721BaseStorage.layout().operatorApprovals[msg.sender][\n            operator\n        ] = status;\n        emit ApprovalForAll(msg.sender, operator, status);\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual returns (bool) {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes memory returnData = to.functionCall(\n            abi.encodeWithSelector(\n                IERC721Receiver(to).onERC721Received.selector,\n                msg.sender,\n                from,\n                tokenId,\n                data\n            ),\n            'ERC721: transfer to non ERC721Receiver implementer'\n        );\n\n        bytes4 returnValue = abi.decode(returnData, (bytes4));\n        return returnValue == type(IERC721Receiver).interfaceId;\n    }\n\n    /**\n     * @notice ERC721 hook, called before externally called approvals for processing of included message value\n     * @param operator beneficiary of approval\n     * @param tokenId id of transferred token\n     * @param value message value\n     */\n    function _handleApproveMessageValue(\n        address operator,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual {}\n\n    /**\n     * @notice ERC721 hook, called before externally called transfers for processing of included message value\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId id of transferred token\n     * @param value message value\n     */\n    function _handleTransferMessageValue(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual {}\n\n    /**\n     * @notice ERC721 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId id of transferred token\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/ERC721BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\n\nlibrary ERC721BaseStorage {\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC721Base');\n\n    struct Layout {\n        EnumerableMap.UintToAddressMap tokenOwners;\n        mapping(address => EnumerableSet.UintSet) holderTokens;\n        mapping(uint256 => address) tokenApprovals;\n        mapping(address => mapping(address => bool)) operatorApprovals;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/IERC721Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721 } from '../../../interfaces/IERC721.sol';\nimport { IERC721BaseInternal } from './IERC721BaseInternal.sol';\n\n/**\n * @title ERC721 base interface\n */\ninterface IERC721Base is IERC721BaseInternal, IERC721 {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/IERC721BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721Internal } from '../../../interfaces/IERC721Internal.sol';\n\n/**\n * @title ERC721 base interface\n */\ninterface IERC721BaseInternal is IERC721Internal {\n    error ERC721Base__NotOwnerOrApproved();\n    error ERC721Base__SelfApproval();\n    error ERC721Base__BalanceQueryZeroAddress();\n    error ERC721Base__ERC721ReceiverNotImplemented();\n    error ERC721Base__InvalidOwner();\n    error ERC721Base__MintToZeroAddress();\n    error ERC721Base__NonExistentToken();\n    error ERC721Base__NotTokenOwner();\n    error ERC721Base__TokenAlreadyMinted();\n    error ERC721Base__TransferToZeroAddress();\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\nimport { IERC721Enumerable } from './IERC721Enumerable.sol';\nimport { ERC721EnumerableInternal } from './ERC721EnumerableInternal.sol';\n\nabstract contract ERC721Enumerable is\n    IERC721Enumerable,\n    ERC721EnumerableInternal\n{\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply();\n    }\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) public view returns (uint256) {\n        return _tokenOfOwnerByIndex(owner, index);\n    }\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        return _tokenByIndex(index);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/ERC721EnumerableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\n\nabstract contract ERC721EnumerableInternal {\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @notice TODO\n     */\n    function _totalSupply() internal view returns (uint256) {\n        return ERC721BaseStorage.layout().tokenOwners.length();\n    }\n\n    /**\n     * @notice TODO\n     */\n    function _tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) internal view returns (uint256) {\n        return ERC721BaseStorage.layout().holderTokens[owner].at(index);\n    }\n\n    /**\n     * @notice TODO\n     */\n    function _tokenByIndex(\n        uint256 index\n    ) internal view returns (uint256 tokenId) {\n        (tokenId, ) = ERC721BaseStorage.layout().tokenOwners.at(index);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC721Enumerable {\n    /**\n     * @notice get total token supply\n     * @return total supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice get token of given owner at given internal storage index\n     * @param owner token holder to query\n     * @param index position in owner's token list to query\n     * @return tokenId id of retrieved token\n     */\n    function tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) external view returns (uint256 tokenId);\n\n    /**\n     * @notice get token at given internal storage index\n     * @param index position in global token list to query\n     * @return tokenId id of retrieved token\n     */\n    function tokenByIndex(\n        uint256 index\n    ) external view returns (uint256 tokenId);\n}\n"
    },
    "@solidstate/contracts/token/ERC721/ISolidStateERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721Base } from './base/IERC721Base.sol';\nimport { IERC721Enumerable } from './enumerable/IERC721Enumerable.sol';\nimport { IERC721Metadata } from './metadata/IERC721Metadata.sol';\n\ninterface ISolidStateERC721 is IERC721Base, IERC721Enumerable, IERC721Metadata {\n    error SolidStateERC721__PayableApproveNotSupported();\n    error SolidStateERC721__PayableTransferNotSupported();\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ERC721MetadataInternal } from './ERC721MetadataInternal.sol';\nimport { IERC721Metadata } from './IERC721Metadata.sol';\n\n/**\n * @title ERC721 metadata extensions\n */\nabstract contract ERC721Metadata is IERC721Metadata, ERC721MetadataInternal {\n    /**\n     * @notice inheritdoc IERC721Metadata\n     */\n    function name() external view virtual returns (string memory) {\n        return _name();\n    }\n\n    /**\n     * @notice inheritdoc IERC721Metadata\n     */\n    function symbol() external view virtual returns (string memory) {\n        return _symbol();\n    }\n\n    /**\n     * @notice inheritdoc IERC721Metadata\n     */\n    function tokenURI(\n        uint256 tokenId\n    ) external view virtual returns (string memory) {\n        return _tokenURI(tokenId);\n    }\n\n    /**\n     * @inheritdoc ERC721MetadataInternal\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from '../../../utils/UintUtils.sol';\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\nimport { ERC721BaseInternal } from '../base/ERC721Base.sol';\nimport { IERC721MetadataInternal } from './IERC721MetadataInternal.sol';\nimport { ERC721MetadataStorage } from './ERC721MetadataStorage.sol';\nimport { ERC721MetadataInternal } from './ERC721MetadataInternal.sol';\n\n/**\n * @title ERC721Metadata internal functions\n */\nabstract contract ERC721MetadataInternal is\n    IERC721MetadataInternal,\n    ERC721BaseInternal\n{\n    using UintUtils for uint256;\n\n    /**\n     * @notice get token name\n     * @return token name\n     */\n    function _name() internal view virtual returns (string memory) {\n        return ERC721MetadataStorage.layout().name;\n    }\n\n    /**\n     * @notice get token symbol\n     * @return token symbol\n     */\n    function _symbol() internal view virtual returns (string memory) {\n        return ERC721MetadataStorage.layout().symbol;\n    }\n\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function _tokenURI(\n        uint256 tokenId\n    ) internal view virtual returns (string memory) {\n        if (!_exists(tokenId)) revert ERC721Metadata__NonExistentToken();\n\n        ERC721MetadataStorage.Layout storage l = ERC721MetadataStorage.layout();\n\n        string memory tokenIdURI = l.tokenURIs[tokenId];\n        string memory baseURI = l.baseURI;\n\n        if (bytes(baseURI).length == 0) {\n            return tokenIdURI;\n        } else if (bytes(tokenIdURI).length > 0) {\n            return string(abi.encodePacked(baseURI, tokenIdURI));\n        } else {\n            return string(abi.encodePacked(baseURI, tokenId.toString()));\n        }\n    }\n\n    /**\n     * @notice ERC721 hook: clear per-token URI data on burn\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (to == address(0)) {\n            delete ERC721MetadataStorage.layout().tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC721MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC721Metadata');\n\n    struct Layout {\n        string name;\n        string symbol;\n        string baseURI;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721MetadataInternal } from './IERC721MetadataInternal.sol';\n\n/**\n * @title ERC721Metadata interface\n */\ninterface IERC721Metadata is IERC721MetadataInternal {\n    /**\n     * @notice get token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice get token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/IERC721MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721BaseInternal } from '../base/IERC721BaseInternal.sol';\n\n/**\n * @title ERC721Metadata internal interface\n */\ninterface IERC721MetadataInternal is IERC721BaseInternal {\n    error ERC721Metadata__NonExistentToken();\n}\n"
    },
    "@solidstate/contracts/token/ERC721/SolidStateERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ERC165Base } from '../../introspection/ERC165/base/ERC165Base.sol';\nimport { ERC721Base, ERC721BaseInternal } from './base/ERC721Base.sol';\nimport { ERC721Enumerable } from './enumerable/ERC721Enumerable.sol';\nimport { ERC721Metadata } from './metadata/ERC721Metadata.sol';\nimport { ISolidStateERC721 } from './ISolidStateERC721.sol';\n\n/**\n * @title SolidState ERC721 implementation, including recommended extensions\n */\nabstract contract SolidStateERC721 is\n    ISolidStateERC721,\n    ERC721Base,\n    ERC721Enumerable,\n    ERC721Metadata,\n    ERC165Base\n{\n    /**\n     * @notice ERC721 hook: revert if value is included in external approve function call\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _handleApproveMessageValue(\n        address operator,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual override {\n        if (value > 0) revert SolidStateERC721__PayableApproveNotSupported();\n        super._handleApproveMessageValue(operator, tokenId, value);\n    }\n\n    /**\n     * @notice ERC721 hook: revert if value is included in external transfer function call\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _handleTransferMessageValue(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual override {\n        if (value > 0) revert SolidStateERC721__PayableTransferNotSupported();\n        super._handleTransferMessageValue(from, to, tokenId, value);\n    }\n\n    /**\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721BaseInternal, ERC721Metadata) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ReentrancyGuardStorage } from './ReentrancyGuardStorage.sol';\n\n/**\n * @title Utility contract for preventing reentrancy attacks\n */\nabstract contract ReentrancyGuard {\n    error ReentrancyGuard__ReentrantCall();\n\n    modifier nonReentrant() {\n        ReentrancyGuardStorage.Layout storage l = ReentrancyGuardStorage\n            .layout();\n        if (l.status == 2) revert ReentrancyGuard__ReentrantCall();\n        l.status = 2;\n        _;\n        l.status = 1;\n    }\n}\n"
    },
    "@solidstate/contracts/utils/ReentrancyGuardStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ReentrancyGuardStorage {\n    struct Layout {\n        uint256 status;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ReentrancyGuard');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/arcadiaDiamonds/arcadians/ArcadiansFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { ERC721BaseInternal } from \"@solidstate/contracts/token/ERC721/base/ERC721BaseInternal.sol\";\nimport { ERC721BaseStorage } from \"@solidstate/contracts/token/ERC721/base/ERC721BaseStorage.sol\";\nimport { ERC721Metadata } from \"@solidstate/contracts/token/ERC721/metadata/ERC721Metadata.sol\";\nimport { ISolidStateERC721 } from \"@solidstate/contracts/token/ERC721/ISolidStateERC721.sol\";\nimport { SolidStateERC721 } from \"@solidstate/contracts/token/ERC721/SolidStateERC721.sol\";\nimport { ERC721Enumerable } from \"@solidstate/contracts/token/ERC721/enumerable/ERC721Enumerable.sol\";\nimport { ERC721Base } from \"@solidstate/contracts/token/ERC721/base/ERC721Base.sol\";\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\nimport { IERC721Metadata } from \"@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol\";\nimport { ArcadiansInternal } from \"./ArcadiansInternal.sol\";\nimport { ArcadiansStorage } from \"./ArcadiansStorage.sol\";\nimport { EnumerableMap } from '@solidstate/contracts/data/EnumerableMap.sol';\n\ncontract ArcadiansFacet is SolidStateERC721, ArcadiansInternal {\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n\n    function tokenURI(\n        uint256 tokenId\n    ) external view override (ERC721Metadata, IERC721Metadata) returns (string memory) {\n        return _tokenURI(tokenId);\n    }\n\n    function claimMerkle(uint totalAmount, bytes32[] memory proof)\n        external nonReentrant\n    {\n        ArcadiansStorage.Layout storage es = ArcadiansStorage.layout();\n\n        // Revert if the token was already claimed before\n        require(es.amountClaimed[msg.sender] < totalAmount, \"All tokens claimed\");\n\n        // Verify if is elegible\n        bytes memory leaf = abi.encode(msg.sender, totalAmount);\n        _validateLeaf(proof, leaf);\n\n        // Mint token to address\n        uint amountLeftToClaim = totalAmount - es.amountClaimed[msg.sender];\n        for (uint256 i = 0; i < amountLeftToClaim; i++) {\n            _safeMint(msg.sender, _totalSupply());\n        }\n        es.amountClaimed[msg.sender] += amountLeftToClaim;\n        emit ArcadianClaimedMerkle(msg.sender, amountLeftToClaim);\n    }\n\n    function getClaimedAmountMerkle(address account) external view returns (uint) {\n        return _getClaimedAmountMerkle(account);\n    }\n\n    function claimWhitelist(uint amount) external {\n        _consumeWhitelist(msg.sender, amount);\n        for (uint i = 0; i < amount; i++) {\n            _safeMint(msg.sender, _totalSupply());\n        }\n    }\n\n    function mint()\n        external payable nonReentrant\n    {\n        ArcadiansStorage.Layout storage arcadiansSL = ArcadiansStorage.layout();\n        require(msg.value == arcadiansSL.mintPrice, \"ArcadiansInternal._mint: Invalid pay amount\");\n        uint mintedTokens = _balanceOf(msg.sender) - arcadiansSL.amountClaimed[msg.sender];\n        require(mintedTokens < arcadiansSL.maxMintPerUser, \"ArcadiansInternal._mint: User maximum minted tokens reached\");\n        _safeMint(msg.sender, _totalSupply());\n    }\n\n    function setMintPrice(uint newMintPrice) external onlyManager {\n        _setMintPrice(newMintPrice);\n    }\n    function getMintPrice() external view returns (uint) {\n        return _getMintPrice();\n    }\n\n    function setMaxMintPerUser(uint newMaxMintPerUser) external onlyManager {\n        _setMaxMintPerUser(newMaxMintPerUser);\n    }\n    function getMaxMintPerUser() external view returns (uint) {\n        return _getMaxMintPerUser();\n    }\n\n    function setBaseURI(string memory baseURI) external onlyManager {\n        _setBaseURI(baseURI);\n    }\n    function getBaseURI() external view returns (string memory) {\n        return _getBaseURI();\n    }\n\n\n\n\n    // required overrides\n    function _handleApproveMessageValue(\n        address operator,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual override {\n        if (value > 0) revert SolidStateERC721__PayableApproveNotSupported();\n        super._handleApproveMessageValue(operator, tokenId, value);\n    }\n\n    function _handleTransferMessageValue(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual override {\n        if (value > 0) revert SolidStateERC721__PayableTransferNotSupported();\n        super._handleTransferMessageValue(from, to, tokenId, value);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        _unequipAllItems(tokenId);\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}"
    },
    "contracts/arcadiaDiamonds/arcadians/ArcadiansInit.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { MerkleStorage } from \"../merkle/MerkleStorage.sol\";\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { ArcadiansInternal } from \"./ArcadiansInternal.sol\";\n\ncontract ArcadiansInit is RolesInternal, ArcadiansInternal {\n    function init(bytes32 merkleRoot, string calldata baseUri, uint maxMintPerUser, uint mintPrice) external {\n        MerkleStorage.Layout storage es = MerkleStorage.layout();\n        es.merkleRoot = merkleRoot;\n\n        // Roles facet\n        _initRoles();\n\n        // Arcadians facet\n        _setBaseURI(baseUri);\n        _setMaxMintPerUser(maxMintPerUser);\n        _setMintPrice(mintPrice);\n    }\n}\n"
    },
    "contracts/arcadiaDiamonds/arcadians/ArcadiansInternal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { ERC721MetadataStorage } from \"@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol\";\nimport { UintUtils } from '@solidstate/contracts/utils/UintUtils.sol';\nimport { ArcadiansStorage } from \"./ArcadiansStorage.sol\";\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { WhitelistInternal } from \"../whitelist/WhitelistInternal.sol\";\nimport { MerkleInternal } from \"../merkle/MerkleInternal.sol\";\nimport { InventoryInternal } from \"../inventory/InventoryInternal.sol\";\n\ncontract ArcadiansInternal is RolesInternal, WhitelistInternal, MerkleInternal, InventoryInternal {\n\n    event MaxMintPerUserChanged(address indexed by, uint oldMaxMintPerUser, uint newMaxMintPerUser);\n    event MintPriceChanged(address indexed by, uint oldMintPrice, uint newMintPrice);\n    event BaseURIChanged(address indexed by, string oldBaseURI, string newBaseURI);\n    event InventoryAddressChanged(address indexed by, address indexed oldInventoryAddress, address indexed newInventoryAddress);\n    event ArcadianClaimedMerkle(address indexed to, uint256 indexed amount);\n\n    using UintUtils for uint256;\n\n    // function _getTokenURI(\n    //     uint256 tokenId\n    // ) internal view returns (string memory) {\n    //     string memory tokenUri = ERC721MetadataInternal._tokenURI(tokenId);\n    //     // IInventoryFacet inventory = IInventoryFacet(_getInventoryAddress());\n    //     // IInventoryFacet.EquippedItem[] memory equippedItem = inventory.equippedAll(tokenId);\n    //     // tokenUri = string.concat(tokenUri, \"/?tokenIds=\");\n    //     // for (uint i = 0; i < equippedItem.length; i++) {\n    //     //     string memory itemId = equippedItem[i].id.toString();\n    //     //     if (i == 0) {\n    //     //         tokenUri = string.concat(tokenUri, itemId);\n    //     //     } else {\n    //     //         tokenUri = string.concat(tokenUri, \",\", itemId);\n    //     //     }\n    //     // }\n    //     return tokenUri;\n    // }\n\n    function _setBaseURI(string memory newBaseURI) internal {\n        ERC721MetadataStorage.Layout storage ERC721SL = ERC721MetadataStorage.layout();\n        emit BaseURIChanged(msg.sender, ERC721SL.baseURI, newBaseURI);\n        ERC721SL.baseURI = newBaseURI;\n    }\n\n    function _getBaseURI() internal view returns (string memory) {\n        return ERC721MetadataStorage.layout().baseURI;\n    }\n\n    function _getClaimedAmountMerkle(address account) internal view returns (uint) {\n        return ArcadiansStorage.layout().amountClaimed[account];\n    }\n\n    function _setMaxMintPerUser(uint newMaxMintPerUser) internal {\n        ArcadiansStorage.Layout storage arcadiansSL = ArcadiansStorage.layout();\n        emit MaxMintPerUserChanged(msg.sender, arcadiansSL.maxMintPerUser, newMaxMintPerUser);\n        arcadiansSL.maxMintPerUser = newMaxMintPerUser;\n    }\n\n    function _getMintPrice() internal view returns (uint) {\n        return ArcadiansStorage.layout().mintPrice;\n    }\n\n    function _setMintPrice(uint newMintPrice) internal {\n        ArcadiansStorage.Layout storage arcadiansSL = ArcadiansStorage.layout();\n        emit MintPriceChanged(msg.sender, arcadiansSL.mintPrice, newMintPrice);\n        arcadiansSL.mintPrice = newMintPrice;\n    }\n\n    function _getMaxMintPerUser() internal view returns (uint) {\n        return ArcadiansStorage.layout().maxMintPerUser;\n    }\n}"
    },
    "contracts/arcadiaDiamonds/arcadians/ArcadiansStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nlibrary ArcadiansStorage {\n\n    bytes32 constant ARCADIANS_STORAGE_POSITION =\n        keccak256(\"equippable.storage.position\");\n\n    struct Layout {\n        // wallet => amount claimed \n        mapping(address => uint) amountClaimed;\n        uint maxMintPerUser;\n        uint mintPrice;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = ARCADIANS_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/inventory/InventoryFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n * Crated based in the following work:\n * Authors: Moonstream DAO (engineering@moonstream.to)\n * GitHub: https://github.com/G7DAO/contracts\n */\n\npragma solidity 0.8.19;\n\nimport { ReentrancyGuard } from \"@solidstate/contracts/utils/ReentrancyGuard.sol\";\nimport { ERC1155Holder } from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport { ERC721Holder } from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport { InventoryStorage } from \"./InventoryStorage.sol\";\nimport { InventoryInternal } from \"./InventoryInternal.sol\";\n\ncontract InventoryFacet is\n    ERC721Holder,\n    ERC1155Holder,\n    ReentrancyGuard,\n    InventoryInternal\n{\n\n    function numSlots() external view returns (uint) {\n        return _numSlots();\n    }\n\n    function getSlot(uint slot) external view returns (InventoryStorage.Slot memory) {\n        return _getSlot(slot);\n    }\n\n    function createSlot(\n        address itemAddress,\n        uint[] calldata allowedItemIds,\n        uint capacity,\n        bool unequippable\n    ) external onlyManager {\n        _createSlot(itemAddress, allowedItemIds, capacity, unequippable);\n    }\n\n    function allowItemInSlot(\n        address itemAddress,\n        uint itemId,\n        uint slot\n    ) external {\n        _allowItemInSlot(itemAddress, itemId, slot);\n    }\n\n    function getItemAllowedSlots(address itemAddress, uint itemId) external view returns (uint[] memory) {\n        return _getItemAllowedSlots(itemAddress, itemId);\n    }\n\n    function equip(\n        uint arcadianId,\n        address itemAddress,\n        uint itemId,\n        uint amount,\n        uint slot\n    ) external nonReentrant {\n        _equip(arcadianId, itemAddress, itemId, amount, slot);\n    }\n\n    function equipBatch(\n        uint arcadianId,\n        address itemAddress,\n        uint[] calldata itemIds,\n        uint[] calldata amounts,\n        uint[] calldata slots\n    ) external nonReentrant {\n        _equipBatch(arcadianId, itemAddress, itemIds, amounts, slots);\n    }\n\n    function unequip(\n        uint arcadianId,\n        uint slot,\n        bool unequipAll,\n        uint amount\n    ) external nonReentrant {\n        _unequip(arcadianId, slot, unequipAll, amount);\n    }\n\n    function unequipBatch(\n        uint arcadianId,\n        uint[] calldata slots,\n        bool[] calldata unequipAll,\n        uint[] calldata amounts\n    ) external {\n        _unequipBatch(arcadianId, slots, unequipAll, amounts);\n    }\n\n    function unequipAllItems(\n        uint arcadianId\n    ) external {\n        _unequipAllItems(arcadianId);\n    }\n\n    function equipped(\n        uint arcadianId,\n        uint slot\n    ) external view returns (InventoryStorage.EquippedItem memory item) {\n        return _equipped(arcadianId, slot);\n    }\n\n    function equippedAll(\n        uint arcadianId\n    ) external view returns (InventoryStorage.EquippedItem[] memory item) {\n        return _equippedAll(arcadianId);\n    }\n}"
    },
    "contracts/arcadiaDiamonds/inventory/InventoryInternal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { ReentrancyGuard } from \"@solidstate/contracts/utils/ReentrancyGuard.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { AddressUtils } from \"@solidstate/contracts/utils/AddressUtils.sol\";\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { InventoryStorage } from \"./InventoryStorage.sol\";\nimport { IERC1155 } from \"@solidstate/contracts/interfaces/IERC1155.sol\";\n\ncontract InventoryInternal is\n    ReentrancyGuard,\n    RolesInternal\n{\n\n    event ArcadiansAddressChanged(address indexed oldArcadiansAddress, address indexed newArcadiansAddress);\n\n    event ItemAllowedInSlot(\n        address indexed by, \n        address itemAddress, \n        uint itemId,\n        uint slot\n    );\n\n    event ItemEquipped(\n        address indexed by,\n        uint indexed arcadianId,\n        address indexed itemAddress,\n        uint itemId,\n        uint amount,\n        uint slot\n    );\n\n    event ItemUnequipped(\n        address indexed by,\n        uint indexed arcadianId,\n        uint slot,\n        uint amount\n    );\n\n    event SlotCreated(\n        address indexed by, \n        uint capacity,\n        bool unequippable,\n        uint slot\n    );\n\n    using AddressUtils for address;\n\n    modifier onlyValidSlot(uint slot) {\n        require(slot != 0, \"InventoryFacet: Slot id can't be zero\");\n        require(slot <= InventoryStorage.layout().numSlots, \"InventoryFacet: Inexistent slot id\");\n        _;\n    }\n\n    modifier onlyArcadianOwner(uint arcadianId) {\n        IERC721 arcadiansContract = IERC721(address(this));\n        require(\n            msg.sender == arcadiansContract.ownerOf(arcadianId),\n            \"InventoryFacet: Message sender is not owner of the arcadian\"\n        );\n        _;\n    }\n\n    modifier onlyValidAddress(address _address) {\n        require(_address != address(0), \"Invalid Address\");\n        _;\n    }\n\n    modifier onlyContract(address _address) {\n        require(_address.isContract(), \"InventoryFacet: Address given is not a contract\");\n        _;\n    }\n\n    function _numSlots() internal view returns (uint) {\n        return InventoryStorage.layout().numSlots;\n    }\n\n    function _unequip(\n        uint arcadianId,\n        uint slot,\n        bool unequipAll,\n        uint amount\n    ) internal onlyArcadianOwner(arcadianId) {\n        \n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        require(\n            !inventorySL.slots[slot].isUnequippable,\n            \"InventoryFacet._unequip: Slot is not unequippable\"\n        );\n\n        InventoryStorage.EquippedItem storage existingItem = inventorySL.equippedItems[arcadianId][slot];\n\n        if (unequipAll) {\n            amount = existingItem.amount;\n        } else {\n            require(\n                amount <= existingItem.amount,\n                \"InventoryFacet._unequip: Attempting to unequip too many items from the slot\"\n            );\n        }\n\n        IERC1155 erc1155Contract = IERC1155(existingItem.itemAddress);\n        erc1155Contract.safeTransferFrom(\n            address(this),\n            msg.sender,\n            existingItem.id,\n            amount,\n            ''\n        );\n\n        emit ItemUnequipped(\n            msg.sender,\n            arcadianId,\n            slot,\n            amount\n        );\n\n        existingItem.amount -= amount;\n        if (existingItem.amount == 0) {\n            delete inventorySL.equippedItems[arcadianId][slot];\n        }\n    }\n\n    function _unequipBatch(\n        uint arcadianId,\n        uint[] calldata slots,\n        bool[] calldata unequipAll,\n        uint[] calldata amounts\n    ) internal onlyArcadianOwner(arcadianId) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        for (uint i = 0; i < slots.length; i++) {\n\n            uint amountToUnequip = amounts[i];\n\n            require(\n                !inventorySL.slots[slots[i]].isUnequippable,\n                \"InventoryFacet._unequipBatch: Slot is not unequippable\"\n            );\n\n            InventoryStorage.EquippedItem storage existingItem = inventorySL.equippedItems[arcadianId][slots[i]];\n\n            if (unequipAll[i]) {\n                amountToUnequip = existingItem.amount;\n            } else {\n                require(\n                    amountToUnequip <= existingItem.amount,\n                    \"InventoryFacet._unequipBatch: Attempting to unequip too many items from the slot\"\n                );\n            }\n\n\n            IERC1155 erc1155Contract = IERC1155(existingItem.itemAddress);\n            erc1155Contract.safeTransferFrom(\n                address(this),\n                msg.sender,\n                existingItem.id,\n                amountToUnequip,\n                ''\n            );\n\n            existingItem.amount -= amountToUnequip;\n            if (existingItem.amount == 0) {\n                delete inventorySL.equippedItems[arcadianId][slots[i]];\n            }\n\n            emit ItemUnequipped(\n                msg.sender,\n                arcadianId,\n                slots[i],\n                amountToUnequip\n            );\n        }\n    }\n\n    function _unequipAllItems(\n        uint arcadianId\n    ) internal {\n\n        IERC721 arcadiansContract = IERC721(address(this));\n        try arcadiansContract.ownerOf(arcadianId) returns (address arcadianOwner) {\n            require(\n                msg.sender == arcadianOwner,\n                \"InventoryFacet._unequipAllItems: Caller not Arcadians contract neither or the arcadian owner\"\n            );\n\n            InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n            for (uint i = 0; i < inventorySL.numSlots; i++) {\n                uint slot = i + 1;\n\n                InventoryStorage.EquippedItem storage existingItem = inventorySL.equippedItems[arcadianId][slot];\n\n                // TODO: evaluate if unequippable items should also be unequiped in case of arcadian transfer\n                if (!inventorySL.slots[slot].isUnequippable && existingItem.amount > 0) {\n\n                    IERC1155 erc1155Contract = IERC1155(existingItem.itemAddress);\n                    erc1155Contract.safeTransferFrom(\n                        address(this),\n                        msg.sender,\n                        existingItem.id,\n                        existingItem.amount,\n                        ''\n                    );\n\n                    emit ItemUnequipped(\n                        arcadianOwner,\n                        arcadianId,\n                        slot,\n                        existingItem.amount\n                    );\n                    \n                    delete inventorySL.equippedItems[arcadianId][slot];\n                }\n            }\n        } catch {\n\n        }\n    }\n\n    function _validateItemForSlot(uint slot, uint itemId, uint amount) internal view {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        uint[] storage allowedItemsIds = inventorySL.slots[slot].allowedItemsIds;\n        for (uint i = 0; i < allowedItemsIds.length; i++) {\n            if (allowedItemsIds[i] == itemId) {\n                require(amount <= inventorySL.slots[slot].capacity, \"InventoryFacet._validateItemForSlot: Amount exceeds slot capacity\");\n                return;\n            }\n        }\n        revert(\"Item not elegible for slot\");\n    }\n\n    function _equip(\n        uint arcadianId,\n        address itemAddress,\n        uint itemId,\n        uint amount,\n        uint slot\n    ) internal onlyArcadianOwner(arcadianId) {\n\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        require(inventorySL.isItemAllowed[slot][itemAddress][itemId], \"InventoryFacet.equip: Item not elegible for slot\");\n        require(inventorySL.slots[slot].capacity >= amount, \"InventoryFacet.equip: Item amount exceeds slot capacity\");\n\n        if (inventorySL.equippedItems[arcadianId][slot].amount != 0) {\n            _unequip(arcadianId, slot, true, 0);\n        }\n        \n        IERC1155 erc1155Contract = IERC1155(itemAddress);\n        require(\n            erc1155Contract.balanceOf(msg.sender, itemId) >= amount,\n            \"InventoryFacet.equip: Message sender does not own enough of that item to equip\"\n        );\n\n        erc1155Contract.safeTransferFrom(\n            msg.sender,\n            address(this),\n            itemId,\n            amount,\n            ''\n        );\n\n        emit ItemEquipped(\n            msg.sender,\n            arcadianId,\n            itemAddress,\n            itemId,\n            amount,\n            slot\n        );\n\n        inventorySL.equippedItems[arcadianId][slot] = InventoryStorage.EquippedItem({\n            itemAddress: itemAddress,\n            id: itemId,\n            amount: amount\n        });\n    }\n\n    function _equipBatch(\n        uint arcadianId,\n        address itemAddress,\n        uint[] calldata itemsIds,\n        uint[] calldata amounts,\n        uint[] calldata slots\n    ) internal onlyArcadianOwner(arcadianId) {\n        require(slots.length == itemsIds.length && itemsIds.length == amounts.length, \"InventoryFacet._equipBatch: Input data length mismatch\");\n\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        IERC1155 erc1155Contract = IERC1155(itemAddress);\n\n        for (uint i = 0; i < itemsIds.length; i++) {\n\n            require(inventorySL.isItemAllowed[slots[i]][itemAddress][itemsIds[i]], \"InventoryFacet._equipBatch: Item not elegible for slot\");\n            require(inventorySL.slots[slots[i]].capacity >= amounts[i], \"InventoryFacet._equipBatch: Item amount exceeds slot capacity\");\n\n            require(\n                erc1155Contract.balanceOf(msg.sender, itemsIds[i]) >= amounts[i],\n                \"InventoryFacet.equip: Sender has insufficient item balance\"\n            );\n\n            if (inventorySL.equippedItems[arcadianId][slots[i]].amount > 0) {\n                _unequip(arcadianId, slots[i], true, 0);\n            }\n\n            emit ItemEquipped(\n                msg.sender,\n                arcadianId,\n                itemAddress,\n                itemsIds[i],\n                amounts[i],\n                slots[i]\n            );\n\n            inventorySL.equippedItems[arcadianId][slots[i]] = InventoryStorage.EquippedItem({\n                itemAddress: itemAddress,\n                id: itemsIds[i],\n                amount: amounts[i]\n            });\n        }\n\n        erc1155Contract.safeBatchTransferFrom(\n            msg.sender,\n            address(this),\n            itemsIds,\n            amounts,\n            ''\n        );\n    }\n\n    function _equipped(\n        uint arcadianId,\n        uint slot\n    ) internal view returns (InventoryStorage.EquippedItem memory item) {\n        return InventoryStorage.layout().equippedItems[arcadianId][slot];\n    }\n\n    function _equippedAll(\n        uint arcadianId\n    ) internal view returns (InventoryStorage.EquippedItem[] memory item) {\n        uint numSlots = InventoryStorage.layout().numSlots;\n        InventoryStorage.EquippedItem[] memory items = new InventoryStorage.EquippedItem[](numSlots);\n        for (uint i = 0; i < numSlots; i++) {\n            items[i] = _equipped(arcadianId, i+1);\n        }\n        return items;\n    }\n\n    function _createSlot(\n        address itemAddress,\n        uint[] calldata allowedItemsIds,\n        uint capacity,\n        bool unequippable\n    ) internal onlyContract(itemAddress) {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n\n        // slots are 1-index\n        inventorySL.numSlots += 1;\n        uint newSlot = inventorySL.numSlots;\n        inventorySL.slots[newSlot].isUnequippable = unequippable;\n        inventorySL.slots[newSlot].capacity = capacity;\n\n        if (allowedItemsIds.length > 0) {\n            _allowItemsInSlot(itemAddress, allowedItemsIds, newSlot);\n        }\n\n        emit SlotCreated(msg.sender, capacity, unequippable, newSlot);\n    }\n\n    function _allowItemInSlot(\n        address itemAddress,\n        uint itemId,\n        uint slot\n    ) internal onlyValidSlot(slot) onlyValidAddress(itemAddress) {\n        _allowItemInSlotUnchecked(itemAddress, itemId, slot);\n    }\n\n    function _allowItemsInSlot(\n        address itemAddress,\n        uint[] calldata itemsIds,\n        uint slot\n    ) internal virtual onlyValidSlot(slot) onlyValidAddress(itemAddress) {\n        for (uint i = 0; i < itemsIds.length; i++) {\n            _allowItemInSlotUnchecked(itemAddress, itemsIds[i], slot);\n        }\n    }\n\n    function _allowItemInSlotUnchecked(\n        address itemAddress,\n        uint itemId,\n        uint slot\n    ) internal virtual {\n        InventoryStorage.Layout storage inventorySL = InventoryStorage.layout();\n        inventorySL.slots[slot].allowedItemsIds.push(itemId);\n        inventorySL.itemAllowedSlots[itemAddress][itemId].push(slot);\n        inventorySL.isItemAllowed[slot][itemAddress][itemId] = true;\n        emit ItemAllowedInSlot(msg.sender, itemAddress, itemId, slot);\n    }\n\n    function _getItemAllowedSlots(address itemAddress, uint itemId) internal view returns (uint[] storage) {\n        return InventoryStorage.layout().itemAllowedSlots[itemAddress][itemId];\n    }\n\n    function _getSlot(uint slot) internal view returns (InventoryStorage.Slot storage) {\n        return InventoryStorage.layout().slots[slot];\n    }\n}"
    },
    "contracts/arcadiaDiamonds/inventory/InventoryStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport {ReentrancyGuard} from \"@solidstate/contracts/utils/ReentrancyGuard.sol\";\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\n\n/**\nLibInventory defines the storage structure used by the Inventory contract as a facet for an EIP-2535 Diamond\nproxy.\n */\nlibrary InventoryStorage {\n    bytes32 constant INVENTORY_STORAGE_POSITION =\n        keccak256(\"inventory.storage.position\");\n\n    uint constant ERC721_ITEM_TYPE = 721;\n    uint constant ERC1155_ITEM_TYPE = 1155;\n\n    // EquippedItem: holds the information of the currently equipped item for a specific slot in an arcadian\n    struct EquippedItem {\n        address itemAddress;\n        uint id;\n        uint amount;\n    }\n    // Slot: Holds the general information for a slot\n    struct Slot {\n        uint capacity;\n        bool isUnequippable;\n        uint[] allowedItemsIds;\n    }\n\n    struct Layout {\n        uint numSlots;\n        // Slot id => Slot\n        mapping(uint => Slot) slots;\n\n        // arcadian token ID => slot id => EquippedItem\n        mapping(uint => mapping(uint => EquippedItem)) equippedItems;\n\n        // Slot id => item id => is allowed to be equipped\n        mapping(uint => mapping(address => mapping(uint => bool))) isItemAllowed;\n\n        // item address => item id => allowed slots list\n        mapping(address => mapping(uint => uint[])) itemAllowedSlots;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage istore)\n    {\n        bytes32 position = INVENTORY_STORAGE_POSITION;\n        assembly {\n            istore.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/items/ItemsInit.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { ERC1155BaseInternal } from \"@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol\";\nimport { MerkleStorage } from \"../merkle/MerkleStorage.sol\";\nimport { RolesInternal } from \"../roles/RolesInternal.sol\";\nimport { ItemsInternal } from \"./ItemsInternal.sol\";\nimport { InventoryInternal } from \"../inventory/InventoryInternal.sol\";\n\ncontract ItemsInit is RolesInternal, ItemsInternal, InventoryInternal {    \n    function init(bytes32 merkleRoot, string calldata baseUri) external {\n        MerkleStorage.Layout storage es = MerkleStorage.layout();\n        es.merkleRoot = merkleRoot;\n\n        _initRoles();\n\n        _setBaseURI(baseUri);\n    }\n}\n"
    },
    "contracts/arcadiaDiamonds/items/ItemsInternal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { ERC1155BaseInternal } from \"@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol\";\nimport { ERC1155EnumerableInternal } from \"@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableInternal.sol\";\nimport { ERC1155MetadataInternal } from \"@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataInternal.sol\";\nimport { ItemsStorage } from \"./ItemsStorage.sol\";\nimport { MerkleInternal } from \"../merkle/MerkleInternal.sol\";\nimport { WhitelistInternal } from \"../whitelist/WhitelistInternal.sol\";\n\ncontract ItemsInternal is MerkleInternal, WhitelistInternal, ERC1155BaseInternal, ERC1155EnumerableInternal, ERC1155MetadataInternal {\n\n    event ItemClaimedMerkle(address indexed to, uint256 indexed itemId, uint amount);\n\n    function _claimMerkle(uint itemId, uint amount, bytes32[] memory proof)\n        internal\n    {\n        ItemsStorage.Layout storage itemsSL = ItemsStorage.layout();\n\n        // Revert if the token was Already claimed before\n        require(!itemsSL.claimedMerkle[msg.sender][itemId], \"ItemsInternal._claimMerkle: Already claimed\");\n        itemsSL.claimedMerkle[msg.sender][itemId] = true;\n\n        // Verify if is elegible\n        bytes memory leaf = abi.encode(msg.sender, itemId, amount);\n        _validateLeaf(proof, leaf);\n\n        // Mint token to address\n        _mint(msg.sender, itemId, amount, '');\n\n        emit ItemClaimedMerkle(msg.sender, itemId, amount);\n    }\n\n    function _claimMerkleBatch(uint256[] calldata itemIds, uint[] calldata amounts, bytes32[][] calldata proofs) \n        internal\n    {\n        require(itemIds.length == amounts.length, \"ItemsInternal._claimMerkleBatch: Inputs length mismatch\");\n        for (uint256 i = 0; i < itemIds.length; i++) {\n            _claimMerkle(itemIds[i], amounts[i], proofs[i]);\n        }\n    }\n    \n    function _claimWhitelist(uint[] calldata itemIds, uint[] calldata amounts) internal {\n        require(itemIds.length == amounts.length, \"ItemsInternal._claimWhitelist: Inputs length mismatch\");\n        uint totalAmount = 0;\n        for (uint i = 0; i < itemIds.length; i++) {\n            _mint(msg.sender, itemIds[i], amounts[i], '');\n            totalAmount += amounts[i];\n        }\n        _consumeWhitelist(msg.sender, totalAmount);\n    }\n\n    function _mint(address to, uint256 itemId, uint256 amount)\n        internal\n    {\n        ERC1155BaseInternal._mint(to, itemId, amount, \"\");\n    }\n\n    function _mintBatch(address to, uint256[] calldata ids, uint256[] calldata amounts)\n        internal\n    {\n        ERC1155BaseInternal._mintBatch(to, ids, amounts, \"\");\n    }\n\n    // required overrides\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n        override (ERC1155BaseInternal, ERC1155EnumerableInternal)\n    {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n}"
    },
    "contracts/arcadiaDiamonds/items/ItemsStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nlibrary ItemsStorage {\n\n    bytes32 constant ITEMS_STORAGE_POSITION =\n        keccak256(\"items.storage.position\");\n\n    struct Layout {\n        // wallet => token id => bool \n        mapping(address => mapping(uint => bool)) claimedMerkle;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = ITEMS_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/merkle/MerkleInternal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { MerkleProof } from \"@solidstate/contracts/cryptography/MerkleProof.sol\";\nimport { MerkleStorage } from \"./MerkleStorage.sol\";\nimport { RolesInternal } from \"./../roles/RolesInternal.sol\";\n\ncontract MerkleInternal is RolesInternal {\n\n    function _getMerkleRoot() internal view returns (bytes32) {\n        return MerkleStorage.layout().merkleRoot;\n    }\n\n    function _updateMerkleRoot(bytes32 merkleRoot) onlyManager internal {\n        MerkleStorage.layout().merkleRoot = merkleRoot;\n    }\n\n    // To create 'leaf' use abi.encode(leafProp1, leafProp2, ...)\n    function _validateLeaf(bytes32[] memory proof, bytes memory _leaf) internal view returns (bool isValid) {\n        bytes32 leaf = keccak256(bytes.concat(keccak256(_leaf)));\n        isValid = MerkleProof.verify(proof, MerkleStorage.layout().merkleRoot, leaf);\n        require(isValid, \"Data not included in merkle\");\n    }\n}"
    },
    "contracts/arcadiaDiamonds/merkle/MerkleStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nlibrary MerkleStorage {\n\n    bytes32 constant MERKLE_STORAGE_POSITION =\n        keccak256(\"merkle.storage.position\");\n\n    struct Layout {\n        bytes32 merkleRoot;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = MERKLE_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/roles/RolesInternal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { AccessControlInternal } from \"@solidstate/contracts/access/access_control/AccessControlInternal.sol\";\nimport { AccessControlStorage } from \"@solidstate/contracts/access/access_control/AccessControlStorage.sol\";\nimport { RolesStorage } from './RolesStorage.sol';\n\ncontract RolesInternal is AccessControlInternal {\n\n    modifier onlyDefaultAdmin() {\n        _checkRole(_getDefaultAdminRole());\n        _;\n    }\n\n    modifier onlyManager() {\n        _checkRole(_getManagerRole());\n        _;\n    }\n\n    modifier onlyMinter() {\n        _checkRole(_getMinterRole());\n        _;\n    }\n\n    function _getDefaultAdminRole() internal pure returns (bytes32) {\n        return AccessControlStorage.DEFAULT_ADMIN_ROLE;\n    }\n\n    function _getManagerRole() internal view returns (bytes32) {\n        return RolesStorage.layout().managerRole;\n    }\n\n    function _getMinterRole() internal view returns (bytes32) {\n        return RolesStorage.layout().minterRole;\n    }\n\n    function _initRoles() internal {\n        RolesStorage.Layout storage rolesSL = RolesStorage.layout();\n        rolesSL.managerRole = keccak256(\"manager.role\");\n        rolesSL.minterRole = keccak256(\"minter.role\");\n\n        _grantRole(_getDefaultAdminRole(), msg.sender);\n        _grantRole(_getManagerRole(), msg.sender);\n        _grantRole(_getMinterRole(), msg.sender);\n    }\n}"
    },
    "contracts/arcadiaDiamonds/roles/RolesStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nlibrary RolesStorage {\n\n    bytes32 constant ROLES_STORAGE_POSITION =\n        keccak256(\"roles.storage.position\");\n\n    struct Layout {\n        bytes32 managerRole;\n        bytes32 minterRole;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = ROLES_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/whitelist/WhitelistInternal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { MerkleProof } from \"@solidstate/contracts/cryptography/MerkleProof.sol\";\nimport { WhitelistStorage } from \"./WhitelistStorage.sol\";\nimport { RolesInternal } from \"./../roles/RolesInternal.sol\";\n\ncontract WhitelistInternal is RolesInternal {\n\n    event WhitelistBalanceChanged(address account, int amount, uint totalElegibleAmount, uint totalClaimedAmount);\n\n    function _getWhitelistClaimed(address account) internal view returns (uint) {\n        return WhitelistStorage.layout().claimed[account];\n    }\n\n    function _getWhitelistBalance(address account) internal view returns (uint) {\n        return WhitelistStorage.layout().elegible[account];\n    }\n\n    function _consumeWhitelist(address account, uint amount) internal {\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        require(whitelistSL.elegible[account] >= amount, \"WhitelistInternal._consumeWhitelist: amount exceeds elegible amount\");\n        whitelistSL.elegible[account] -= amount;\n        whitelistSL.claimed[account] += amount;\n        emit WhitelistBalanceChanged(msg.sender, int(amount), whitelistSL.elegible[account], whitelistSL.claimed[account]);\n    }\n\n    function _addToWhitelist(address account, uint amount) onlyManager internal {\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        whitelistSL.elegible[account] += amount;\n        emit WhitelistBalanceChanged(msg.sender, int(amount), whitelistSL.elegible[account], whitelistSL.claimed[account]);\n    }\n\n    function _addToWhitelistBatch(address[] calldata accounts, uint[] calldata amounts) onlyManager internal {\n        require(accounts.length == amounts.length, \"WhitelistInternal._addToWhitelistBatch: Inputs length mismatch\");\n        WhitelistStorage.Layout storage whitelistSL = WhitelistStorage.layout();\n        for (uint i = 0; i < accounts.length; i++) {\n            WhitelistStorage.layout().elegible[accounts[i]] += amounts[i];\n            emit WhitelistBalanceChanged(msg.sender, int(amounts[i]), whitelistSL.elegible[accounts[i]], whitelistSL.claimed[accounts[i]]);\n        }\n    }\n}"
    },
    "contracts/arcadiaDiamonds/whitelist/WhitelistStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nlibrary WhitelistStorage {\n\n    bytes32 constant WHITELIST_STORAGE_POSITION =\n        keccak256(\"whitelist.storage.position\");\n\n    struct Layout {\n        mapping(address => uint) claimed;\n        mapping(address => uint) elegible;\n    }\n\n    function layout()\n        internal\n        pure\n        returns (Layout storage es)\n    {\n        bytes32 position = WHITELIST_STORAGE_POSITION;\n        assembly {\n            es.slot := position\n        }\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 250
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}